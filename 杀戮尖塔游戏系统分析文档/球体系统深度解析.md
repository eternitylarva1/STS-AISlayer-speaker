# 球体系统深度解析

## 概述

杀戮尖塔的球体系统是缺陷者角色（Defect）的核心机制，通过引导不同类型的球体来产生各种效果。该系统提供了独特的资源管理和战斗策略，每个球体都有被动效果和唤起效果，为玩家提供了丰富的战术选择。

## 核心类分析

### AbstractOrb 抽象基类

`AbstractOrb` 是所有球体的抽象基类，定义了球体系统的核心接口和通用功能。

```java
public abstract class AbstractOrb {
    // 基本属性
    public String name;        // 球体名称
    public String description; // 球体描述
    public String ID;          // 球体标识符
    protected ArrayList<PowerTip> tips = new ArrayList<>();
    
    // 数值系统
    public int evokeAmount = 0;    // 唤起数量
    public int passiveAmount = 0;  // 被动数量
    protected int baseEvokeAmount = 0;   // 基础唤起数量
    protected int basePassiveAmount = 0; // 基础被动数量
    
    // 位置和渲染
    public float cX = 0.0F;        // 当前X坐标
    public float cY = 0.0F;        // 当前Y坐标
    public float tX;               // 目标X坐标
    public float tY;               // 目标Y坐标
    protected Color c = Settings.CREAM_COLOR.cpy(); // 颜色
    protected Color shineColor = new Color(1.0F, 1.0F, 1.0F, 0.0F); // 光泽颜色
    
    // 物理属性
    protected static final int W = 96; // 球体宽度
    public Hitbox hb = new Hitbox(96.0F * Settings.scale, 96.0F * Settings.scale);
    protected Texture img = null;
    protected BobEffect bobEffect = new BobEffect(3.0F * Settings.scale, 3.0F);
    
    // 动画属性
    protected float angle;              // 旋转角度
    protected float scale;              // 缩放比例
    protected float fontScale = 0.7F;   // 字体缩放
    protected boolean showEvokeValue = false; // 是否显示唤起值
    protected static final float CHANNEL_IN_TIME = 0.5F; // 引导动画时间
    protected float channelAnimTimer = 0.5F; // 引导动画计时器
    
    // 文本偏移
    protected static final float NUM_X_OFFSET = 20.0F * Settings.scale;
    protected static final float NUM_Y_OFFSET = -12.0F * Settings.scale;
}
```

#### 抽象方法

```java
// 必须实现的抽象方法
public abstract void updateDescription(); // 更新描述
public abstract void onEvoke();           // 唤起效果
public abstract void render(SpriteBatch sb); // 渲染
public abstract AbstractOrb makeCopy();   // 创建副本
public abstract void playChannelSFX();    // 播放引导音效
```

#### 生命周期钩子方法

```java
// 可选择性重写的钩子方法
public void onStartOfTurn() {}  // 回合开始时触发
public void onEndOfTurn() {}    // 回合结束时触发
public void triggerEvokeAnimation() {} // 触发唤起动画
```

#### 核心功能方法

```java
// 应用专注效果
public void applyFocus() {
    AbstractPower power = AbstractDungeon.player.getPower("Focus");
    if (power != null && !this.ID.equals("Plasma")) {
        // 等离子球不受专注影响
        this.passiveAmount = Math.max(0, this.basePassiveAmount + power.amount);
        this.evokeAmount = Math.max(0, this.baseEvokeAmount + power.amount);
    } else {
        this.passiveAmount = this.basePassiveAmount;
        this.evokeAmount = this.baseEvokeAmount;
    }
}

// 应用锁定效果
public static int applyLockOn(AbstractCreature target, int dmg) {
    int retVal = dmg;
    if (target.hasPower("Lockon")) {
        retVal = (int)(retVal * 1.5F); // 锁定增加50%伤害
    }
    return retVal;
}

// 获取随机球体
public static AbstractOrb getRandomOrb(boolean useCardRng) {
    ArrayList<AbstractOrb> orbs = new ArrayList<>();
    orbs.add(new Dark());
    orbs.add(new Frost());
    orbs.add(new Lightning());
    orbs.add(new Plasma());
    
    if (useCardRng) {
        return orbs.get(AbstractDungeon.cardRandomRng.random(orbs.size() - 1));
    }
    return orbs.get(MathUtils.random(orbs.size() - 1));
}
```

#### 更新系统

```java
// 主更新方法
public void update() {
    this.hb.update();
    
    // 悬停提示
    if (this.hb.hovered) {
        TipHelper.renderGenericTip(this.tX + 96.0F * Settings.scale, 
            this.tY + 64.0F * Settings.scale, this.name, this.description);
    }
    
    // 字体缩放动画
    this.fontScale = MathHelper.scaleLerpSnap(this.fontScale, 0.7F);
}

// 动画更新方法
public void updateAnimation() {
    this.bobEffect.update(); // 浮动效果
    
    // 位置插值
    this.cX = MathHelper.orbLerpSnap(this.cX, AbstractDungeon.player.animX + this.tX);
    this.cY = MathHelper.orbLerpSnap(this.cY, AbstractDungeon.player.animY + this.tY);
    
    // 引导动画计时器
    if (this.channelAnimTimer != 0.0F) {
        this.channelAnimTimer -= Gdx.graphics.getDeltaTime();
        if (this.channelAnimTimer < 0.0F) {
            this.channelAnimTimer = 0.0F;
        }
    }
    
    // 透明度和缩放动画
    this.c.a = Interpolation.pow2In.apply(1.0F, 0.01F, this.channelAnimTimer / 0.5F);
    this.scale = Interpolation.swingIn.apply(Settings.scale, 0.01F, this.channelAnimTimer / 0.5F);
}
```

#### 槽位系统

```java
// 设置球体槽位
public void setSlot(int slotNum, int maxOrbs) {
    // 计算距离和角度
    float dist = 160.0F * Settings.scale + maxOrbs * 10.0F * Settings.scale;
    float angle = 100.0F + maxOrbs * 12.0F;
    float offsetAngle = angle / 2.0F;
    
    // 计算当前球体的角度
    angle *= slotNum / (maxOrbs - 1.0F);
    angle += 90.0F - offsetAngle;
    
    // 计算目标位置
    this.tX = dist * MathUtils.cosDeg(angle) + AbstractDungeon.player.drawX;
    this.tY = dist * MathUtils.sinDeg(angle) + AbstractDungeon.player.drawY + 
              AbstractDungeon.player.hb_h / 2.0F;
    
    // 单个球体的特殊处理
    if (maxOrbs == 1) {
        this.tX = AbstractDungeon.player.drawX;
        this.tY = 160.0F * Settings.scale + AbstractDungeon.player.drawY + 
                  AbstractDungeon.player.hb_h / 2.0F;
    }
    
    this.hb.move(this.tX, this.tY);
}
```

#### 文本渲染系统

```java
// 渲染球体数值
protected void renderText(SpriteBatch sb) {
    if (!(this instanceof EmptyOrbSlot)) {
        if (this.showEvokeValue) {
            // 显示唤起值（青色）
            FontHelper.renderFontCentered(sb, FontHelper.cardEnergyFont_L, 
                Integer.toString(this.evokeAmount), 
                this.cX + NUM_X_OFFSET, 
                this.cY + this.bobEffect.y / 2.0F + NUM_Y_OFFSET, 
                new Color(0.2F, 1.0F, 1.0F, this.c.a), this.fontScale);
        } else {
            // 显示被动值（默认颜色）
            FontHelper.renderFontCentered(sb, FontHelper.cardEnergyFont_L, 
                Integer.toString(this.passiveAmount), 
                this.cX + NUM_X_OFFSET, 
                this.cY + this.bobEffect.y / 2.0F + NUM_Y_OFFSET, 
                this.c, this.fontScale);
        }
    }
}

// 显示唤起值
public void showEvokeValue() {
    this.showEvokeValue = true;
    this.fontScale = 1.5F; // 放大字体
}

// 隐藏唤起值
public void hideEvokeValues() {
    this.showEvokeValue = false;
}
```

## 具体球体实现

### Lightning（闪电球）

闪电球是攻击型球体，提供雷电伤害效果。

```java
public class Lightning extends AbstractOrb {
    public static final String ORB_ID = "Lightning";
    private static final OrbStrings orbString = CardCrawlGame.languagePack.getOrbString("Lightning");
    private float vfxTimer = 1.0F; // 特效计时器
    
    // 渲染常量
    private static final float PI_DIV_16 = 0.19634955F;
    private static final float ORB_WAVY_DIST = 0.05F;
    private static final float PI_4 = 12.566371F;
    private static final float ORB_BORDER_SCALE = 1.2F;
    
    public Lightning() {
        this.ID = "Lightning";
        this.img = ImageMaster.ORB_LIGHTNING;
        this.name = orbString.NAME;
        
        // 设置基础数值
        this.baseEvokeAmount = 8;
        this.evokeAmount = this.baseEvokeAmount;
        this.basePassiveAmount = 3;
        this.passiveAmount = this.basePassiveAmount;
        
        updateDescription();
        this.angle = MathUtils.random(360.0F);
        this.channelAnimTimer = 0.5F;
    }
    
    @Override
    public void updateDescription() {
        applyFocus();
        this.description = orbString.DESCRIPTION[0] + this.passiveAmount + 
                           orbString.DESCRIPTION[1] + this.evokeAmount + 
                           orbString.DESCRIPTION[2];
    }
    
    @Override
    public void onEvoke() {
        // 检查电力能力
        if (AbstractDungeon.player.hasPower("Electro")) {
            AbstractDungeon.actionManager.addToTop(new LightningOrbEvokeAction(
                new DamageInfo(AbstractDungeon.player, this.evokeAmount, 
                DamageInfo.DamageType.THORNS), true));
        } else {
            AbstractDungeon.actionManager.addToTop(new LightningOrbEvokeAction(
                new DamageInfo(AbstractDungeon.player, this.evokeAmount, 
                DamageInfo.DamageType.THORNS), false));
        }
    }
    
    @Override
    public void onEndOfTurn() {
        if (AbstractDungeon.player.hasPower("Electro")) {
            // 电力能力：直接触发唤起效果
            float speedTime = 0.2F / AbstractDungeon.player.orbs.size();
            if (Settings.FAST_MODE) {
                speedTime = 0.0F;
            }
            
            AbstractDungeon.actionManager.addToBottom(new VFXAction(
                new OrbFlareEffect(this, OrbFlareEffect.OrbFlareColor.LIGHTNING), speedTime));
            AbstractDungeon.actionManager.addToBottom(new LightningOrbEvokeAction(
                new DamageInfo(AbstractDungeon.player, this.passiveAmount, 
                DamageInfo.DamageType.THORNS), true));
        } else {
            // 标准被动效果
            AbstractDungeon.actionManager.addToBottom(new LightningOrbPassiveAction(
                new DamageInfo(AbstractDungeon.player, this.passiveAmount, 
                DamageInfo.DamageType.THORNS), this, false));
        }
    }
    
    @Override
    public void triggerEvokeAnimation() {
        CardCrawlGame.sound.play("ORB_LIGHTNING_EVOKE", 0.1F);
        AbstractDungeon.effectsQueue.add(new LightningOrbActivateEffect(this.cX, this.cY));
    }
    
    @Override
    public void updateAnimation() {
        super.updateAnimation();
        this.angle += Gdx.graphics.getDeltaTime() * 180.0F; // 旋转动画
        
        // 闪电特效生成
        this.vfxTimer -= Gdx.graphics.getDeltaTime();
        if (this.vfxTimer < 0.0F) {
            AbstractDungeon.effectList.add(new LightningOrbPassiveEffect(this.cX, this.cY));
            if (MathUtils.randomBoolean()) {
                AbstractDungeon.effectList.add(new LightningOrbPassiveEffect(this.cX, this.cY));
            }
            this.vfxTimer = MathUtils.random(0.15F, 0.8F);
        }
    }
    
    @Override
    public void render(SpriteBatch sb) {
        // 渲染光泽层
        this.c.a /= 2.0F;
        sb.setColor(this.shineColor);
        sb.setBlendFunction(770, 1);
        
        // 第一层光泽
        sb.draw(this.img, this.cX - 48.0F, this.cY - 48.0F + this.bobEffect.y, 
            48.0F, 48.0F, 96.0F, 96.0F, 
            this.scale + MathUtils.sin(this.angle / 12.566371F) * 0.05F + 0.19634955F, 
            this.scale * 1.2F, this.angle, 0, 0, 96, 96, false, false);
        
        // 第二层光泽
        sb.draw(this.img, this.cX - 48.0F, this.cY - 48.0F + this.bobEffect.y, 
            48.0F, 48.0F, 96.0F, 96.0F, 
            this.scale * 1.2F, this.scale + 
            MathUtils.sin(this.angle / 12.566371F) * 0.05F + 0.19634955F, 
            -this.angle, 0, 0, 96, 96, false, false);
        
        sb.setBlendFunction(770, 771);
        
        // 渲染主体
        sb.setColor(this.c);
        sb.draw(this.img, this.cX - 48.0F, this.cY - 48.0F + this.bobEffect.y, 
            48.0F, 48.0F, 96.0F, 96.0F, 
            this.scale, this.scale, this.angle / 12.0F, 0, 0, 96, 96, false, false);
        
        renderText(sb);
        this.hb.render(sb);
    }
    
    @Override
    public void playChannelSFX() {
        CardCrawlGame.sound.play("ORB_LIGHTNING_CHANNEL", 0.1F);
    }
    
    @Override
    public AbstractOrb makeCopy() {
        return new Lightning();
    }
}
```

### Frost（冰霜球）

冰霜球是防御型球体，提供格挡效果。

```java
public class Frost extends AbstractOrb {
    private static final OrbStrings orbString = CardCrawlGame.languagePack.getOrbString("Frost");
    public static final String ORB_ID = "Frost";
    
    // 渲染控制
    private boolean hFlip1;
    private boolean hFlip2;
    private float vfxTimer = 1.0F;
    private float vfxIntervalMin = 0.15F;
    private float vfxIntervalMax = 0.8F;
    
    public Frost() {
        this.hFlip1 = MathUtils.randomBoolean();
        this.hFlip2 = MathUtils.randomBoolean();
        
        this.ID = "Frost";
        this.name = orbString.NAME;
        
        // 设置基础数值
        this.baseEvokeAmount = 5;
        this.evokeAmount = this.baseEvokeAmount;
        this.basePassiveAmount = 2;
        this.passiveAmount = this.basePassiveAmount;
        
        updateDescription();
        this.channelAnimTimer = 0.5F;
    }
    
    @Override
    public void updateDescription() {
        applyFocus();
        this.description = orbString.DESCRIPTION[0] + this.passiveAmount + 
                           orbString.DESCRIPTION[1] + this.evokeAmount + 
                           orbString.DESCRIPTION[2];
    }
    
    @Override
    public void onEvoke() {
        AbstractDungeon.actionManager.addToTop(new GainBlockAction(
            AbstractDungeon.player, AbstractDungeon.player, this.evokeAmount));
    }
    
    @Override
    public void onEndOfTurn() {
        float speedTime = 0.6F / AbstractDungeon.player.orbs.size();
        if (Settings.FAST_MODE) {
            speedTime = 0.0F;
        }
        
        AbstractDungeon.actionManager.addToBottom(new VFXAction(
            new OrbFlareEffect(this, OrbFlareEffect.OrbFlareColor.FROST), speedTime));
        AbstractDungeon.actionManager.addToBottom(new GainBlockAction(
            AbstractDungeon.player, AbstractDungeon.player, this.passiveAmount, true));
    }
    
    @Override
    public void triggerEvokeAnimation() {
        CardCrawlGame.sound.play("ORB_FROST_EVOKE", 0.1F);
        AbstractDungeon.effectsQueue.add(new FrostOrbActivateEffect(this.cX, this.cY));
    }
    
    @Override
    public void updateAnimation() {
        super.updateAnimation();
        this.angle += Gdx.graphics.getDeltaTime() * 180.0F;
        
        // 冰霜特效生成
        this.vfxTimer -= Gdx.graphics.getDeltaTime();
        if (this.vfxTimer < 0.0F) {
            AbstractDungeon.effectList.add(new FrostOrbPassiveEffect(this.cX, this.cY));
            if (MathUtils.randomBoolean()) {
                AbstractDungeon.effectList.add(new FrostOrbPassiveEffect(this.cX, this.cY));
            }
            this.vfxTimer = MathUtils.random(this.vfxIntervalMin, this.vfxIntervalMax);
        }
    }
    
    @Override
    public void render(SpriteBatch sb) {
        sb.setColor(this.c);
        
        // 渲染三层冰霜图像
        sb.draw(ImageMaster.FROST_ORB_RIGHT, 
            this.cX - 48.0F + this.bobEffect.y / 4.0F, 
            this.cY - 48.0F + this.bobEffect.y / 4.0F, 
            48.0F, 48.0F, 96.0F, 96.0F, 
            this.scale, this.scale, 0.0F, 0, 0, 96, 96, this.hFlip1, false);
        
        sb.draw(ImageMaster.FROST_ORB_LEFT, 
            this.cX - 48.0F + this.bobEffect.y / 4.0F, 
            this.cY - 48.0F - this.bobEffect.y / 4.0F, 
            48.0F, 48.0F, 96.0F, 96.0F, 
            this.scale, this.scale, 0.0F, 0, 0, 96, 96, this.hFlip1, false);
        
        sb.draw(ImageMaster.FROST_ORB_MIDDLE, 
            this.cX - 48.0F - this.bobEffect.y / 4.0F, 
            this.cY - 48.0F + this.bobEffect.y / 2.0F, 
            48.0F, 48.0F, 96.0F, 96.0F, 
            this.scale, this.scale, 0.0F, 0, 0, 96, 96, this.hFlip2, false);
        
        renderText(sb);
        this.hb.render(sb);
    }
    
    @Override
    public void playChannelSFX() {
        CardCrawlGame.sound.play("ORB_FROST_CHANNEL", 0.1F);
    }
    
    @Override
    public AbstractOrb makeCopy() {
        return new Frost();
    }
}
```

### Plasma（等离子球）

等离子球是资源型球体，提供能量效果。

```java
public class Plasma extends AbstractOrb {
    public static final String ORB_ID = "Plasma";
    private static final OrbStrings orbString = CardCrawlGame.languagePack.getOrbString("Plasma");
    public static final String[] DESC = orbString.DESCRIPTION;
    
    // 特效控制
    private float vfxTimer = 1.0F;
    private float vfxIntervalMin = 0.1F;
    private float vfxIntervalMax = 0.4F;
    
    // 渲染常量
    private static final float ORB_WAVY_DIST = 0.04F;
    private static final float PI_4 = 12.566371F;
    
    public Plasma() {
        this.ID = "Plasma";
        this.img = ImageMaster.ORB_PLASMA;
        this.name = orbString.NAME;
        
        // 设置基础数值
        this.baseEvokeAmount = 2;
        this.evokeAmount = this.baseEvokeAmount;
        this.basePassiveAmount = 1;
        this.passiveAmount = this.basePassiveAmount;
        
        updateDescription();
        this.angle = MathUtils.random(360.0F);
        this.channelAnimTimer = 0.5F;
    }
    
    @Override
    public void updateDescription() {
        applyFocus();
        this.description = DESC[0] + this.evokeAmount + DESC[1];
    }
    
    @Override
    public void onEvoke() {
        AbstractDungeon.actionManager.addToTop(new GainEnergyAction(this.evokeAmount));
    }
    
    @Override
    public void onStartOfTurn() {
        // 回合开始时获得能量
        AbstractDungeon.actionManager.addToBottom(new VFXAction(
            new OrbFlareEffect(this, OrbFlareEffect.OrbFlareColor.PLASMA), 0.1F));
        AbstractDungeon.actionManager.addToBottom(new GainEnergyAction(this.passiveAmount));
    }
    
    @Override
    public void triggerEvokeAnimation() {
        CardCrawlGame.sound.play("ORB_PLASMA_EVOKE", 0.1F);
        AbstractDungeon.effectsQueue.add(new PlasmaOrbActivateEffect(this.cX, this.cY));
    }
    
    @Override
    public void updateAnimation() {
        super.updateAnimation();
        this.angle += Gdx.graphics.getDeltaTime() * 45.0F; // 较慢的旋转
        
        // 等离子特效生成
        this.vfxTimer -= Gdx.graphics.getDeltaTime();
        if (this.vfxTimer < 0.0F) {
            AbstractDungeon.effectList.add(new PlasmaOrbPassiveEffect(this.cX, this.cY));
            this.vfxTimer = MathUtils.random(this.vfxIntervalMin, this.vfxIntervalMax);
        }
    }
    
    @Override
    public void render(SpriteBatch sb) {
        // 渲染光泽层
        this.c.a /= 2.0F;
        sb.setColor(this.shineColor);
        
        sb.draw(this.img, this.cX - 48.0F, this.cY - 48.0F + this.bobEffect.y, 
            48.0F, 48.0F, 96.0F, 96.0F, 
            this.scale + MathUtils.sin(this.angle / 12.566371F) * 0.04F * Settings.scale, 
            this.scale, this.angle, 0, 0, 96, 96, false, false);
        
        sb.setBlendFunction(770, 1);
        sb.draw(this.img, this.cX - 48.0F, this.cY - 48.0F + this.bobEffect.y, 
            48.0F, 48.0F, 96.0F, 96.0F, 
            this.scale, this.scale + 
            MathUtils.sin(this.angle / 12.566371F) * 0.04F * Settings.scale, 
            -this.angle, 0, 0, 96, 96, false, false);
        
        sb.setBlendFunction(770, 771);
        
        // 等离子球使用特殊的文本渲染
        renderText(sb);
        this.hb.render(sb);
    }
    
    @Override
    protected void renderText(SpriteBatch sb) {
        if (this.showEvokeValue) {
            FontHelper.renderFontCentered(sb, FontHelper.cardEnergyFont_L, 
                Integer.toString(this.evokeAmount), 
                this.cX + NUM_X_OFFSET, 
                this.cY + this.bobEffect.y / 2.0F + NUM_Y_OFFSET - 4.0F * Settings.scale, 
                new Color(0.2F, 1.0F, 1.0F, this.c.a), this.fontScale);
        }
    }
    
    @Override
    public void playChannelSFX() {
        CardCrawlGame.sound.play("ORB_PLASMA_CHANNEL", 0.1F);
    }
    
    @Override
    public AbstractOrb makeCopy() {
        return new Plasma();
    }
}
```

### EmptyOrbSlot（空槽位）

空槽位用于显示未填充的球体位置。

```java
public class EmptyOrbSlot extends AbstractOrb {
    public static final String ORB_ID = "Empty";
    
    public EmptyOrbSlot() {
        this.ID = "Empty";
        this.name = "";
        this.baseEvokeAmount = 0;
        this.evokeAmount = this.baseEvokeAmount;
        this.basePassiveAmount = 0;
        this.passiveAmount = this.basePassiveAmount;
        
        updateDescription();
        this.channelAnimTimer = 0.5F;
    }
    
    @Override
    public void updateDescription() {
        this.description = "";
    }
    
    @Override
    public void onEvoke() {
        // 空槽位没有唤起效果
    }
    
    @Override
    public void render(SpriteBatch sb) {
        // 渲染空槽位图像
        sb.setColor(this.c);
        sb.draw(ImageMaster.ORB_SLOT, this.cX - 48.0F, this.cY - 48.0F + this.bobEffect.y, 
            48.0F, 48.0F, 96.0F, 96.0F, this.scale, this.scale, 0.0F, 0, 0, 96, 96, false, false);
        
        this.hb.render(sb);
    }
    
    @Override
    public void playChannelSFX() {
        // 空槽位没有音效
    }
    
    @Override
    public AbstractOrb makeCopy() {
        return new EmptyOrbSlot();
    }
}
```

## 球体管理系统

### 球体槽位管理

缺陷者角色通过 `orbs` 列表管理球体：

```java
// 在 AbstractPlayer 中
public ArrayList<AbstractOrb> orbs = new ArrayList<>();

// 初始化球体槽位
public void initializeOrbs(int maxOrbs) {
    orbs.clear();
    for (int i = 0; i < maxOrbs; i++) {
        orbs.add(new EmptyOrbSlot());
    }
    updateOrbPositions();
}

// 更新球体位置
public void updateOrbPositions() {
    for (int i = 0; i < orbs.size(); i++) {
        orbs.get(i).setSlot(i, orbs.size());
    }
}
```

### 球体引导系统

```java
// 引导球体
public void channelOrb(AbstractOrb orb) {
    // 找到第一个空槽位
    for (int i = 0; i < orbs.size(); i++) {
        if (orbs.get(i) instanceof EmptyOrbSlot) {
            orbs.set(i, orb);
            orb.setSlot(i, orbs.size());
            orb.playChannelSFX();
            updateOrbPositions();
            return;
        }
    }
    
    // 如果没有空槽位，替换最后一个
    if (orbs.size() > 0) {
        orbs.set(orbs.size() - 1, orb);
        orb.setSlot(orbs.size() - 1, orbs.size());
        orb.playChannelSFX();
        updateOrbPositions();
    }
}

// 唤起球体
public void evokeOrb(int index) {
    if (index >= 0 && index < orbs.size()) {
        AbstractOrb orb = orbs.get(index);
        if (!(orb instanceof EmptyOrbSlot)) {
            orb.triggerEvokeAnimation();
            orb.onEvoke();
            orbs.set(index, new EmptyOrbSlot());
            updateOrbPositions();
        }
    }
}

// 唤起所有球体
public void evokeAllOrbs() {
    for (int i = orbs.size() - 1; i >= 0; i--) {
        evokeOrb(i);
    }
}
```

## 视觉效果系统

### 球体特效

每个球体都有独特的视觉效果：

1. **闪电球** - 闪电效果、快速旋转、电弧粒子
2. **冰霜球** - 冰晶效果、三层图像渲染、冰霜粒子
3. **等离子球** - 能量波动、缓慢旋转、能量粒子
4. **空槽位** - 简单的槽位图像、无特效

### 渲染技术

```java
// 多层渲染技术
public void render(SpriteBatch sb) {
    // 1. 渲染光泽层（半透明）
    this.c.a /= 2.0F;
    sb.setColor(this.shineColor);
    sb.setBlendFunction(770, 1); // 加法混合
    
    // 2. 渲染主体
    sb.setBlendFunction(770, 771); // 标准混合
    sb.setColor(this.c);
    
    // 3. 渲染文本
    renderText(sb);
    
    // 4. 渲染碰撞框
    this.hb.render(sb);
}
```

### 动画系统

```java
// 浮动效果
protected BobEffect bobEffect = new BobEffect(3.0F * Settings.scale, 3.0F);

// 旋转动画
this.angle += Gdx.graphics.getDeltaTime() * rotationSpeed;

// 缩放动画
this.scale = Interpolation.swingIn.apply(Settings.scale, 0.01F, 
    this.channelAnimTimer / 0.5F);

// 透明度动画
this.c.a = Interpolation.pow2In.apply(1.0F, 0.01F, 
    this.channelAnimTimer / 0.5F);
```

## 音效系统

### 音效管理

每个球体都有对应的音效：

```java
// 引导音效
public void playChannelSFX() {
    CardCrawlGame.sound.play("ORB_" + this.ID + "_CHANNEL", 0.1F);
}

// 唤起音效
public void triggerEvokeAnimation() {
    CardCrawlGame.sound.play("ORB_" + this.ID + "_EVOKE", 0.1F);
    // 视觉效果
    AbstractDungeon.effectsQueue.add(new SpecificOrbActivateEffect(this.cX, this.cY));
}
```

## 游戏机制集成

### 专注系统

专注能力会影响球体的数值：

```java
public void applyFocus() {
    AbstractPower power = AbstractDungeon.player.getPower("Focus");
    if (power != null && !this.ID.equals("Plasma")) {
        // 等离子球不受专注影响
        this.passiveAmount = Math.max(0, this.basePassiveAmount + power.amount);
        this.evokeAmount = Math.max(0, this.baseEvokeAmount + power.amount);
    } else {
        this.passiveAmount = this.basePassiveAmount;
        this.evokeAmount = this.baseEvokeAmount;
    }
}
```

### 锁定效果

锁定能力会增加闪电球的伤害：

```java
public static int applyLockOn(AbstractCreature target, int dmg) {
    int retVal = dmg;
    if (target.hasPower("Lockon")) {
        retVal = (int)(retVal * 1.5F); // 50%伤害加成
    }
    return retVal;
}
```

### 电力能力

电力能力会改变闪电球的行为：

```java
public void onEndOfTurn() {
    if (AbstractDungeon.player.hasPower("Electro")) {
        // 电力：直接触发唤起效果
        AbstractDungeon.actionManager.addToBottom(new LightningOrbEvokeAction(
            new DamageInfo(AbstractDungeon.player, this.passiveAmount, 
            DamageInfo.DamageType.THORNS), true));
    } else {
        // 标准：被动效果
        AbstractDungeon.actionManager.addToBottom(new LightningOrbPassiveAction(
            new DamageInfo(AbstractDungeon.player, this.passiveAmount, 
            DamageInfo.DamageType.THORNS), this, false));
    }
}
```

## 性能优化

### 特效频率控制

```java
// 不同球体使用不同的特效生成频率
// 闪电球：0.15-0.8秒
this.vfxTimer = MathUtils.random(0.15F, 0.8F);

// 冰霜球：0.15-0.8秒
this.vfxTimer = MathUtils.random(this.vfxIntervalMin, this.vfxIntervalMax);

// 等离子球：0.1-0.4秒
this.vfxTimer = MathUtils.random(this.vfxIntervalMin, this.vfxIntervalMax);
```

### 快速模式优化

```java
// 在快速模式下减少动画时间
float speedTime = 0.6F / AbstractDungeon.player.orbs.size();
if (Settings.FAST_MODE) {
    speedTime = 0.0F;
}
```

### 条件渲染

```java
// 只在非空槽位渲染文本
protected void renderText(SpriteBatch sb) {
    if (!(this instanceof EmptyOrbSlot)) {
        // 渲染逻辑
    }
}
```

## 扩展性设计

### 新球体添加

添加新球体的步骤：

1. 创建继承 `AbstractOrb` 的新类
2. 实现必要的抽象方法
3. 在 `getRandomOrb` 中添加新球体
4. 添加对应的本地化字符串
5. 创建相应的视觉效果和音效

### 模组支持

```java
// 模组可以通过反射注册新球体
public static void registerOrb(String id, Class<? extends AbstractOrb> orbClass) {
    // 注册逻辑
}
```

## 总结

杀戮尖塔的球体系统是一个精心设计的机制系统，具有以下特点：

1. **模块化设计** - 清晰的抽象基类和具体实现分离
2. **丰富的视觉效果** - 每个球体都有独特的渲染和动画
3. **灵活的槽数系统** - 支持动态调整球体槽位数量
4. **深度机制集成** - 与专注、锁定、电力等能力系统紧密结合
5. **性能优化** - 智能的特效频率控制和快速模式支持
6. **音效系统完善** - 每个球体都有对应的音效
7. **扩展性强** - 易于添加新球体和模组支持

该系统通过不同类型的球体为玩家提供了丰富的战术选择，每个球体都有独特的被动效果和唤起效果，是缺陷者角色核心玩法的重要组成部分。球体的视觉表现和音效设计也极大地增强了游戏的沉浸感和策略深度。