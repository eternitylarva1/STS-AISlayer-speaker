# 杀戮尖塔卡牌系统深度解析

## 概述

杀戮尖塔的卡牌系统是游戏的核心机制，负责管理所有卡牌的创建、使用、升级和交互。该系统采用面向对象设计，通过抽象基类定义通用行为，具体卡牌类实现特定功能，形成了灵活且可扩展的架构。

## 核心组件

### 1. AbstractCard - 卡牌基类

`AbstractCard` 是所有卡牌的抽象基类，定义了卡牌的基本属性、行为和渲染机制。

```java
public abstract class AbstractCard implements Comparable<AbstractCard> {
    // 基本属性
    public CardType type;
    public int cost;
    public int costForTurn;
    public CardRarity rarity;
    public CardColor color;
    public CardTarget target;
    
    // 数值属性
    public int baseDamage = -1, baseBlock = -1, baseMagicNumber = -1;
    public int damage = -1, block = -1, magicNumber = -1;
    public boolean isDamageModified = false;
    public boolean isBlockModified = false;
    public boolean isMagicNumberModified = false;
    
    // 状态标志
    public boolean upgraded = false;
    public boolean exhaust = false;
    public boolean isEthereal = false;
    public boolean retain = false;
    public boolean selfRetain = false;
    
    // 视觉属性
    public String name;
    public String rawDescription;
    public String cardID;
    public TextureAtlas.AtlasRegion portrait;
    
    // 位置和缩放
    public float current_x, current_y;
    public float target_x, target_y;
    public float drawScale = 0.7F;
    public float targetDrawScale = 0.7F;
    public float angle = 0.0F;
    public float targetAngle = 0.0F;
    
    // 交互相关
    public Hitbox hb = new Hitbox(IMG_WIDTH_S, IMG_HEIGHT_S);
    public boolean hovered = false;
    public boolean isSelected = false;
}
```

#### 卡牌类型枚举

```java
public enum CardType {
    ATTACK,    // 攻击卡牌
    SKILL,     // 技能卡牌
    POWER,     // 能力卡牌
    STATUS,    // 状态卡牌
    CURSE      // 诅咒卡牌
}
```

#### 卡牌稀有度枚举

```java
public enum CardRarity {
    BASIC,     // 基础卡牌
    SPECIAL,   // 特殊卡牌
    COMMON,    // 普通卡牌
    UNCOMMON,  // 罕见卡牌
    RARE,      // 稀有卡牌
    CURSE      // 诅咒卡牌
}
```

#### 卡牌颜色枚举

```java
public enum CardColor {
    RED,       // 铁甲战士
    GREEN,     // 静默猎手
    BLUE,      // 故障机器人
    PURPLE,    // 观察者
    COLORLESS, // 无色
    CURSE      // 诅咒
}
```

#### 卡牌目标枚举

```java
public enum CardTarget {
    ENEMY,         // 敌人
    ALL_ENEMY,     // 所有敌人
    SELF,          // 自己
    NONE,          // 无目标
    SELF_AND_ENEMY, // 自己和敌人
    ALL            // 所有
}
```

### 2. 卡牌初始化系统

#### 构造函数

```java
public AbstractCard(String id, String name, String imgUrl, int cost, 
                    String rawDescription, CardType type, CardColor color, 
                    CardRarity rarity, CardTarget target, DamageInfo.DamageType dType) {
    this.originalName = name;
    this.name = name;
    this.cardID = id;
    this.assetUrl = imgUrl;
    
    // 加载卡牌图像
    this.portrait = cardAtlas.findRegion(imgUrl);
    this.jokePortrait = oldCardAtlas.findRegion(imgUrl);
    if (this.portrait == null) {
        if (this.jokePortrait != null) {
            this.portrait = this.jokePortrait;
        } else {
            this.portrait = cardAtlas.findRegion("status/beta");
        }
    }
    
    // 设置基本属性
    this.cost = cost;
    this.costForTurn = cost;
    this.rawDescription = rawDescription;
    this.type = type;
    this.color = color;
    this.rarity = rarity;
    this.target = target;
    this.damageType = dType;
    this.damageTypeForTurn = dType;
    
    // 初始化显示
    createCardImage();
    initializeTitle();
    initializeDescription();
    updateTransparency();
    this.uuid = UUID.randomUUID();
}
```

#### 静态初始化

```java
public static void initialize() {
    long startTime = System.currentTimeMillis();
    cardAtlas = new TextureAtlas(Gdx.files.internal("cards/cards.atlas"));
    oldCardAtlas = new TextureAtlas(Gdx.files.internal("oldCards/cards.atlas"));
    orbAtlas = new TextureAtlas(Gdx.files.internal("orbs/orb.atlas"));
    
    // 加载能量球图像
    orb_red = orbAtlas.findRegion("red");
    orb_green = orbAtlas.findRegion("green");
    orb_blue = orbAtlas.findRegion("blue");
    orb_purple = orbAtlas.findRegion("purple");
    orb_card = orbAtlas.findRegion("card");
    orb_potion = orbAtlas.findRegion("potion");
    orb_relic = orbAtlas.findRegion("relic");
    orb_special = orbAtlas.findRegion("special");
    
    logger.info("Card Image load time: " + (System.currentTimeMillis() - startTime) + "ms");
}
```

### 3. 卡牌升级系统

#### 升级检查

```java
public boolean canUpgrade() {
    if (this.type == CardType.CURSE) {
        return false;
    }
    if (this.type == CardType.STATUS) {
        return false;
    }
    if (this.upgraded) {
        return false;
    }
    return true;
}
```

#### 升级方法

```java
protected void upgradeDamage(int amount) {
    this.baseDamage += amount;
    this.upgradedDamage = true;
}

protected void upgradeBlock(int amount) {
    this.baseBlock += amount;
    this.upgradedBlock = true;
}

protected void upgradeMagicNumber(int amount) {
    this.baseMagicNumber += amount;
    this.magicNumber = this.baseMagicNumber;
    this.upgradedMagicNumber = true;
}

protected void upgradeName() {
    this.timesUpgraded++;
    this.upgraded = true;
    this.name += "+";
    initializeTitle();
}

protected void upgradeBaseCost(int newBaseCost) {
    int diff = this.costForTurn - this.cost;
    this.cost = newBaseCost;
    
    if (this.costForTurn > 0) {
        this.costForTurn = this.cost + diff;
    }
    if (this.costForTurn < 0) {
        this.costForTurn = 0;
    }
    this.upgradedCost = true;
}
```

#### 升级显示

```java
public void displayUpgrades() {
    if (this.upgradedCost) {
        this.isCostModified = true;
    }
    
    if (this.upgradedDamage) {
        this.damage = this.baseDamage;
        this.isDamageModified = true;
    }
    
    if (this.upgradedBlock) {
        this.block = this.baseBlock;
        this.isBlockModified = true;
    }
    
    if (this.upgradedMagicNumber) {
        this.magicNumber = this.baseMagicNumber;
        this.isMagicNumberModified = true;
    }
}
```

### 4. 卡牌使用系统

#### 使用条件检查

```java
public boolean canUse(AbstractPlayer p, AbstractMonster m) {
    // 状态卡牌检查
    if (this.type == CardType.STATUS && this.costForTurn < -1 && 
        !AbstractDungeon.player.hasRelic("Medical Kit")) {
        return false;
    }
    
    // 诅咒卡牌检查
    if (this.type == CardType.CURSE && this.costForTurn < -1 && 
        !AbstractDungeon.player.hasRelic("Blue Candle")) {
        return false;
    }
    
    // 基本使用条件
    if (cardPlayable(m) && hasEnoughEnergy()) {
        return true;
    }
    
    return false;
}
```

#### 能量检查

```java
public boolean hasEnoughEnergy() {
    if (AbstractDungeon.actionManager.turnHasEnded) {
        this.cantUseMessage = TEXT[9];
        return false;
    }
    
    // 检查能力限制
    for (AbstractPower p : AbstractDungeon.player.powers) {
        if (!p.canPlayCard(this)) {
            this.cantUseMessage = TEXT[13];
            return false;
        }
    }
    
    // 检查缠绕状态
    if (AbstractDungeon.player.hasPower("Entangled") && this.type == CardType.ATTACK) {
        this.cantUseMessage = TEXT[10];
        return false;
    }
    
    // 检查遗物限制
    for (AbstractRelic r : AbstractDungeon.player.relics) {
        if (!r.canPlay(this)) {
            return false;
        }
    }
    
    // 检查诅咒限制
    for (AbstractBlight b : AbstractDungeon.player.blights) {
        if (!b.canPlay(this)) {
            return false;
        }
    }
    
    // 检查手牌限制
    for (AbstractCard c : AbstractDungeon.player.hand.group) {
        if (!c.canPlay(this)) {
            return false;
        }
    }
    
    // 能量检查
    if (EnergyPanel.totalCount >= this.costForTurn || freeToPlay() || this.isInAutoplay) {
        return true;
    }
    
    this.cantUseMessage = TEXT[11];
    return false;
}
```

#### 免费使用检查

```java
public boolean freeToPlay() {
    if (this.freeToPlayOnce) {
        return true;
    }
    
    if (AbstractDungeon.player != null && AbstractDungeon.currMapNode != null && 
        (AbstractDungeon.getCurrRoom()).phase == AbstractRoom.RoomPhase.COMBAT && 
        AbstractDungeon.player.hasPower("FreeAttackPower") && this.type == CardType.ATTACK) {
        return true;
    }
    
    return false;
}
```

### 5. 卡牌数值计算系统

#### 伤害计算

```java
public void applyPowers() {
    applyPowersToBlock();
    AbstractPlayer player = AbstractDungeon.player;
    this.isDamageModified = false;
    
    if (!this.isMultiDamage) {
        float tmp = this.baseDamage;
        
        // 遗物伤害修正
        for (AbstractRelic r : player.relics) {
            tmp = r.atDamageModify(tmp, this);
            if (this.baseDamage != (int)tmp) {
                this.isDamageModified = true;
            }
        }
        
        // 玩家能力伤害修正
        for (AbstractPower p : player.powers) {
            tmp = p.atDamageGive(tmp, this.damageTypeForTurn, this);
        }
        
        // 姿态伤害修正
        tmp = player.stance.atDamageGive(tmp, this.damageTypeForTurn, this);
        if (this.baseDamage != (int)tmp) {
            this.isDamageModified = true;
        }
        
        // 最终伤害修正
        for (AbstractPower p : player.powers) {
            tmp = p.atDamageFinalGive(tmp, this.damageTypeForTurn, this);
        }
        
        // 确保伤害不为负
        if (tmp < 0.0F) {
            tmp = 0.0F;
        }
        
        // 设置最终伤害
        if (this.baseDamage != MathUtils.floor(tmp)) {
            this.isDamageModified = true;
        }
        this.damage = MathUtils.floor(tmp);
    } else {
        // 多目标伤害计算
        ArrayList<AbstractMonster> m = (AbstractDungeon.getCurrRoom()).monsters.monsters;
        float[] tmp = new float[m.size()];
        
        for (int i = 0; i < tmp.length; i++) {
            tmp[i] = this.baseDamage;
        }
        
        // 对每个目标计算伤害
        for (int i = 0; i < tmp.length; i++) {
            for (AbstractRelic r : player.relics) {
                tmp[i] = r.atDamageModify(tmp[i], this);
                if (this.baseDamage != (int)tmp[i]) {
                    this.isDamageModified = true;
                }
            }
            
            for (AbstractPower p : player.powers) {
                tmp[i] = p.atDamageGive(tmp[i], this.damageTypeForTurn, this);
            }
            
            tmp[i] = player.stance.atDamageGive(tmp[i], this.damageTypeForTurn, this);
            
            for (AbstractPower p : player.powers) {
                tmp[i] = p.atDamageFinalGive(tmp[i], this.damageTypeForTurn, this);
            }
            
            if (tmp[i] < 0.0F) {
                tmp[i] = 0.0F;
            }
        }
        
        this.multiDamage = new int[tmp.length];
        for (int i = 0; i < tmp.length; i++) {
            this.multiDamage[i] = MathUtils.floor(tmp[i]);
            if (this.baseDamage != this.multiDamage[i]) {
                this.isDamageModified = true;
            }
        }
    }
}
```

#### 格挡计算

```java
public void applyPowersToBlock() {
    AbstractPlayer player = AbstractDungeon.player;
    this.isBlockModified = false;
    
    float tmp = this.baseBlock;
    
    // 遗物格挡修正
    for (AbstractRelic r : player.relics) {
        tmp = r.atBlockModify(tmp, this);
        if (this.baseBlock != (int)tmp) {
            this.isBlockModified = true;
        }
    }
    
    // 玩家能力格挡修正
    for (AbstractPower p : player.powers) {
        tmp = p.atBlockGive(tmp, this);
    }
    
    // 姿态格挡修正
    tmp = player.stance.atBlockGive(tmp, this);
    if (this.baseBlock != (int)tmp) {
        this.isBlockModified = true;
    }
    
    // 最终格挡修正
    for (AbstractPower p : player.powers) {
        tmp = p.atBlockFinalGive(tmp, this);
    }
    
    // 确保格挡不为负
    if (tmp < 0.0F) {
        tmp = 0.0F;
    }
    
    // 设置最终格挡
    if (this.baseDamage != MathUtils.floor(tmp)) {
        this.isBlockModified = true;
    }
    this.block = MathUtils.floor(tmp);
}
```

### 6. 卡牌描述系统

#### 描述初始化

```java
public void initializeDescription() {
    this.keywords.clear();
    if (Settings.lineBreakViaCharacter) {
        initializeDescriptionCN();
        return;
    }
    
    this.description.clear();
    int numLines = 1;
    
    sbuilder.setLength(0);
    float currentWidth = 0.0F;
    
    for (String word : this.rawDescription.split(" ")) {
        boolean isKeyword = false;
        
        sbuilder2.setLength(0);
        sbuilder2.append(" ");
        if (word.length() > 0 && word.charAt(word.length() - 1) != ']' && 
            !Character.isLetterOrDigit(word.charAt(word.length() - 1))) {
            sbuilder2.insert(0, word.charAt(word.length() - 1));
            word = word.substring(0, word.length() - 1);
        }
        
        // 检查关键词
        String keywordTmp = word.toLowerCase();
        keywordTmp = dedupeKeyword(keywordTmp);
        
        if (GameDictionary.keywords.containsKey(keywordTmp)) {
            if (!this.keywords.contains(keywordTmp)) {
                this.keywords.add(keywordTmp);
            }
            
            gl.reset();
            gl.setText(FontHelper.cardDescFont_N, sbuilder2);
            float tmp = gl.width;
            gl.setText(FontHelper.cardDescFont_N, word);
            gl.width += tmp;
            isKeyword = true;
        }
        // 处理能量图标
        else if (!word.isEmpty() && word.charAt(0) == '[') {
            gl.reset();
            gl.setText(FontHelper.cardDescFont_N, sbuilder2);
            gl.width += CARD_ENERGY_IMG_WIDTH;
            
            // 根据卡牌颜色添加对应能量关键词
            switch (this.color) {
                case BASIC:
                    if (!this.keywords.contains("[R]")) {
                        this.keywords.add("[R]");
                    }
                    break;
                case CURSE:
                    if (!this.keywords.contains("[G]")) {
                        this.keywords.add("[G]");
                    }
                    break;
                // ... 其他颜色处理
            }
        }
        // 处理换行
        else if (word.equals("NL")) {
            gl.width = 0.0F;
            word = "";
            this.description.add(new DescriptionLine(sbuilder.toString().trim(), currentWidth));
            currentWidth = 0.0F;
            numLines++;
            sbuilder.setLength(0);
        }
        else {
            gl.setText(FontHelper.cardDescFont_N, word + sbuilder2);
        }
        
        // 检查是否需要换行
        if (currentWidth + gl.width > DESC_BOX_WIDTH) {
            this.description.add(new DescriptionLine(sbuilder.toString().trim(), currentWidth));
            numLines++;
            sbuilder.setLength(0);
            currentWidth = gl.width;
        } else {
            currentWidth += gl.width;
        }
        
        if (isKeyword) {
            sbuilder.append('*');
        }
        sbuilder.append(word).append(sbuilder2);
    }
    
    if (!sbuilder.toString().trim().isEmpty()) {
        this.description.add(new DescriptionLine(sbuilder.toString().trim(), currentWidth));
    }
    
    if (Settings.isDev && numLines > 5) {
        logger.info("WARNING: Card " + this.name + " has lots of text");
    }
}
```

#### 动态数值显示

```java
private String getDynamicValue(char key) {
    switch (key) {
        case 'B':
            if (this.isBlockModified) {
                if (this.block >= this.baseBlock) {
                    return "[#7fff00]" + Integer.toString(this.block) + "[]";
                }
                return "[#ff6563]" + Integer.toString(this.block) + "[]";
            }
            return Integer.toString(this.baseBlock);
        
        case 'D':
            if (this.isDamageModified) {
                if (this.damage >= this.baseDamage) {
                    return "[#7fff00]" + Integer.toString(this.damage) + "[]";
                }
                return "[#ff6563]" + Integer.toString(this.damage) + "[]";
            }
            return Integer.toString(this.baseDamage);
        
        case 'M':
            if (this.isMagicNumberModified) {
                if (this.magicNumber >= this.baseMagicNumber) {
                    return "[#7fff00]" + Integer.toString(this.magicNumber) + "[]";
                }
                return "[#ff6563]" + Integer.toString(this.magicNumber) + "[]";
            }
            return Integer.toString(this.baseMagicNumber);
    }
    
    logger.info("KEY: " + key);
    return Integer.toString(-99);
}
```

### 7. 卡牌渲染系统

#### 主渲染方法

```java
public void render(SpriteBatch sb, boolean selected) {
    if (!Settings.hideCards) {
        if (this.flashVfx != null) {
            this.flashVfx.render(sb);
        }
        renderCard(sb, this.hovered, selected);
        this.hb.render(sb);
    }
}

private void renderCard(SpriteBatch sb, boolean hovered, boolean selected) {
    if (!Settings.hideCards) {
        if (!isOnScreen()) {
            return;
        }
        if (!this.isFlipped) {
            updateGlow();
            renderGlow(sb);
            renderImage(sb, hovered, selected);
            renderTitle(sb);
            renderType(sb);
            if (Settings.lineBreakViaCharacter) {
                renderDescriptionCN(sb);
            } else {
                renderDescription(sb);
            }
            renderTint(sb);
            renderEnergy(sb);
        } else {
            renderBack(sb, hovered, selected);
            this.hb.render(sb);
        }
    }
}
```

#### 卡牌背景渲染

```java
private void renderCardBg(SpriteBatch sb, float x, float y) {
    switch (this.type) {
        case BASIC:
            renderAttackBg(sb, x, y);
            break;
        case COMMON:
            renderSkillBg(sb, x, y);
            break;
        case UNCOMMON:
            renderPowerBg(sb, x, y);
            break;
        case CURSE:
            renderSkillBg(sb, x, y);
            break;
        case SPECIAL:
            renderSkillBg(sb, x, y);
            break;
    }
}

private void renderAttackBg(SpriteBatch sb, float x, float y) {
    switch (this.color) {
        case BASIC:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_ATTACK_BG_RED, x, y);
            return;
        case CURSE:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_ATTACK_BG_GREEN, x, y);
            return;
        case SPECIAL:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_ATTACK_BG_BLUE, x, y);
            return;
        case COMMON:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_ATTACK_BG_PURPLE, x, y);
            return;
        case RARE:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_SKILL_BG_BLACK, x, y);
            return;
        case UNCOMMON:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_ATTACK_BG_GRAY, x, y);
            return;
    }
    renderHelper(sb, this.renderColor, ImageMaster.CARD_SKILL_BG_BLACK, x, y);
}
```

#### 能量图标渲染

```java
private void renderEnergy(SpriteBatch sb) {
    if (this.cost <= -2 || this.darken || this.isLocked || !this.isSeen) {
        return;
    }
    
    switch (this.color) {
        case BASIC:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_RED_ORB, this.current_x, this.current_y);
            break;
        case CURSE:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_GREEN_ORB, this.current_x, this.current_y);
            break;
        case SPECIAL:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_BLUE_ORB, this.current_x, this.current_y);
            break;
        case COMMON:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_PURPLE_ORB, this.current_x, this.current_y);
            break;
        case UNCOMMON:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_COLORLESS_ORB, this.current_x, this.current_y);
            break;
        default:
            renderHelper(sb, this.renderColor, ImageMaster.CARD_COLORLESS_ORB, this.current_x, this.current_y);
            break;
    }
    
    Color costColor = Color.WHITE.cpy();
    if (AbstractDungeon.player != null && AbstractDungeon.player.hand.contains(this) && !hasEnoughEnergy()) {
        costColor = ENERGY_COST_RESTRICTED_COLOR;
    } else if (this.isCostModified || this.isCostModifiedForTurn || freeToPlay()) {
        costColor = ENERGY_COST_MODIFIED_COLOR;
    }
    costColor.a = this.transparency;
    
    String text = getCost();
    BitmapFont font = getEnergyFont();
    
    if ((this.type != CardType.STATUS || this.cardID.equals("Slimed")) && 
        (this.color != CardColor.CURSE || this.cardID.equals("Pride"))) {
        FontHelper.renderRotatedText(sb, font, text, this.current_x, this.current_y, 
                                   -132.0F * this.drawScale * Settings.scale, 
                                   192.0F * this.drawScale * Settings.scale, 
                                   this.angle, false, costColor);
    }
}
```

### 8. 卡牌交互系统

#### 悬停处理

```java
public void updateHoverLogic() {
    this.hb.update();
    if (this.hb.hovered) {
        hover();
        this.hoverDuration += Gdx.graphics.getDeltaTime();
        if (this.hoverDuration > 0.2F && !Settings.hideCards) {
            this.renderTip = true;
        }
    } else {
        unhover();
    }
}

public void hover() {
    if (!this.hovered) {
        this.hovered = true;
        this.drawScale = 1.0F;
        this.targetDrawScale = 1.0F;
    }
}

public void unhover() {
    if (this.hovered) {
        this.hovered = false;
        this.hoverDuration = 0.0F;
        this.renderTip = false;
        this.targetDrawScale = 0.75F;
    }
}
```

#### 卡牌提示

```java
public void renderCardTip(SpriteBatch sb) {
    if (!Settings.hideCards && this.renderTip) {
        if (AbstractDungeon.player != null && AbstractDungeon.player.isDraggingCard && !Settings.isTouchScreen) {
            return;
        }
        
        if (this.isLocked) {
            ArrayList<String> locked = new ArrayList<>();
            locked.add(0, "locked");
            TipHelper.renderTipForCard(this, sb, locked);
            return;
        }
        
        if (!this.isSeen) {
            ArrayList<String> unseen = new ArrayList<>();
            unseen.add(0, "unseen");
            TipHelper.renderTipForCard(this, sb, unseen);
            return;
        }
        
        if (SingleCardViewPopup.isViewingUpgrade && this.isSeen && !this.isLocked) {
            AbstractCard copy = makeCopy();
            copy.current_x = this.current_x;
            copy.current_y = this.current_y;
            copy.drawScale = this.drawScale;
            copy.upgrade();
            
            TipHelper.renderTipForCard(copy, sb, copy.keywords);
        } else {
            TipHelper.renderTipForCard(this, sb, this.keywords);
        }
        
        if (this.cardsToPreview != null) {
            renderCardPreview(sb);
        }
    }
}
```

### 9. 卡牌复制系统

#### 统计等价复制

```java
public AbstractCard makeStatEquivalentCopy() {
    AbstractCard card = makeCopy();
    
    // 应用升级
    for (int i = 0; i < this.timesUpgraded; i++) {
        card.upgrade();
    }
    
    // 复制属性
    card.name = this.name;
    card.target = this.target;
    card.upgraded = this.upgraded;
    card.timesUpgraded = this.timesUpgraded;
    card.baseDamage = this.baseDamage;
    card.baseBlock = this.baseBlock;
    card.baseMagicNumber = this.baseMagicNumber;
    card.cost = this.cost;
    card.costForTurn = this.costForTurn;
    card.isCostModified = this.isCostModified;
    card.isCostModifiedForTurn = this.isCostModifiedForTurn;
    card.inBottleLightning = this.inBottleLightning;
    card.inBottleFlame = this.inBottleFlame;
    card.inBottleTornado = this.inBottleTornado;
    card.isSeen = this.isSeen;
    card.isLocked = this.isLocked;
    card.misc = this.misc;
    card.freeToPlayOnce = this.freeToPlayOnce;
    
    return card;
}
```

#### 相同实例复制

```java
public AbstractCard makeSameInstanceOf() {
    AbstractCard card = makeStatEquivalentCopy();
    card.uuid = this.uuid;
    return card;
}
```

### 10. 卡牌事件系统

#### 生命周期事件

```java
// 抽牌时触发
public void triggerWhenDrawn() {}

// 复制时触发
public void triggerWhenCopied() {}

// 玩家回合结束时触发
public void triggerOnEndOfPlayerTurn() {
    if (this.isEthereal) {
        addToTop(new ExhaustSpecificCardAction(this, AbstractDungeon.player.hand));
    }
}

// 回合结束时触发（用于正在打出的卡牌）
public void triggerOnEndOfTurnForPlayingCard() {}

// 其他卡牌打出时触发
public void triggerOnOtherCardPlayed(AbstractCard c) {}

// 获得能量时触发
public void triggerOnGainEnergy(int e, boolean dueToCard) {}

// 手动丢弃时触发
public void triggerOnManualDiscard() {}

// 卡牌被打出时触发
public void triggerOnCardPlayed(AbstractCard cardPlayed) {}

// 预言时触发
public void triggerOnScry() {}

// 姿态变化时触发（已消耗的卡牌）
public void triggerExhaustedCardsOnStanceChange(AbstractStance newStance) {}

// 回合开始时触发
public void triggerAtStartOfTurn() {}

// 卡牌被打出时触发
public void onPlayCard(AbstractCard c, AbstractMonster m) {}

// 回合开始时触发（抽牌前）
public void atTurnStartPreDraw() {}

// 选择此选项时触发
public void onChoseThisOption() {}

// 保留时触发
public void onRetained() {}

// 消耗时触发
public void triggerOnExhaust() {}
```

### 11. 卡牌成本管理系统

#### 成本修改

```java
public void updateCost(int amt) {
    if ((this.color != CardColor.CURSE || this.cardID.equals("Pride")) && 
        (this.type != CardType.STATUS || this.cardID.equals("Slimed"))) {
        
        int tmpCost = this.cost;
        int diff = this.cost - this.costForTurn;
        
        tmpCost += amt;
        if (tmpCost < 0) {
            tmpCost = 0;
        }
        
        if (tmpCost != this.cost) {
            this.isCostModified = true;
            this.cost = tmpCost;
            this.costForTurn = this.cost - diff;
            
            if (this.costForTurn < 0) {
                this.costForTurn = 0;
            }
        }
    } else {
        logger.info("Curses/Statuses cannot have their costs modified");
    }
}
```

#### 回合成本设置

```java
public void setCostForTurn(int amt) {
    if (this.costForTurn >= 0) {
        this.costForTurn = amt;
        if (this.costForTurn < 0) {
            this.costForTurn = 0;
        }
        
        if (this.costForTurn != this.cost) {
            this.isCostModifiedForTurn = true;
        }
    }
}
```

#### 战斗成本修改

```java
public void modifyCostForCombat(int amt) {
    if (this.costForTurn > 0) {
        this.costForTurn += amt;
        if (this.costForTurn < 0) {
            this.costForTurn = 0;
        }
        
        if (this.cost != this.costForTurn) {
            this.isCostModified = true;
        }
        this.cost = this.costForTurn;
    } else if (this.cost >= 0) {
        this.cost += amt;
        if (this.cost < 0) {
            this.cost = 0;
        }
        this.costForTurn = 0;
        if (this.cost != this.costForTurn) {
            this.isCostModified = true;
        }
    }
}
```

### 12. 卡牌移动系统

#### 移动到弃牌堆

```java
public void moveToDiscardPile() {
    this.target_x = CardGroup.DISCARD_PILE_X;
    if ((AbstractDungeon.getCurrRoom()).phase == AbstractRoom.RoomPhase.COMBAT) {
        this.target_y = 0.0F;
    } else {
        this.target_y = 0.0F - OverlayMenu.HAND_HIDE_Y;
    }
}

public void teleportToDiscardPile() {
    this.current_x = CardGroup.DISCARD_PILE_X;
    this.target_x = this.current_x;
    if ((AbstractDungeon.getCurrRoom()).phase == AbstractRoom.RoomPhase.COMBAT) {
        this.current_y = 0.0F;
    } else {
        this.current_y = 0.0F - OverlayMenu.HAND_HIDE_Y;
    }
    this.target_y = this.current_y;
    onMoveToDiscard();
}
```

### 13. 设计模式分析

#### 1. 模板方法模式 (Template Method Pattern)

`AbstractCard` 定义了卡牌的基本结构和行为模板，具体卡牌类通过重写特定方法来实现个性化功能：

- **模板方法**: `use()` 方法定义了卡牌使用的基本流程
- **基本方法**: `upgrade()`, `applyPowers()`, `triggerWhenDrawn()` 等提供扩展点

#### 2. 策略模式 (Strategy Pattern)

不同类型的卡牌通过不同的渲染策略实现视觉效果：

- **策略接口**: 卡牌渲染方法
- **具体策略**: 攻击卡、技能卡、能力卡的不同渲染实现

#### 3. 观察者模式 (Observer Pattern)

卡牌通过事件系统与游戏其他组件交互：

- **观察者**: 卡牌监听游戏状态变化
- **被观察者**: 游戏管理器、玩家、怪物等

#### 4. 工厂方法模式 (Factory Method Pattern)

卡牌创建通过工厂方法实现：

- **工厂方法**: `makeCopy()`, `makeStatEquivalentCopy()`
- **产品**: 具体的卡牌实例

#### 5. 状态模式 (State Pattern)

卡牌的不同状态通过状态对象管理：

- **状态**: 手牌、抽牌堆、弃牌堆、消耗堆等
- **状态转换**: 卡牌在不同区域间的移动

### 14. 性能优化机制

#### 1. 视觉优化

```java
// 视锥剔除
private boolean isOnScreen() {
    return (this.current_y >= -200.0F * Settings.scale && 
            this.current_y <= Settings.HEIGHT + 200.0F * Settings.scale);
}

// 快速模式
if (Settings.FAST_MODE) {
    this.current_x = MathHelper.cardLerpSnap(this.current_x, this.target_x);
    this.current_y = MathHelper.cardLerpSnap(this.current_y, this.target_y);
}
```

#### 2. 内存优化

```java
// 静态图像资源
private static TextureAtlas cardAtlas;
private static TextureAtlas oldCardAtlas;
private static TextureAtlas orbAtlas;

// 对象池化
public AbstractCard makeStatEquivalentCopy() {
    // 复用现有对象而非创建新对象
}
```

#### 3. 渲染优化

```java
// 批量渲染
public void render(SpriteBatch sb) {
    if (!Settings.hideCards) {
        renderCard(sb, this.hovered, selected);
        this.hb.render(sb);
    }
}

// 条件渲染
if (!isOnScreen()) {
    return;
}
```

## 总结

杀戮尖塔的卡牌系统是一个精心设计的面向对象系统，具有以下特点：

1. **模块化设计**: 每个卡牌都是独立的模块，具有清晰的职责分工
2. **灵活的扩展性**: 通过继承和多态支持各种卡牌类型的实现
3. **丰富的交互机制**: 支持悬停、提示、拖拽等多种用户交互
4. **动态数值系统**: 实时计算和显示卡牌数值变化
5. **完整的事件系统**: 支持卡牌生命周期中的各种事件处理
6. **高效的渲染系统**: 优化的渲染流程确保流畅的视觉体验
7. **强大的复制机制**: 支持多种卡牌复制方式，满足不同需求

这个系统为游戏提供了丰富的卡牌玩法和良好的用户体验，是杀戮尖塔游戏体验的核心基础。