# 杀戮尖塔事件系统深度解析

## 概述

事件系统是《杀戮尖塔》中提供叙事体验和随机选择的核心机制。事件为玩家提供了除战斗外的另一种游戏体验，通过选择不同的选项来获得各种奖励或承受惩罚。本文档将深入分析事件系统的架构、实现机制和扩展性。

## 核心类结构

### AbstractEvent - 事件基类

`AbstractEvent`是所有事件的抽象基类，定义了事件的基本框架：

```java
public abstract class AbstractEvent implements Disposable {
    // 视觉资源
    protected Texture img = null;
    protected float drawX;
    protected float drawY;
    protected Color imgColor = Color.WHITE.cpy();
    protected float imgWidth;
    protected float imgHeight;
    protected Hitbox hb = null;
    
    // 对话系统
    public RoomEventDialog roomEventText = new RoomEventDialog();
    public GenericEventDialog imageEventText = new GenericEventDialog();
    
    // 事件状态
    public float panelAlpha = 0.0F;
    public boolean hideAlpha = false;
    public boolean hasFocus = false;
    protected String body = null;
    public float waitTimer = 1.5F;
    protected boolean waitForInput = false;
    public boolean hasDialog = false;
    protected int screenNum = 0;
    
    // 事件类型
    public static EventType type = EventType.IMAGE;
    public boolean combatTime = false;
    public boolean noCardsInRewards = false;
    
    // 选择记录
    public ArrayList<Integer> optionsSelected = new ArrayList<>();
    
    // 本地化
    public static String NAME;
    public static String[] DESCRIPTIONS;
    public static String[] OPTIONS;
}
```

### 事件类型枚举

```java
public enum EventType {
    TEXT,   // 纯文本事件
    IMAGE,  // 带图像事件
    ROOM    // 房间事件
}
```

## 事件生命周期

### 1. 事件初始化

事件在房间进入时初始化：

```java
public void onEnterRoom() {
    // 默认实现为空，子类可重写
}
```

### 2. 事件更新循环

事件的核心更新逻辑：

```java
public void update() {
    // 等待计时器更新
    if (this.waitTimer > 0.0F) {
        this.waitTimer -= Gdx.graphics.getDeltaTime();
        if (this.waitTimer < 0.0F && this.hasDialog) {
            this.roomEventText.show(this.body);
            this.waitTimer = 0.0F;
        }
    } else if ((AbstractDungeon.getCurrRoom()).phase != AbstractRoom.RoomPhase.COMBAT && 
               !this.hideAlpha) {
        // 面板透明度渐变
        this.panelAlpha = MathHelper.fadeLerpSnap(this.panelAlpha, 0.66F);
    } else {
        this.panelAlpha = MathHelper.fadeLerpSnap(this.panelAlpha, 0.0F);
    }
    
    // 处理用户输入
    if (!RoomEventDialog.waitForInput) {
        buttonEffect(this.roomEventText.getSelectedOption());
    }
}
```

### 3. 按钮效果处理

每个事件必须实现`buttonEffect()`方法：

```java
protected abstract void buttonEffect(int buttonPressed);
```

### 4. 战斗进入

事件可以触发战斗：

```java
public void enterCombat() {
    this.roomEventText.clear();
    (AbstractDungeon.getCurrRoom()).phase = AbstractRoom.RoomPhase.COMBAT;
    (AbstractDungeon.getCurrRoom()).monsters.init();
    AbstractRoom.waitTimer = 0.1F;
    AbstractDungeon.player.preBattlePrep();
    this.hasFocus = false;
    this.roomEventText.hide();
}
```

## AbstractImageEvent - 图像事件

`AbstractImageEvent`是带图像的事件基类：

```java
public abstract class AbstractImageEvent extends AbstractEvent {
    protected String title;
    
    public AbstractImageEvent(String title, String body, String imgUrl) {
        this.imageEventText.clear();
        this.roomEventText.clear();
        this.title = title;
        this.body = body;
        this.imageEventText.loadImage(imgUrl);
        type = AbstractEvent.EventType.IMAGE;
        this.noCardsInRewards = false;
    }
    
    public void update() {
        if (!this.combatTime) {
            this.hasFocus = true;
            
            // 随机背景粒子效果
            if (MathUtils.randomBoolean(0.1F)) {
                AbstractDungeon.effectList.add(new EventBgParticle());
            }
            
            // 等待计时器处理
            if (this.waitTimer > 0.0F) {
                this.waitTimer -= Gdx.graphics.getDeltaTime();
                if (this.waitTimer < 0.0F) {
                    this.imageEventText.show(this.title, this.body);
                    this.waitTimer = 0.0F;
                }
            }
            
            // 处理用户输入
            if (!GenericEventDialog.waitForInput) {
                buttonEffect(GenericEventDialog.getSelectedOption());
            }
        }
    }
}
```

### 战斗转换

图像事件支持与战斗的相互转换：

```java
public void enterCombatFromImage() {
    (AbstractDungeon.getCurrRoom()).smoked = false;
    AbstractDungeon.player.isEscaping = false;
    (AbstractDungeon.getCurrRoom()).phase = AbstractRoom.RoomPhase.COMBAT;
    (AbstractDungeon.getCurrRoom()).monsters.init();
    AbstractRoom.waitTimer = 0.1F;
    AbstractDungeon.player.preBattlePrep();
    this.hasFocus = false;
    GenericEventDialog.hide();
    CardCrawlGame.fadeIn(1.5F);
    AbstractDungeon.rs = AbstractDungeon.RenderScene.NORMAL;
    this.combatTime = true;
}

public void enterImageFromCombat() {
    (AbstractDungeon.getCurrRoom()).phase = AbstractRoom.RoomPhase.EVENT;
    (AbstractDungeon.getCurrRoom()).isBattleOver = false;
    (AbstractDungeon.getCurrRoom()).monsters.monsters.clear();
    (AbstractDungeon.getCurrRoom()).rewards.clear();
    this.hasDialog = true;
    this.hasFocus = true;
    this.combatTime = false;
    GenericEventDialog.show();
    CardCrawlGame.fadeIn(1.5F);
    AbstractDungeon.rs = AbstractDungeon.RenderScene.EVENT;
}
```

## 对话系统

### RoomEventDialog - 房间事件对话

`RoomEventDialog`处理房间事件的文本显示和选项：

```java
public class RoomEventDialog {
    // 颜色和动画
    private Color color = new Color(0.0F, 0.0F, 0.0F, 0.0F);
    private Color targetColor = new Color(0.0F, 0.0F, 0.0F, 0.0F);
    private static final Color PANEL_COLOR = new Color(0.0F, 0.0F, 0.0F, 0.5F);
    private static final float COLOR_FADE_SPEED = 8.0F;
    
    // 文本显示
    private boolean show = false;
    private float curLineWidth = 0.0F;
    private int curLine = 0;
    private DialogWord.AppearEffect a_effect;
    private Scanner s;
    private GlyphLayout gl = new GlyphLayout();
    private ArrayList<DialogWord> words = new ArrayList<>();
    private boolean textDone = true;
    private float wordTimer = 0.0F;
    
    // 选项系统
    public static ArrayList<LargeDialogOptionButton> optionList = new ArrayList<>();
    public static int selectedOption = -1;
    public static boolean waitForInput = true;
    
    // 布局常量
    private static final float WORD_TIME = 0.02F;
    private static final float CHAR_SPACING = 8.0F * Settings.scale;
    private static final float LINE_SPACING = 34.0F * Settings.scale;
    private static final float DIALOG_MSG_X = Settings.WIDTH * 0.1F;
    private static final float DIALOG_MSG_Y = 250.0F * Settings.scale;
    private static final float DIALOG_MSG_W = Settings.WIDTH * 0.8F;
}
```

### 文本效果系统

对话系统支持逐字显示效果：

```java
private void bodyTextEffect() {
    this.wordTimer -= Gdx.graphics.getDeltaTime();
    if (this.wordTimer < 0.0F && !this.textDone) {
        if (Settings.FAST_MODE) {
            this.wordTimer = 0.005F;
        } else {
            this.wordTimer = 0.02F;
        }
        
        if (this.s.hasNext()) {
            String word = this.s.next();
            
            // 处理换行
            if (word.equals("NL")) {
                this.curLine++;
                this.curLineWidth = 0.0F;
                return;
            }
            
            // 识别颜色标记
            DialogWord.WordColor color = DialogWord.identifyWordColor(word);
            if (color != DialogWord.WordColor.DEFAULT) {
                word = word.substring(2, word.length());
            }
            
            // 识别效果标记
            DialogWord.WordEffect effect = DialogWord.identifyWordEffect(word);
            if (effect != DialogWord.WordEffect.NONE) {
                word = word.substring(1, word.length() - 1);
            }
            
            // 计算布局
            this.gl.setText(FontHelper.charDescFont, word);
            if (this.curLineWidth + this.gl.width > DIALOG_MSG_W) {
                this.curLine++;
                this.curLineWidth = this.gl.width + CHAR_SPACING;
            } else {
                this.curLineWidth += this.gl.width + CHAR_SPACING;
            }
            
            // 创建对话词
            this.words.add(new DialogWord(FontHelper.charDescFont, word, this.a_effect, 
                                        effect, color, 
                                        DIALOG_MSG_X + this.curLineWidth - this.gl.width, 
                                        DIALOG_MSG_Y - LINE_SPACING * this.curLine, 
                                        this.curLine));
            
            if (!this.show) {
                ((DialogWord)this.words.get(this.words.size() - 1)).dialogFadeOut();
            }
        } else {
            this.textDone = true;
            this.s.close();
        }
    }
}
```

### GenericEventDialog - 通用事件对话

`GenericEventDialog`支持图像显示：

```java
public class GenericEventDialog {
    // 图像资源
    private Texture img = null;
    
    // 颜色和动画
    private Color panelColor = new Color(1.0F, 1.0F, 1.0F, 0.0F);
    private Color titleColor = new Color(1.0F, 0.835F, 0.39F, 0.0F);
    private Color borderColor = new Color(0.0F, 0.0F, 0.0F, 0.0F);
    private Color imgColor = new Color(1.0F, 1.0F, 1.0F, 0.0F);
    private float animateTimer = 0.0F;
    
    // 布局常量
    private static final float DIALOG_MSG_X_IMAGE = 816.0F * Settings.xScale;
    private static final float DIALOG_MSG_W_IMAGE = 900.0F * Settings.scale;
    private static final float TITLE_X = 570.0F * Settings.xScale;
    private static final float TITLE_Y = Settings.EVENT_Y + 408.0F * Settings.scale;
    
    // 选项系统
    public ArrayList<LargeDialogOptionButton> optionList = new ArrayList<>();
    public static int selectedOption = -1;
    public static boolean waitForInput = true;
}
```

### 图像加载和管理

```java
public void loadImage(String imgUrl) {
    if (this.img != null) {
        this.img.dispose();
        this.img = null;
    }
    this.img = ImageMaster.loadImage(imgUrl);
    
    DIALOG_MSG_X = DIALOG_MSG_X_IMAGE;
    DIALOG_MSG_W = DIALOG_MSG_W_IMAGE;
}

private void clearImage() {
    dispose();
    DIALOG_MSG_X = DIALOG_MSG_X_TEXT;
    DIALOG_MSG_Y = DIALOG_MSG_Y_TEXT;
    DIALOG_MSG_W = DIALOG_MSG_W_TEXT;
}
```

## 选项系统

### 选项按钮管理

对话系统支持多种类型的选项：

```java
// 基础选项
public void addDialogOption(String text) {
    optionList.add(new LargeDialogOptionButton(optionList.size(), text));
}

// 带卡牌预览的选项
public void addDialogOption(String text, AbstractCard previewCard) {
    optionList.add(new LargeDialogOptionButton(optionList.size(), text, previewCard));
}

// 带遗物预览的选项
public void addDialogOption(String text, AbstractRelic previewRelic) {
    optionList.add(new LargeDialogOptionButton(optionList.size(), text, previewRelic));
}

// 带卡牌和遗物预览的选项
public void addDialogOption(String text, AbstractCard previewCard, AbstractRelic previewRelic) {
    optionList.add(new LargeDialogOptionButton(optionList.size(), text, previewCard, previewRelic));
}

// 禁用选项
public void addDialogOption(String text, boolean isDisabled) {
    optionList.add(new LargeDialogOptionButton(optionList.size(), text, isDisabled));
}
```

### 选项更新和移除

```java
// 更新选项
public void updateDialogOption(int slot, String text) {
    optionList.set(slot, new LargeDialogOptionButton(slot, text));
}

// 移除选项
public void removeDialogOption(int slot) {
    optionList.remove(slot);
}

// 清除剩余选项
public void clearRemainingOptions() {
    for (int i = optionList.size() - 1; i > 0; i--) {
        optionList.remove(i);
    }
}
```

## 渲染系统

### 基础渲染

事件的基础渲染：

```java
public void render(SpriteBatch sb) {
    if (this.img != null) {
        sb.setColor(this.imgColor);
        sb.draw(this.img, this.drawX, this.drawY, this.imgWidth, this.imgHeight);
    }
    
    if (this.hb != null) {
        this.hb.render(sb);
        if (this.img != null && this.hb.hovered) {
            sb.setBlendFunction(770, 1);
            sb.setColor(new Color(1.0F, 1.0F, 1.0F, 0.3F));
            sb.draw(this.img, this.drawX, this.drawY, this.imgWidth, this.imgHeight);
            sb.setBlendFunction(770, 771);
        }
    }
}
```

### 文本渲染

```java
public void renderText(SpriteBatch sb) {
    this.roomEventText.render(sb);
    this.imageEventText.render(sb);
}
```

### 房间事件面板渲染

```java
public void renderRoomEventPanel(SpriteBatch sb) {
    sb.setColor(new Color(0.0F, 0.0F, 0.0F, this.panelAlpha));
    sb.draw(ImageMaster.EVENT_ROOM_PANEL, 0.0F, Settings.HEIGHT - 475.0F * Settings.scale, 
            Settings.WIDTH, 300.0F * Settings.scale);
}
```

### GenericEventDialog渲染

```java
public void render(SpriteBatch sb) {
    if (show && !AbstractDungeon.player.isDead) {
        sb.setColor(this.panelColor);
        
        // 绘制背景面板
        sb.draw(AbstractDungeon.eventBackgroundImg, 
                Settings.WIDTH / 2.0F - 881.5F - 12.0F * Settings.xScale, 
                Settings.EVENT_Y - 403.0F + 64.0F * Settings.scale, 
                881.5F, 403.0F, 1763.0F, 806.0F, 
                Settings.xScale, Settings.scale, 0.0F, 0, 0, 1763, 806, false, false);
        
        // 绘制图像
        if (this.img != null) {
            sb.setColor(this.imgColor);
            sb.draw(this.img, 460.0F * Settings.xScale - 300.0F, 
                    Settings.EVENT_Y - 300.0F + 16.0F * Settings.scale, 
                    300.0F, 300.0F, 600.0F, 600.0F, 
                    Settings.scale, Settings.scale, 0.0F, 0, 0, 600, 600, false, false);
            
            // 绘制边框
            sb.setColor(this.borderColor);
            sb.draw(ImageMaster.EVENT_IMG_FRAME, 460.0F * Settings.xScale - 305.0F, 
                    Settings.EVENT_Y - 305.0F + 16.0F * Settings.scale, 
                    305.0F, 305.0F, 610.0F, 610.0F, 
                    Settings.scale, Settings.scale, 0.0F, 0, 0, 610, 610, false, false);
        }
        
        // 绘制标题
        FontHelper.renderFontCentered(sb, FontHelper.losePowerFont, this.title, 
                TITLE_X, TITLE_Y, this.titleColor, 0.88F);
        
        // 绘制对话词
        for (DialogWord w : words) {
            w.render(sb);
        }
        
        // 绘制选项
        for (LargeDialogOptionButton b : this.optionList) {
            b.render(sb);
        }
        
        // 绘制预览
        for (LargeDialogOptionButton b : this.optionList) {
            b.renderCardPreview(sb);
        }
        for (LargeDialogOptionButton b : this.optionList) {
            b.renderRelicPreview(sb);
        }
    }
}
```

## 数据统计系统

### 通用指标记录

事件系统提供了丰富的数据统计功能：

```java
public static void logMetric(String eventName, String playerChoice, 
                           List<String> cardsObtained, List<String> cardsRemoved, 
                           List<String> cardsTransformed, List<String> cardsUpgraded, 
                           List<String> relicsObtained, List<String> potionsObtained, 
                           List<String> relicsLost, int damageTaken, int damageHealed, 
                           int hpLoss, int hpGain, int goldGain, int goldLoss) {
    HashMap<String, Object> choice = new HashMap<>();
    choice.put("event_name", eventName);
    choice.put("player_choice", playerChoice);
    choice.put("floor", Integer.valueOf(AbstractDungeon.floorNum));
    
    // 卡牌相关
    choice.put("cards_obtained", cardsObtained);
    choice.put("cards_removed", cardsRemoved);
    choice.put("cards_transformed", cardsTransformed);
    choice.put("cards_upgraded", cardsUpgraded);
    
    // 物品相关
    choice.put("relics_obtained", relicsObtained);
    choice.put("potions_obtained", potionsObtained);
    choice.put("relics_lost", relicsLost);
    
    // 生命和金币
    choice.put("damage_taken", Integer.valueOf(damageTaken));
    choice.put("damage_healed", Integer.valueOf(damageHealed));
    choice.put("max_hp_loss", Integer.valueOf(hpLoss));
    choice.put("max_hp_gain", Integer.valueOf(hpGain));
    choice.put("gold_gain", Integer.valueOf(goldGain));
    choice.put("gold_loss", Integer.valueOf(goldLoss));
    
    CardCrawlGame.metricData.event_choices.add(choice);
}
```

### 便捷统计方法

系统提供了多种便捷的统计方法：

```java
// 卡牌移除统计
public static void logMetricRemoveCards(String eventName, String playerChoice, List<String> cardsRemoved) {
    logMetricRemoveCardsAtCost(eventName, playerChoice, cardsRemoved, 0);
}

// 卡牌获得统计
public static void logMetricObtainCards(String eventName, String playerChoice, List<String> cardsObtained) {
    logMetricObtainCardsLoseMapHP(eventName, playerChoice, cardsObtained, 0);
}

// 遗物获得统计
public static void logMetricObtainRelic(String eventName, String playerChoice, AbstractRelic relicGained) {
    List<String> tempList = new ArrayList<>();
    tempList.add(relicGained.relicId);
    logMetric(eventName, playerChoice, null, null, null, null, tempList, null, null, 0, 0, 0, 0, 0, 0);
}

// 金币获得统计
public static void logMetricGainGold(String eventName, String playerChoice, int gold) {
    logMetric(eventName, playerChoice, null, null, null, null, null, null, null, 0, 0, 0, 0, gold, 0);
}

// 伤害统计
public static void logMetricTakeDamage(String eventName, String playerChoice, int damage) {
    logMetric(eventName, playerChoice, null, null, null, null, null, null, null, damage, 0, 0, 0, 0, 0);
}
```

## 工具方法

### 地图打开

```java
protected void openMap() {
    (AbstractDungeon.getCurrRoom()).phase = AbstractRoom.RoomPhase.COMPLETE;
    AbstractDungeon.dungeonMapScreen.open(false);
}
```

### 继续屏幕显示

```java
public void showProceedScreen(String bodyText) {
    this.roomEventText.updateBodyText(bodyText);
    this.roomEventText.updateDialogOption(0, "[ #bProceed ]");
    this.roomEventText.clearRemainingOptions();
    this.screenNum = 99;
}
```

### 输入记录

```java
public void logInput(int buttonPressed) {
    this.optionsSelected.add(Integer.valueOf(buttonPressed));
}
```

### 本地化字符串获取

```java
public HashMap<String, Serializable> getLocStrings() {
    HashMap<String, Serializable> data = new HashMap<>();
    data.put("name", NAME);
    data.put("moves", DESCRIPTIONS);
    data.put("dialogs", OPTIONS);
    return data;
}
```

## 资源管理

### 资源释放

```java
public void dispose() {
    if (this.img != null) {
        logger.info("Disposed event img asset");
        this.img.dispose();
        this.img = null;
    }
    this.imageEventText.clear();
    this.roomEventText.clear();
}
```

### 图像初始化

```java
protected void initializeImage(String imgUrl, float x, float y) {
    this.img = ImageMaster.loadImage(imgUrl);
    this.drawX = x;
    this.drawY = y;
    this.imgWidth = this.img.getWidth() * Settings.xScale;
    this.imgHeight = this.img.getHeight() * Settings.scale;
}
```

## 设计模式分析

### 1. 模板方法模式

`AbstractEvent`定义了事件的基本流程：

- 模板方法：`update()`定义了更新流程
- 抽象方法：`buttonEffect()`由子类实现具体逻辑
- 钩子方法：`onEnterRoom()`提供可选的初始化逻辑

### 2. 策略模式

不同类型的事件采用不同的显示策略：

- `AbstractEvent`：基础文本事件
- `AbstractImageEvent`：带图像的事件
- `RoomEventDialog` vs `GenericEventDialog`：不同的对话策略

### 3. 状态模式

事件通过状态管理不同的显示模式：

- `combatTime`：战斗时间标志
- `hasFocus`：焦点状态
- `waitForInput`：等待输入状态

### 4. 观察者模式

事件系统通过回调机制响应用户输入：

- 选项按钮点击触发`buttonEffect()`
- 对话系统监听用户输入

## 扩展性设计

### 1. 新事件类型添加

添加新事件类型只需：

1. 继承`AbstractEvent`或`AbstractImageEvent`
2. 实现`buttonEffect()`方法
3. 定义事件特定的逻辑和选项
4. 注册到事件池

### 2. 新对话效果添加

通过扩展`DialogWord`类添加新效果：

```java
public enum WordEffect {
    NONE, BUMP_IN, WAVE, NEW_EFFECT;
}
```

### 3. 自定义统计指标

通过扩展统计方法添加新指标：

```java
public static void logMetricCustomEffect(String eventName, String playerChoice, CustomData data) {
    // 自定义统计逻辑
}
```

## 性能优化

### 1. 资源管理

- 图像资源及时释放
- 对话词对象复用
- 扫描器正确关闭

### 2. 渲染优化

- 条件渲染减少绘制调用
- 透明度渐变优化
- 文本效果缓存

### 3. 内存管理

- 选项列表及时清理
- 对话状态重置
- 临时对象回收

## 总结

事件系统是《杀戮尖塔》中设计精良的叙事系统，具有以下特点：

1. **高度模块化**：通过抽象基类实现组件化设计
2. **丰富的表现力**：支持文本、图像、动画等多种表现形式
3. **灵活的选项系统**：支持预览、禁用等多种选项类型
4. **完善的统计系统**：详细记录玩家选择和结果
5. **良好的扩展性**：易于添加新事件类型和效果

这种设计使得事件系统既功能强大又易于维护和扩展，为游戏提供了丰富的叙事体验和良好的架构基础。