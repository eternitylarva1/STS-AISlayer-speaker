# 遗物系统深度解析

## 概述

遗物系统是杀戮尖塔的核心机制之一，通过AbstractRelic类实现了各种永久性和一次性效果。遗物为玩家提供了强大的被动效果、触发效果和特殊能力，是游戏策略深度和可玩性的重要来源。

## 核心类分析

### AbstractRelic - 遗物基类

AbstractRelic是所有遗物的抽象基类，定义了遗物的基本属性和行为：

```java
public abstract class AbstractRelic implements Comparable<AbstractRelic> {
    // 基本属性
    public final String name;        // 遗物名称
    public final String relicId;     // 遗物唯一标识
    public String description;       // 遗物描述
    public String flavorText = "missing"; // 遗物背景文本
    
    // 数值相关
    public int cost;                // 遗物价格
    public int counter = -1;        // 计数器（-1表示不显示）
    public boolean energyBased = false; // 是否基于能量
    
    // 状态相关
    public boolean usedUp = false;  // 是否已使用
    public boolean grayscale = false; // 是否灰度显示
    public boolean isSeen = false; // 是否已见过
    public boolean isDone = false; // 是否完成动画
    public boolean isAnimating = false; // 是否正在动画
    public boolean isObtained = false; // 是否已获得
    public boolean discarded = false; // 是否已丢弃
    
    // 类型相关
    public RelicTier tier;         // 遗物稀有度
    public LandingSound landingSFX; // 落地音效
    
    // 视觉资源
    public Texture img;             // 遗物图标
    public Texture largeImg;        // 大图标
    public Texture outlineImg;      // 轮廓图标
    public String imgUrl = "";      // 图像路径
    
    // 位置和动画
    public float currentX, currentY; // 当前位置
    public float targetX, targetY;   // 目标位置
    public float scale = Settings.scale; // 缩放
    public float rotation = 0.0F;    // 旋转角度
    public Hitbox hb;               // 碰撞箱
    
    // 动画效果
    private FloatyEffect f_effect = new FloatyEffect(10.0F, 0.2F);
    private float animationTimer;
    private float glowTimer = 0.0F;
    public float flashTimer = 0.0F;
    protected boolean pulse = false;
    
    // 提示信息
    public ArrayList<PowerTip> tips = new ArrayList<>();
    private final RelicStrings relicStrings;
    public final String[] DESCRIPTIONS;
}
```

#### 遗物稀有度枚举

```java
public enum RelicTier {
    DEPRECATED,  // 已废弃
    STARTER,    // 起始遗物
    COMMON,      // 普通遗物
    UNCOMMON,    // 罕见遗物
    RARE,        // 稀有遗物
    SPECIAL,     // 特殊遗物
    BOSS,        // Boss遗物
    SHOP;        // 商店遗物
}
```

#### 落地音效枚举

```java
public enum LandingSound {
    CLINK,   // 金属声
    FLAT,    // 平坦声
    HEAVY,   // 沉重声
    MAGICAL, // 魔法声
    SOLID;   // 坚实声
}
```

#### 核心方法

1. **makeCopy()** - 创建遗物副本（抽象方法）
2. **onEquip()** - 装备时触发
3. **onUnequip()** - 卸装时触发
4. **atBattleStart()** - 战斗开始时触发
5. **atTurnStart()** - 回合开始时触发
6. **onPlayCard()** - 使用卡牌时触发
7. **onMonsterDeath()** - 怪物死亡时触发
8. **canSpawn()** - 检查是否可以生成

### 遗物生命周期

#### 初始化流程

```java
public AbstractRelic(String setId, String imgName, RelicTier tier, LandingSound sfx) {
    this.relicId = setId;
    this.relicStrings = CardCrawlGame.languagePack.getRelicStrings(this.relicId);
    this.DESCRIPTIONS = this.relicStrings.DESCRIPTIONS;
    this.imgUrl = imgName;
    
    // 加载图像资源
    ImageMaster.loadRelicImg(setId, imgName);
    this.img = ImageMaster.getRelicImg(setId);
    this.outlineImg = ImageMaster.getRelicOutlineImg(setId);
    
    // 设置基本属性
    this.name = this.relicStrings.NAME;
    this.description = getUpdatedDescription();
    this.flavorText = this.relicStrings.FLAVOR;
    this.tier = tier;
    this.landingSFX = sfx;
    this.assetURL = "images/relics/" + imgName;
    
    // 初始化提示
    this.tips.add(new PowerTip(this.name, this.description));
    initializeTips();
}
```

#### 获得流程

```java
// 生成遗物
public void spawn(float x, float y) {
    if (!(AbstractDungeon.getCurrRoom() instanceof com.megacrit.cardcrawl.rooms.ShopRoom)) {
        AbstractDungeon.effectsQueue.add(new SmokePuffEffect(x, y));
    }
    
    this.currentX = x;
    this.currentY = y;
    this.isAnimating = true;
    this.isObtained = false;
    
    // Boss遗物特殊处理
    if (this.tier == RelicTier.BOSS) {
        this.f_effect.x = 0.0F;
        this.f_effect.y = 0.0F;
        this.targetX = x;
        this.targetY = y;
        this.glowTimer = 0.0F;
    }
}

// 获得遗物
public void obtain() {
    // 特殊处理：环状遗物
    if (this.relicId == "Circlet" && AbstractDungeon.player.hasRelic("Circlet")) {
        AbstractRelic circ = AbstractDungeon.player.getRelic("Circlet");
        circ.counter++;
        circ.flash();
        this.hb.hovered = false;
    } else {
        this.hb.hovered = false;
        int row = AbstractDungeon.player.relics.size();
        this.targetX = START_X + row * PAD_X;
        this.targetY = START_Y;
        AbstractDungeon.player.relics.add(this);
        relicTip();
        UnlockTracker.markRelicAsSeen(this.relicId);
    }
}

// 立即获得遗物
public void instantObtain(AbstractPlayer p, int slot, boolean callOnEquip) {
    if (this.relicId.equals("Circlet") && p != null && p.hasRelic("Circlet")) {
        AbstractRelic circ = p.getRelic("Circlet");
        circ.counter++;
        circ.flash();
        this.isDone = true;
        this.isObtained = true;
        this.discarded = true;
    } else {
        this.isDone = true;
        this.isObtained = true;
        
        if (slot >= p.relics.size()) {
            p.relics.add(this);
        } else {
            p.relics.set(slot, this);
        }
        
        this.currentX = START_X + slot * PAD_X;
        this.currentY = START_Y;
        this.targetX = this.currentX;
        this.targetY = this.currentY;
        this.hb.move(this.currentX, this.currentY);
        
        if (callOnEquip) {
            onEquip();
            relicTip();
        }
        
        UnlockTracker.markRelicAsSeen(this.relicId);
        getUpdatedDescription();
        
        if (AbstractDungeon.topPanel != null) {
            AbstractDungeon.topPanel.adjustRelicHbs();
        }
    }
}
```

#### 装备和卸装流程

```java
// 装备遗物
public void onEquip() {
    // 默认空实现，子类可重写
}

// 卸装遗物
public void onUnequip() {
    // 默认空实现，子类可重写
}

// 使用完毕
public void usedUp() {
    this.grayscale = true;
    this.usedUp = true;
    this.description = MSG[2];
    this.tips.clear();
    this.tips.add(new PowerTip(this.name, this.description));
    initializeTips();
}
```

## 数据结构

### 遗物属性系统

```java
// 基本属性
public final String name;        // 显示名称
public final String relicId;     // 唯一标识
public String description;       // 描述文本
public String flavorText;        // 背景文本

// 数值系统
public int cost;                // 商店价格
public int counter;             // 计数器
public boolean energyBased;     // 是否基于能量

// 状态系统
public boolean usedUp;          // 是否已使用
public boolean grayscale;       // 是否灰度显示
public boolean isSeen;          // 是否已见过
public boolean isObtained;      // 是否已获得
public boolean discarded;       // 是否已丢弃

// 类型系统
public RelicTier tier;          // 稀有度
public LandingSound landingSFX;  // 落地音效
```

### 视觉资源系统

```java
// 图像资源
public Texture img;             // 遗物图标
public Texture largeImg;        // 大图标
public Texture outlineImg;      // 轮廓图标
public String imgUrl;           // 图像路径

// 位置和变换
public float currentX, currentY; // 当前位置
public float targetX, targetY;   // 目标位置
public float scale;             // 缩放比例
public float rotation;          // 旋转角度

// 交互区域
public Hitbox hb;               // 碰撞箱
```

### 动画系统

```java
// 动画效果
private FloatyEffect f_effect;  // 漂浮效果
private float animationTimer;    // 动画计时器
private float glowTimer;         // 发光计时器
public float flashTimer;         // 闪烁计时器
protected boolean pulse;         // 脉冲状态

// 动画状态
public boolean isAnimating;     // 是否正在动画
public boolean isDone;          // 是否完成
```

### 事件回调系统

```java
// 战斗事件
public void atPreBattle();                    // 战斗前
public void atBattleStart();                  // 战斗开始
public void atBattleStartPreDraw();           // 战斗开始前抽牌
public void atTurnStart();                    // 回合开始
public void atTurnStartPostDraw();            // 回合开始后抽牌
public void onPlayerEndTurn();                // 玩家回合结束
public void onVictory();                      // 胜利时

// 卡牌事件
public void onPlayCard(AbstractCard c, AbstractMonster m); // 使用卡牌
public void onUseCard(AbstractCard targetCard, UseCardAction useCardAction); // 使用卡牌动作
public void onAfterUseCard(AbstractCard card, UseCardAction action); // 使用卡牌后
public void onCardDraw(AbstractCard drawnCard); // 抽牌时
public void onExhaust(AbstractCard card);      // 消耗卡牌时
public void onManualDiscard();                 // 手动弃牌时

// 怪物事件
public void onSpawnMonster(AbstractMonster monster); // 生成怪物
public void onMonsterDeath(AbstractMonster m); // 怪物死亡
public void onAttack(DamageInfo info, int damageAmount, AbstractCreature target); // 攻击时
public int onAttacked(DamageInfo info, int damageAmount); // 被攻击时

// 房间事件
public void onEnterRoom(AbstractRoom room);   // 进入房间
public void justEnteredRoom(AbstractRoom room); // 刚进入房间
public void onEnterRestRoom();                // 进入休息房间
public void onChestOpen(boolean bossChest);   // 打开箱子

// 生命值事件
public void onBloodied();                     // 流血时
public void onNotBloodied();                  // 未流血时
public void onLoseHp(int damageAmount);       // 失去生命值
public int onPlayerHeal(int healAmount);      // 玩家治疗
public int onPlayerGainBlock(int blockAmount); // 玩家获得格挡

// 其他事件
public void onGainGold();                     // 获得金币
public void onLoseGold();                     // 失去金币
public void onSpendGold();                    // 花费金币
public void onEnergyRecharge();               // 能量充能
public void onChangeStance(AbstractStance prevStance, AbstractStance newStance); // 姿态改变
public void onEvokeOrb(AbstractOrb ammo);     // 召唤球体
public void onUsePotion();                    // 使用药水
```

## 算法与逻辑

### 遗物价格计算

```java
public int getPrice() {
    switch (this.tier) {
        case COMMON:
            return 150;
        case UNCOMMON:
            return 250;
        case RARE:
            return 400;
        case BOSS:
            return -1; // Boss遗物不售卖
        case SHOP:
            return 300;
        case SPECIAL:
            return 150;
        case STARTER:
            return -1; // 起始遗物不售卖
        default:
            return -1;
    }
}
```

### 遗物生成逻辑

```java
// 检查是否可以生成
public boolean canSpawn() {
    return true; // 默认可以生成，子类可重写
}

// 生成遗物池
public static ArrayList<String> generateRelicPool(RelicTier tier) {
    ArrayList<String> pool = new ArrayList<>();
    
    // 添加对应稀有度的所有遗物
    for (String relicId : RelicLibrary.getAllRelicIds()) {
        AbstractRelic relic = RelicLibrary.getRelic(relicId);
        if (relic.tier == tier && relic.canSpawn()) {
            pool.add(relicId);
        }
    }
    
    // 移除已拥有的遗物
    if (AbstractDungeon.player != null) {
        for (AbstractRelic ownedRelic : AbstractDungeon.player.relics) {
            pool.remove(ownedRelic.relicId);
        }
    }
    
    return pool;
}
```

### 遗物更新逻辑

```java
public void update() {
    updateFlash();
    
    if (!this.isDone) {
        // 动画状态更新
        if (this.isAnimating) {
            updateAnimation();
        } else if (this.hb.hovered) {
            this.scale = Settings.scale * 1.25F;
        } else {
            this.scale = MathHelper.scaleLerpSnap(this.scale, Settings.scale);
        }
        
        // 获得后的移动动画
        if (this.isObtained) {
            updateObtainAnimation();
        }
        
        // 碰撞箱更新
        if (this.hb != null) {
            this.hb.update();
            updateClickLogic();
        }
        
        // Boss奖励屏幕特殊处理
        if (AbstractDungeon.screen == AbstractDungeon.CurrentScreen.BOSS_REWARD) {
            updateAnimation();
        }
    } else {
        // 已完成状态的更新
        updateCompletedState();
    }
}

private void updateObtainAnimation() {
    // 旋转动画
    if (this.rotation != 0.0F) {
        this.rotation = MathUtils.lerp(this.rotation, 0.0F, Gdx.graphics.getDeltaTime() * 6.0F * 2.0F);
    }
    
    // 位置插值
    if (this.currentX != this.targetX) {
        this.currentX = MathUtils.lerp(this.currentX, this.targetX, Gdx.graphics.getDeltaTime() * 6.0F);
        if (Math.abs(this.currentX - this.targetX) < 0.5F) {
            this.currentX = this.targetX;
        }
    }
    
    if (this.currentY != this.targetY) {
        this.currentY = MathUtils.lerp(this.currentY, this.targetY, Gdx.graphics.getDeltaTime() * 6.0F);
        if (Math.abs(this.currentY - this.targetY) < 0.5F) {
            this.currentY = this.targetY;
        }
    }
    
    // 检查是否到达目标位置
    if (this.currentY == this.targetY && this.currentX == this.targetX) {
        this.isDone = true;
        if (AbstractDungeon.topPanel != null) {
            AbstractDungeon.topPanel.adjustRelicHbs();
        }
        this.hb.move(this.currentX, this.currentY);
        
        // Boss遗物特殊处理
        if (this.tier == RelicTier.BOSS && AbstractDungeon.getCurrRoom() instanceof com.megacrit.cardcrawl.rooms.TreasureRoomBoss) {
            AbstractDungeon.overlayMenu.proceedButton.show();
        }
        
        onEquip();
    }
    
    this.scale = Settings.scale;
}
```

### 遗物渲染逻辑

```java
public void renderInTopPanel(SpriteBatch sb) {
    if (Settings.hideRelics) {
        return;
    }
    
    // 渲染轮廓
    renderOutline(sb, true);
    
    // 灰度处理
    if (this.grayscale) {
        ShaderHelper.setShader(sb, ShaderHelper.Shader.GRAYSCALE);
    }
    
    // 渲染遗物图标
    sb.setColor(Color.WHITE);
    sb.draw(this.img, this.currentX - 64.0F + offsetX, this.currentY - 64.0F, 
             64.0F, 64.0F, 128.0F, 128.0F, this.scale, this.scale, this.rotation, 
             0, 0, 128, 128, false, false);
    
    // 恢复着色器
    if (this.grayscale) {
        ShaderHelper.setShader(sb, ShaderHelper.Shader.DEFAULT);
    }
    
    // 渲染计数器
    renderCounter(sb, true);
    
    // 渲染闪烁效果
    renderFlash(sb, true);
    
    // 渲染碰撞箱
    this.hb.render(sb);
}

public void render(SpriteBatch sb) {
    if (Settings.hideRelics) {
        return;
    }
    
    renderOutline(sb, false);
    
    // 根据状态渲染
    if (!this.isObtained && (!AbstractDungeon.isScreenUp || 
        AbstractDungeon.screen == AbstractDungeon.CurrentScreen.BOSS_REWARD || 
        AbstractDungeon.screen == AbstractDungeon.CurrentScreen.SHOP)) {
        
        // 未获得状态
        if (this.hb.hovered) {
            renderBossTip(sb);
        }
        
        if (AbstractDungeon.screen == AbstractDungeon.CurrentScreen.BOSS_REWARD) {
            renderBossRewardState(sb);
        }
    }
    
    // 渲染遗物图标
    renderRelicIcon(sb);
    
    // 渲染特效
    if (this.isDone) {
        renderFlash(sb, false);
    }
    
    this.hb.render(sb);
}
```

## 系统交互

### 与角色系统的交互

```java
// 玩家获得遗物
public void obtainRelic(AbstractRelic relic) {
    relic.obtain();
    this.relics.add(relic);
    
    // 调整UI
    if (AbstractDungeon.topPanel != null) {
        AbstractDungeon.topPanel.adjustRelicHbs();
    }
}

// 玩家失去遗物
public void loseRelic(String relicId) {
    AbstractRelic relic = getRelic(relicId);
    if (relic != null) {
        relic.onUnequip();
        this.relics.remove(relic);
        
        // 调整UI
        if (AbstractDungeon.topPanel != null) {
            AbstractDungeon.topPanel.adjustRelicHbs();
        }
    }
}
```

### 与战斗系统的交互

```java
// 战斗开始时触发所有遗物
public void onBattleStart() {
    for (AbstractRelic relic : relics) {
        relic.atBattleStart();
    }
}

// 回合开始时触发所有遗物
public void atTurnStart() {
    for (AbstractRelic relic : relics) {
        relic.atTurnStart();
    }
}

// 使用卡牌时触发所有遗物
public void onPlayCard(AbstractCard card, AbstractMonster monster) {
    for (AbstractRelic relic : relics) {
        relic.onPlayCard(card, monster);
    }
}
```

### 与商店系统的交互

```java
// 商店购买遗物
public void purchaseRelic(AbstractRelic relic) {
    if (this.gold >= relic.getPrice()) {
        this.gold -= relic.getPrice();
        relic.instantObtain(this, this.relics.size(), true);
        
        // 播放音效
        relic.playLandingSFX();
    }
}

// 商店售卖遗物
public void sellRelic(AbstractRelic relic) {
    int sellPrice = relic.getPrice() / 2;
    this.gold += sellPrice;
    this.loseRelic(relic.relicId);
}
```

## 关键流程

### 遗物获得流程

```java
// 1. 生成遗物
AbstractRelic relic = RelicLibrary.getRelic("BurningBlood").makeCopy();

// 2. 设置位置
relic.spawn(x, y);

// 3. 玩家交互
if (relic.hb.clicked) {
    relic.obtain();
}

// 4. 获得处理
public void obtain() {
    // 添加到玩家遗物列表
    AbstractDungeon.player.relics.add(this);
    
    // 触发装备效果
    onEquip();
    
    // 显示提示
    relicTip();
    
    // 标记为已见
    UnlockTracker.markRelicAsSeen(this.relicId);
}
```

### 遗物触发流程

```java
// 战斗开始触发
public void atBattleStart() {
    // 触发所有遗物的战斗开始效果
    for (AbstractRelic relic : AbstractDungeon.player.relics) {
        relic.atBattleStart();
    }
}

// 使用卡牌触发
public void onPlayCard(AbstractCard card, AbstractMonster monster) {
    // 触发所有遗物的卡牌使用效果
    for (AbstractRelic relic : AbstractDungeon.player.relics) {
        relic.onPlayCard(card, monster);
    }
}

// 怪物死亡触发
public void onMonsterDeath(AbstractMonster monster) {
    // 触发所有遗物的怪物死亡效果
    for (AbstractRelic relic : AbstractDungeon.player.relics) {
        relic.onMonsterDeath(monster);
    }
}
```

### 遗物保存和加载

```java
// 保存遗物数据
public String save() {
    StringBuilder saveData = new StringBuilder();
    for (AbstractRelic relic : relics) {
        saveData.append(relic.relicId).append(",");
        if (relic.counter > -1) {
            saveData.append(relic.counter);
        }
        saveData.append(";");
    }
    return saveData.toString();
}

// 加载遗物数据
public void load(String saveData) {
    String[] relicData = saveData.split(";");
    for (String data : relicData) {
        String[] parts = data.split(",");
        String relicId = parts[0];
        int counter = parts.length > 1 ? Integer.parseInt(parts[1]) : -1;
        
        AbstractRelic relic = RelicLibrary.getRelic(relicId).makeCopy();
        if (counter > -1) {
            relic.counter = counter;
        }
        
        relic.instantObtain(this, this.relics.size(), false);
    }
}
```

## 设计模式

### 模板方法模式

AbstractRelic使用模板方法模式定义了遗物的基本结构：

```java
public abstract class AbstractRelic {
    // 模板方法
    public final void obtain() {
        setupPosition();
        addToPlayerRelics();
        triggerEquipEffect();
        showTip();
        markAsSeen();
    }
    
    // 钩子方法
    protected abstract void onEquip();
    protected abstract AbstractRelic makeCopy();
}
```

### 观察者模式

遗物系统作为观察者监听游戏事件：

```java
// 事件通知
public void onPlayCard(AbstractCard card, AbstractMonster monster) {
    // 通知所有观察者（遗物）
    for (AbstractRelic relic : AbstractDungeon.player.relics) {
        relic.onPlayCard(card, monster);
    }
}
```

### 工厂模式

遗物创建使用工厂模式：

```java
public class RelicLibrary {
    private static HashMap<String, AbstractRelic> relics = new HashMap<>();
    
    public static AbstractRelic getRelic(String relicId) {
        AbstractRelic relic = relics.get(relicId);
        return relic != null ? relic.makeCopy() : null;
    }
    
    public static void addRelicToPool(AbstractRelic relic) {
        relics.put(relic.relicId, relic);
    }
}
```

### 策略模式

不同的遗物实现不同的策略：

```java
// 伤害加成策略
public class SneckoEye extends AbstractRelic {
    @Override
    public void onEquip() {
        // 改变抽牌数量
        AbstractDungeon.player.masterHandSize += 1;
    }
}

// 治疗策略
public class BurningBlood extends AbstractRelic {
    @Override
    public void onVictory() {
        // 战斗胜利后治疗
        AbstractDungeon.player.heal(6);
    }
}
```

## 性能考虑

### 渲染优化

```java
// 条件渲染
public void renderInTopPanel(SpriteBatch sb) {
    if (Settings.hideRelics) {
        return; // 隐藏遗物时不渲染
    }
    
    // 只渲染当前页面的遗物
    if (AbstractDungeon.player.relics.indexOf(this) / MAX_RELICS_PER_PAGE == relicPage) {
        renderRelic(sb);
    }
}
```

### 内存管理

```java
// 延迟加载大图标
public void loadLargeImg() {
    if (this.largeImg == null) {
        this.largeImg = ImageMaster.loadImage("images/largeRelics/" + this.imgUrl);
    }
}

// 及时清理资源
public void dispose() {
    if (this.img != null) {
        this.img.dispose();
    }
    if (this.largeImg != null) {
        this.largeImg.dispose();
    }
}
```

### 更新优化

```java
// 分帧更新
public void update() {
    // 只更新需要更新的部分
    if (this.flashTimer > 0) {
        updateFlash();
    }
    
    if (this.isAnimating) {
        updateAnimation();
    }
    
    if (this.hb.hovered) {
        updateHoverEffect();
    }
}
```

## 扩展机制

### 自定义遗物

```java
public class CustomRelic extends AbstractRelic {
    public static final String RELIC_ID = "CustomRelic";
    
    public CustomRelic() {
        super(RELIC_ID, "custom_relic.png", RelicTier.RARE, LandingSound.MAGICAL);
    }
    
    @Override
    public String getUpdatedDescription() {
        return DESCRIPTIONS[0] + 5 + DESCRIPTIONS[1];
    }
    
    @Override
    public void onEquip() {
        // 装备效果
        AbstractDungeon.player.masterHandSize += 1;
    }
    
    @Override
    public void onUnequip() {
        // 卸装效果
        AbstractDungeon.player.masterHandSize -= 1;
    }
    
    @Override
    public void atBattleStart() {
        // 战斗开始效果
        flash();
    }
    
    @Override
    public void onPlayCard(AbstractCard card, AbstractMonster monster) {
        // 使用卡牌效果
        if (card.type == AbstractCard.CardType.ATTACK) {
            flash();
        }
    }
    
    @Override
    public AbstractRelic makeCopy() {
        return new CustomRelic();
    }
}
```

### 条件遗物

```java
public class ConditionalRelic extends AbstractRelic {
    public ConditionalRelic() {
        super("ConditionalRelic", "conditional.png", RelicTier.UNCOMMON, LandingSound.CLINK);
    }
    
    @Override
    public boolean canSpawn() {
        // 只在特定条件下生成
        return AbstractDungeon.player.chosenClass == AbstractPlayer.PlayerClass.IRONCLAD;
    }
    
    @Override
    public void onEquip() {
        // 根据角色类型提供不同效果
        if (AbstractDungeon.player.chosenClass == AbstractPlayer.PlayerClass.IRONCLAD) {
            AbstractDungeon.player.masterMaxHealth += 10;
        }
    }
    
    @Override
    public AbstractRelic makeCopy() {
        return new ConditionalRelic();
    }
}
```

## 总结

遗物系统是杀戮尖塔的核心机制之一，通过AbstractRelic基类提供了丰富的效果系统。该系统的设计特点包括：

1. **灵活的事件系统** - 通过丰富的回调方法支持各种游戏事件
2. **分层的稀有度系统** - 不同稀有度提供不同强度的效果
3. **完整的生命周期管理** - 从生成到获得的完整流程
4. **强大的视觉效果** - 丰富的动画和特效系统
5. **良好的扩展性** - 易于添加新的遗物类型和效果

遗物系统为游戏提供了丰富的策略深度和可玩性，是游戏设计的重要组成部分。通过深入理解遗物系统，可以更好地理解游戏的核心机制，并为Mod开发提供坚实的基础。