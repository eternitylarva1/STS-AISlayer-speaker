# 杀戮尖塔房间系统深度解析

## 概述

房间系统是《杀戮尖塔》的核心架构之一，构成了游戏的主要流程框架。每个房间代表游戏中的一个独立场景，具有不同的功能、规则和交互方式。本文档将深入分析房间系统的设计模式、实现机制和扩展性。

## 核心类结构

### AbstractRoom - 房间基类

`AbstractRoom`是所有房间的抽象基类，定义了房间的基本属性和行为：

```java
public abstract class AbstractRoom implements Disposable {
    // 房间内容
    public ArrayList<AbstractPotion> potions = new ArrayList<>();
    public ArrayList<AbstractRelic> relics = new ArrayList<>();
    public ArrayList<RewardItem> rewards = new ArrayList<>();
    public SoulGroup souls = new SoulGroup();
    
    // 房间状态
    public RoomPhase phase;
    public AbstractEvent event = null;
    public MonsterGroup monsters;
    
    // 房间标识
    protected String mapSymbol;
    protected Texture mapImg;
    protected Texture mapImgOutline;
    
    // 战斗状态
    public boolean isBattleOver = false;
    public boolean cannotLose = false;
    public boolean eliteTrigger = false;
    
    // 特殊状态
    public boolean mugged = false, smoked = false;
    public boolean combatEvent = false;
    public boolean rewardAllowed = true;
    public boolean rewardTime = false;
    public boolean skipMonsterTurn = false;
    
    // 卡牌稀有度概率
    public int baseRareCardChance = 3;
    public int baseUncommonCardChance = 37;
    public int rareCardChance = this.baseRareCardChance;
    public int uncommonCardChance = this.baseUncommonCardChance;
    
    // 计时器
    private float endBattleTimer = 0.0F;
    public float rewardPopOutTimer = 1.0F;
    public static float waitTimer = 0.0F;
}
```

### 房间状态枚举

#### RoomPhase - 房间阶段
```java
public enum RoomPhase {
    COMBAT,    // 战斗阶段
    EVENT,     // 事件阶段
    COMPLETE,  // 完成阶段
    INCOMPLETE // 未完成阶段
}
```

#### RoomType - 房间类型
```java
public enum RoomType {
    SHOP,     // 商店
    MONSTER,  // 怪物
    SHRINE,   // 神龛
    TREASURE, // 宝藏
    EVENT,    // 事件
    BOSS      // Boss
}
```

## 房间生命周期

### 1. 房间初始化

每个房间子类必须实现`onPlayerEntry()`方法：

```java
public abstract void onPlayerEntry();
```

#### MonsterRoom 初始化
```java
public void onPlayerEntry() {
    playBGM(null);
    if (this.monsters == null) {
        this.monsters = CardCrawlGame.dungeon.getMonsterForRoomCreation();
        this.monsters.init();
    }
    waitTimer = 0.1F;
}
```

#### EventRoom 初始化
```java
public void onPlayerEntry() {
    AbstractDungeon.overlayMenu.proceedButton.hide();
    Random eventRngDuplicate = new Random(Settings.seed, AbstractDungeon.eventRng.counter);
    this.event = AbstractDungeon.generateEvent(eventRngDuplicate);
    this.event.onEnterRoom();
}
```

#### ShopRoom 初始化
```java
public void onPlayerEntry() {
    if (!AbstractDungeon.id.equals("TheEnding")) {
        playBGM("SHOP");
    }
    AbstractDungeon.overlayMenu.proceedButton.setLabel(TEXT[0]);
    setMerchant(new Merchant());
}
```

### 2. 房间更新循环

房间的核心更新逻辑在`update()`方法中实现：

```java
public void update() {
    // 通用更新逻辑
    if (!AbstractDungeon.isScreenUp && InputHelper.pressedEscape && 
        AbstractDungeon.overlayMenu.cancelButton.current_x == CancelButton.HIDE_X) {
        AbstractDungeon.settingsScreen.open();
    }
    
    // 调试功能
    if (Settings.isDebug) {
        // 调试快捷键处理
    }
    
    // 根据房间阶段更新
    switch (this.phase) {
        case EVENT:
            this.event.updateDialog();
            break;
        case COMBAT:
            updateCombatPhase();
            break;
        case COMPLETE:
            updateCompletePhase();
            break;
        case INCOMPLETE:
            break;
    }
    
    // 玩家更新
    AbstractDungeon.player.update();
    AbstractDungeon.player.updateAnimations();
}
```

### 3. 战斗阶段更新

战斗阶段的更新逻辑最为复杂：

```java
private void updateCombatPhase() {
    this.monsters.update();
    
    if (waitTimer > 0.0F) {
        // 战斗开始等待
        if (AbstractDungeon.actionManager.currentAction != null || 
            !AbstractDungeon.actionManager.isEmpty()) {
            AbstractDungeon.actionManager.update();
        } else {
            waitTimer -= Gdx.graphics.getDeltaTime();
        }
        
        if (waitTimer <= 0.0F) {
            startCombat();
        }
    } else {
        // 战斗进行中
        updateCombatInProgress();
        
        // 检查战斗结束
        if (this.isBattleOver && AbstractDungeon.actionManager.actions.isEmpty()) {
            handleBattleEnd();
        }
    }
    
    this.monsters.updateAnimations();
}
```

### 4. 战斗开始流程

```java
private void startCombat() {
    AbstractDungeon.actionManager.turnHasEnded = true;
    if (!AbstractDungeon.isScreenUp) {
        AbstractDungeon.topLevelEffects.add(new BattleStartEffect(false));
    }
    
    // 获得能量和启用控制
    AbstractDungeon.actionManager.addToBottom(
        new GainEnergyAndEnableControlsAction(AbstractDungeon.player.energy.energyMaster));
    
    // 战斗前逻辑
    AbstractDungeon.player.applyStartOfCombatPreDrawLogic();
    AbstractDungeon.actionManager.addToBottom(
        new DrawCardAction(AbstractDungeon.player, AbstractDungeon.player.gameHandSize));
    AbstractDungeon.actionManager.addToBottom(new EnableEndTurnButtonAction());
    AbstractDungeon.overlayMenu.showCombatPanels();
    AbstractDungeon.player.applyStartOfCombatLogic();
    
    // Mod支持
    if (ModHelper.isModEnabled("Careless")) {
        Careless.modAction();
    }
    if (ModHelper.isModEnabled("ControlledChaos")) {
        ControlledChaos.modAction();
    }
    
    // 回合开始触发
    this.skipMonsterTurn = false;
    AbstractDungeon.player.applyStartOfTurnRelics();
    AbstractDungeon.player.applyStartOfTurnPostDrawRelics();
    AbstractDungeon.player.applyStartOfTurnCards();
    AbstractDungeon.player.applyStartOfTurnPowers();
    AbstractDungeon.player.applyStartOfTurnOrbs();
    AbstractDungeon.actionManager.useNextCombatActions();
}
```

### 5. 战斗结束处理

```java
private void handleBattleEnd() {
    this.skipMonsterTurn = false;
    this.endBattleTimer -= Gdx.graphics.getDeltaTime();
    
    if (this.endBattleTimer < 0.0F) {
        this.phase = RoomPhase.COMPLETE;
        
        // 播放胜利音效
        if (!(AbstractDungeon.getCurrRoom() instanceof MonsterRoomBoss) || 
            !(CardCrawlGame.dungeon instanceof TheBeyond) || Settings.isEndless) {
            CardCrawlGame.sound.play("VICTORY");
        }
        
        this.endBattleTimer = 0.0F;
        
        // 处理特殊房间奖励
        handleSpecialRoomRewards();
        
        // 生成奖励
        if (rewardAllowed) {
            dropReward();
            addPotionToRewards();
            
            // 打开奖励界面
            openRewardScreen();
        }
    }
}
```

## 房间类型详解

### 1. MonsterRoom - 怪物房间

怪物房间是最常见的房间类型，包含战斗 encounters：

```java
public class MonsterRoom extends AbstractRoom {
    public DiscardPileViewScreen discardPileViewScreen = new DiscardPileViewScreen();
    public static final float COMBAT_WAIT_TIME = 0.1F;
    
    public void dropReward() {
        if (ModHelper.isModEnabled("Vintage") && 
            !(AbstractDungeon.getCurrRoom() instanceof MonsterRoomElite) && 
            !(AbstractDungeon.getCurrRoom() instanceof MonsterRoomBoss)) {
            
            AbstractRelic.RelicTier tier = returnRandomRelicTier();
            addRelicToRewards(tier);
        }
    }
    
    private AbstractRelic.RelicTier returnRandomRelicTier() {
        int roll = AbstractDungeon.relicRng.random(0, 99);
        
        if (roll < 50) {
            return AbstractRelic.RelicTier.COMMON;
        }
        if (roll > 85) {
            return AbstractRelic.RelicTier.RARE;
        }
        
        return AbstractRelic.RelicTier.UNCOMMON;
    }
}
```

### 2. EventRoom - 事件房间

事件房间提供叙事选择和随机事件：

```java
public class EventRoom extends AbstractRoom {
    public void onPlayerEntry() {
        AbstractDungeon.overlayMenu.proceedButton.hide();
        Random eventRngDuplicate = new Random(Settings.seed, AbstractDungeon.eventRng.counter);
        this.event = AbstractDungeon.generateEvent(eventRngDuplicate);
        this.event.onEnterRoom();
    }
    
    public void update() {
        super.update();
        if (!AbstractDungeon.isScreenUp) {
            this.event.update();
        }
        
        if (this.event.waitTimer == 0.0F && !this.event.hasFocus && 
            this.phase != AbstractRoom.RoomPhase.COMBAT) {
            this.phase = AbstractRoom.RoomPhase.COMPLETE;
            this.event.reopen();
        }
    }
}
```

### 3. ShopRoom - 商店房间

商店房间允许玩家购买卡牌、药水和遗物：

```java
public class ShopRoom extends AbstractRoom {
    public int shopRarityBonus = 6;
    public Merchant merchant;
    
    public ShopRoom() {
        this.phase = AbstractRoom.RoomPhase.COMPLETE;
        this.merchant = null;
        this.mapSymbol = "$";
        this.mapImg = ImageMaster.MAP_NODE_MERCHANT;
        this.mapImgOutline = ImageMaster.MAP_NODE_MERCHANT_OUTLINE;
        this.baseRareCardChance = 9;
        this.baseUncommonCardChance = 37;
    }
    
    public void onPlayerEntry() {
        if (!AbstractDungeon.id.equals("TheEnding")) {
            playBGM("SHOP");
        }
        AbstractDungeon.overlayMenu.proceedButton.setLabel(TEXT[0]);
        setMerchant(new Merchant());
    }
}
```

## 奖励系统

### 1. 卡牌稀有度计算

房间提供卡牌稀有度计算机制：

```java
public AbstractCard.CardRarity getCardRarity(int roll, boolean useAlternation) {
    this.rareCardChance = this.baseRareCardChance;
    this.uncommonCardChance = this.baseUncommonCardChance;
    
    if (useAlternation) {
        alterCardRarityProbabilities();
    }
    
    if (roll < this.rareCardChance) {
        // 检查遗物影响
        if (roll >= this.baseRareCardChance) {
            for (AbstractRelic r : AbstractDungeon.player.relics) {
                if (r.changeRareCardRewardChance(this.baseRareCardChance) > this.baseRareCardChance) {
                    r.flash();
                }
            }
        }
        return AbstractCard.CardRarity.RARE;
    }
    
    if (roll < this.rareCardChance + this.uncommonCardChance) {
        // 检查遗物影响
        if (roll >= this.baseRareCardChance + this.baseUncommonCardChance) {
            for (AbstractRelic r : AbstractDungeon.player.relics) {
                if (r.changeUncommonCardRewardChance(this.baseUncommonCardChance) > this.baseUncommonCardChance) {
                    r.flash();
                }
            }
        }
        return AbstractCard.CardRarity.UNCOMMON;
    }
    
    return AbstractCard.CardRarity.COMMON;
}
```

### 2. 遗物稀有度调整

```java
public void alterCardRarityProbabilities() {
    for (AbstractRelic r : AbstractDungeon.player.relics) {
        this.rareCardChance = r.changeRareCardRewardChance(this.rareCardChance);
    }
    for (AbstractRelic r : AbstractDungeon.player.relics) {
        this.uncommonCardChance = r.changeUncommonCardRewardChance(this.uncommonCardChance);
    }
}
```

### 3. 药水奖励生成

```java
public void addPotionToRewards() {
    int chance = 0;
    
    // 根据房间类型设置基础概率
    if (this instanceof MonsterRoomElite) {
        chance = 40;
        chance += blizzardPotionMod;
    } else if (this instanceof MonsterRoom) {
        if (!AbstractDungeon.getMonsters().haveMonstersEscaped()) {
            chance = 40;
            chance += blizzardPotionMod;
        }
    } else if (this instanceof EventRoom) {
        chance = 40;
        chance += blizzardPotionMod;
    }
    
    // 特殊遗物影响
    if (AbstractDungeon.player.hasRelic("White Beast Statue")) {
        chance = 100;
    }
    
    // 奖励数量限制
    if (this.rewards.size() >= 4) {
        chance = 0;
    }
    
    // 随机生成药水
    if (AbstractDungeon.potionRng.random(0, 99) < chance || Settings.isDebug) {
        CardCrawlGame.metricData.potions_floor_spawned.add(Integer.valueOf(AbstractDungeon.floorNum));
        this.rewards.add(new RewardItem(AbstractDungeon.returnRandomPotion()));
        blizzardPotionMod -= 10;
    } else {
        blizzardPotionMod += 10;
    }
}
```

## 对象管理系统

### 1. 房间对象更新

```java
public void updateObjects() {
    this.souls.update();
    
    // 更新药水
    for (Iterator<AbstractPotion> iterator = this.potions.iterator(); iterator.hasNext(); ) {
        AbstractPotion tmpPotion = iterator.next();
        tmpPotion.update();
        if (tmpPotion.isObtained) {
            iterator.remove();
        }
    }
    
    // 更新遗物
    for (Iterator<AbstractRelic> i = this.relics.iterator(); i.hasNext(); ) {
        AbstractRelic relic = i.next();
        relic.update();
        if (relic.isDone) {
            i.remove();
        }
    }
}
```

### 2. 遗物生成和获取

```java
public void spawnRelicAndObtain(float x, float y, AbstractRelic relic) {
    if (relic.relicId == "Circlet" && AbstractDungeon.player.hasRelic("Circlet")) {
        // 特殊遗物处理
        AbstractRelic circ = AbstractDungeon.player.getRelic("Circlet");
        circ.counter++;
        circ.flash();
    } else {
        relic.spawn(x, y);
        this.relics.add(relic);
        relic.obtain();
        relic.isObtained = true;
        relic.isAnimating = false;
        relic.isDone = false;
        relic.flash();
    }
}
```

## 回合结束处理

### 1. 结束回合流程

```java
public void endTurn() {
    AbstractDungeon.player.applyEndOfTurnTriggers();
    
    // 清理卡牌队列
    AbstractDungeon.actionManager.addToBottom(new ClearCardQueueAction());
    AbstractDungeon.actionManager.addToBottom(new DiscardAtEndOfTurnAction());
    
    // 重置卡牌属性
    resetCardAttributes();
    
    // 执行结束回合动作
    AbstractDungeon.actionManager.addToBottom(new AbstractGameAction() {
        public void update() {
            addToBot(new EndTurnAction());
            addToBot(new WaitAction(1.2F));
            if (!AbstractRoom.this.skipMonsterTurn) {
                addToBot(new MonsterStartTurnAction());
            }
            AbstractDungeon.actionManager.monsterAttacksQueued = false;
            this.isDone = true;
        }
    });
    
    AbstractDungeon.player.isEndingTurn = false;
}
```

### 2. 卡牌属性重置

```java
private void resetCardAttributes() {
    for (AbstractCard c : AbstractDungeon.player.drawPile.group) {
        c.resetAttributes();
    }
    for (AbstractCard c : AbstractDungeon.player.discardPile.group) {
        c.resetAttributes();
    }
    for (AbstractCard c : AbstractDungeon.player.hand.group) {
        c.resetAttributes();
    }
    
    if (AbstractDungeon.player.hoveredCard != null) {
        AbstractDungeon.player.hoveredCard.resetAttributes();
    }
}
```

## 战斗结束处理

### 1. 战斗胜利逻辑

```java
public void endBattle() {
    this.isBattleOver = true;
    
    // 成就检查
    if (AbstractDungeon.player.currentHealth == 1) {
        UnlockTracker.unlockAchievement("SHRUG_IT_OFF");
    }
    
    // 特殊遗物触发
    if (AbstractDungeon.player.hasRelic("Meat on the Bone")) {
        AbstractDungeon.player.getRelic("Meat on the Bone").onTrigger();
    }
    
    // 玩家胜利处理
    AbstractDungeon.player.onVictory();
    this.endBattleTimer = 0.25F;
    
    // 统计数据收集
    collectCombatStats();
    
    // 清理战斗状态
    cleanupBattleState();
}
```

### 2. 战斗统计收集

```java
private void collectCombatStats() {
    int attackCount = 0, skillCount = 0;
    for (AbstractCard c : AbstractDungeon.actionManager.cardsPlayedThisCombat) {
        if (c.type == AbstractCard.CardType.ATTACK) {
            attackCount++;
            break;
        }
        if (c.type == AbstractCard.CardType.SKILL) {
            skillCount++;
        }
    }
    
    // 成就检查
    if (attackCount == 0 && this.smoked != true) {
        UnlockTracker.unlockAchievement("COME_AT_ME");
    }
    
    // 无伤精英检查
    if (this.smoked != true) {
        if (GameActionManager.damageReceivedThisCombat - GameActionManager.hpLossThisCombat <= 0 && 
            this instanceof MonsterRoomElite) {
            CardCrawlGame.champion++;
        }
    }
    
    CardCrawlGame.metricData.addEncounterData();
}
```

### 3. 战斗状态清理

```java
private void cleanupBattleState() {
    AbstractDungeon.actionManager.clear();
    AbstractDungeon.player.inSingleTargetMode = false;
    AbstractDungeon.player.releaseCard();
    AbstractDungeon.player.hand.refreshHandLayout();
    AbstractDungeon.player.resetControllerValues();
    AbstractDungeon.overlayMenu.hideCombatPanels();
    
    // 停止姿态音效
    if (!AbstractDungeon.player.stance.ID.equals("Neutral") && AbstractDungeon.player.stance != null) {
        AbstractDungeon.player.stance.stopIdleSfx();
    }
}
```

## 渲染系统

### 1. 基础渲染

```java
public void render(SpriteBatch sb) {
    // 事件房间特殊渲染
    if (this instanceof EventRoom || this instanceof VictoryRoom) {
        if (this.event != null && 
            (!(this.event instanceof AbstractImageEvent) || this.event.combatTime)) {
            this.event.renderRoomEventPanel(sb);
            if (AbstractDungeon.screen != AbstractDungeon.CurrentScreen.VICTORY) {
                AbstractDungeon.player.render(sb);
            }
        }
    } else if (AbstractDungeon.screen != AbstractDungeon.CurrentScreen.BOSS_REWARD) {
        AbstractDungeon.player.render(sb);
    }
    
    // 非休息房间渲染怪物
    if (!(AbstractDungeon.getCurrRoom() instanceof RestRoom)) {
        if (this.monsters != null && AbstractDungeon.screen != AbstractDungeon.CurrentScreen.DEATH) {
            this.monsters.render(sb);
        }
        
        // 战斗UI渲染
        if (this.phase == RoomPhase.COMBAT) {
            AbstractDungeon.player.renderPlayerBattleUi(sb);
        }
        
        // 药水渲染
        for (AbstractPotion i : this.potions) {
            if (!i.isObtained) {
                i.render(sb);
            }
        }
    }
    
    // 遗物渲染
    for (AbstractRelic r : this.relics) {
        r.render(sb);
    }
    
    renderTips(sb);
}
```

### 2. 顶层面板渲染

```java
public void renderAboveTopPanel(SpriteBatch sb) {
    // 已获得的药水
    for (AbstractPotion i : this.potions) {
        if (i.isObtained) {
            i.render(sb);
        }
    }
    
    // 灵魂效果
    this.souls.render(sb);
    
    // 调试信息
    if (Settings.isInfo) {
        renderDebugInfo(sb);
    }
}
```

## 地图集成

### 1. 地图图标管理

```java
public final Texture getMapImg() {
    return this.mapImg;
}

public final Texture getMapImgOutline() {
    return this.mapImgOutline;
}

public final void setMapImg(Texture img, Texture imgOutline) {
    this.mapImg = img;
    this.mapImgOutline = imgOutline;
}

public final String getMapSymbol() {
    return this.mapSymbol;
}

public final void setMapSymbol(String newSymbol) {
    this.mapSymbol = newSymbol;
}
```

## 音频管理

### 1. 背景音乐控制

```java
public void playBGM(String key) {
    CardCrawlGame.music.playTempBGM(key);
}

public void playBgmInstantly(String key) {
    CardCrawlGame.music.playTempBgmInstantly(key);
}
```

## 控制器支持

### 1. 事件控制器输入

```java
public void eventControllerInput() {
    if (!Settings.isControllerMode) {
        return;
    }
    
    if (AbstractDungeon.getCurrRoom().event != null && 
        AbstractDungeon.getCurrRoom().phase != RoomPhase.COMBAT && 
        !AbstractDungeon.topPanel.selectPotionMode && 
        AbstractDungeon.topPanel.potionUi.isHidden && 
        !AbstractDungeon.topPanel.potionUi.targetMode && 
        !AbstractDungeon.player.viewingRelics) {
        
        handleEventControllerInput();
    }
}
```

## 资源管理

### 1. 资源释放

```java
public void dispose() {
    if (this.event != null) {
        this.event.dispose();
    }
    if (this.monsters != null) {
        for (AbstractMonster m : this.monsters.monsters) {
            m.dispose();
        }
    }
}
```

## 设计模式分析

### 1. 模板方法模式

`AbstractRoom`定义了房间的基本生命周期流程：

- 模板方法：`update()`定义了更新流程
- 抽象方法：`onPlayerEntry()`由子类实现
- 钩子方法：`dropReward()`提供默认实现

### 2. 状态模式

房间通过`RoomPhase`枚举管理不同状态：

- 不同状态有不同的行为
- 状态转换由游戏逻辑控制
- 每个状态有独立的更新逻辑

### 3. 策略模式

不同房间类型实现不同的策略：

- `MonsterRoom`：战斗策略
- `EventRoom`：事件策略
- `ShopRoom`：交易策略

### 4. 工厂方法模式

房间通过工厂方法创建内容：

- `getMonsterForRoomCreation()`：创建怪物组
- `generateEvent()`：生成事件
- `returnRandomRelic()`：返回随机遗物

## 扩展性设计

### 1. 新房间类型添加

添加新房间类型只需：

1. 继承`AbstractRoom`
2. 实现`onPlayerEntry()`方法
3. 重写必要的行为方法
4. 添加到房间生成逻辑

### 2. 新房间阶段添加

通过`RoomPhase`枚举扩展：

```java
public enum RoomPhase {
    COMBAT, EVENT, COMPLETE, INCOMPLETE, NEW_PHASE;
}
```

### 3. 自定义奖励系统

通过重写奖励生成方法：

```java
@Override
public void dropReward() {
    // 自定义奖励逻辑
}
```

## 性能优化

### 1. 对象池管理

- 药水和遗物对象及时清理
- 使用迭代器安全删除
- 避免内存泄漏

### 2. 渲染优化

- 条件渲染减少绘制调用
- 分层渲染提高效率
- 视锥剔除优化

### 3. 更新优化

- 状态驱动的更新逻辑
- 避免不必要的计算
- 批量处理对象更新

## 总结

房间系统是《杀戮尖塔》的核心架构，具有以下特点：

1. **高度模块化**：通过抽象基类实现组件化设计
2. **状态驱动**：清晰的状态管理和转换机制
3. **丰富的扩展性**：易于添加新房间类型和功能
4. **完善的奖励系统**：灵活的奖励生成和分配机制
5. **良好的性能**：优化的渲染和更新逻辑

这种设计使得房间系统既功能强大又易于维护和扩展，为游戏提供了丰富的玩法体验和良好的架构基础。