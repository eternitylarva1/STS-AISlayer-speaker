# 角色系统深度解析

## 概述

杀戮尖塔的角色系统是游戏的核心机制之一，包括玩家角色（AbstractPlayer）和怪物（AbstractMonster）两大类。所有角色都继承自AbstractCreature基类，共享生命值、格挡、能力等基本属性，但又有各自独特的特性和行为模式。

## 核心类分析

### AbstractCreature - 角色基类

AbstractCreature是所有角色的抽象基类，定义了角色的基本属性和行为：

```java
public abstract class AbstractCreature {
    // 基本属性
    public String name;
    public int currentHealth;
    public int maxHealth;
    public int currentBlock;
    public float drawX, drawY;
    public Hitbox hb;
    public Hitbox healthHb;
    
    // 能力系统
    public ArrayList<AbstractPower> powers = new ArrayList<>();
    
    // 渲染相关
    public TextureAtlas atlas;
    public Skeleton skeleton;
    public AnimationState state;
    public TintEffect tint = new TintEffect();
    
    // 状态标志
    public boolean isPlayer = false;
    public boolean isDying = false;
    public boolean isEscaping = false;
    public boolean isDead = false;
    public boolean isFlying = false;
    public boolean isImmuneToHazard = false;
    
    // 动画相关
    public float animX = 0.0F;
    public float animY = 0.0F;
    public boolean flipHorizontal = false;
    public boolean flipVertical = false;
    public float hbAlpha = 1.0F;
}
```

#### 关键方法

1. **damage(DamageInfo info)** - 处理伤害计算和应用
2. **heal(int healAmount)** - 处理治疗
3. **addPower(AbstractPower power)** - 添加能力
4. **render(SpriteBatch sb)** - 渲染角色
5. **update()** - 更新角色状态

### AbstractPlayer - 玩家角色

AbstractPlayer继承自AbstractCreature，是玩家控制的角色基类：

```java
public abstract class AbstractPlayer extends AbstractCreature {
    // 角色类
    public PlayerClass chosenClass;
    
    // 卡牌系统
    public CardGroup masterDeck = new CardGroup(CardGroup.CardGroupType.MASTER_DECK);
    public CardGroup drawPile = new CardGroup(CardGroup.CardGroupType.DRAW_PILE);
    public CardGroup hand = new CardGroup(CardGroup.CardGroupType.HAND);
    public CardGroup discardPile = new CardGroup(CardGroup.CardGroupType.DISCARD_PILE);
    public CardGroup exhaustPile = new CardGroup(CardGroup.CardGroupType.EXHAUST_PILE);
    public CardGroup limbo = new CardGroup(CardGroup.CardGroupType.UNSPECIFIED);
    
    // 手牌大小
    public int gameHandSize;
    public int masterHandSize;
    
    // 遗物和诅咒
    public ArrayList<AbstractRelic> relics = new ArrayList<>();
    public ArrayList<AbstractBlight> blights = new ArrayList<>();
    
    // 药水系统
    public int potionSlots = 3;
    public ArrayList<AbstractPotion> potions = new ArrayList<>();
    
    // 能量系统
    public EnergyManager energy;
    
    // 球体系统（缺陷角色专用）
    public ArrayList<AbstractOrb> orbs = new ArrayList<>();
    public int masterMaxOrbs;
    public int maxOrbs;
    public AbstractStance stance = new NeutralStance();
    
    // 交互状态
    public boolean isEndingTurn = false;
    public boolean isDraggingCard = false;
    public AbstractCard hoveredCard = null;
    public AbstractCard cardInUse = null;
    public boolean inSingleTargetMode = false;
    
    // 视觉资源
    public Texture img;
    public Texture shoulderImg;
    public Texture shoulder2Img;
    public Texture corpseImg;
}
```

#### 初始化流程

```java
public AbstractPlayer(String name, PlayerClass setClass) {
    this.name = name;
    this.title = getTitle(setClass);
    this.drawX = Settings.WIDTH * 0.25F;
    this.drawY = AbstractDungeon.floorY;
    this.chosenClass = setClass;
    this.isPlayer = true;
    
    // 初始化起始遗物
    initializeStarterRelics(setClass);
    loadPrefs();
    
    // 高层模式调整药水槽
    if (AbstractDungeon.ascensionLevel >= 11) {
        this.potionSlots--;
    }
    
    // 初始化药水槽
    this.potions.clear();
    for (int i = 0; i < this.potionSlots; i++) {
        this.potions.add(new PotionSlot(i));
    }
}
```

#### 核心方法

1. **initializeClass()** - 初始化角色类属性
2. **initializeStarterDeck()** - 初始化起始牌组
3. **initializeStarterRelics()** - 初始化起始遗物
4. **combatUpdate()** - 战斗中的更新逻辑
5. **update()** - 主更新循环
6. **draw()** - 抽牌
7. **useCard()** - 使用卡牌

### AbstractMonster - 怪物角色

AbstractMonster继承自AbstractCreature，是所有怪物的基类：

```java
public abstract class AbstractMonster extends AbstractCreature {
    // 怪物类型
    public EnemyType type = EnemyType.NORMAL;
    
    // 意图系统
    public Intent intent = Intent.DEBUG;
    public Intent tipIntent = Intent.DEBUG;
    public float intentAlpha = 0.0F;
    public float intentAlphaTarget = 0.0F;
    public String moveName = null;
    public byte nextMove = -1;
    
    // 伤害信息
    public ArrayList<DamageInfo> damage = new ArrayList<>();
    private int intentDmg = -1;
    private int intentBaseDmg = -1;
    private int intentMultiAmt = 0;
    private boolean isMultiDmg = false;
    
    // 动作历史
    public ArrayList<Byte> moveHistory = new ArrayList<>();
    private HashMap<Byte, String> moveSet = new HashMap<>();
    
    // 状态标志
    public boolean escaped = false;
    public boolean escapeNext = false;
    public boolean cannotEscape = false;
    
    // 动画计时器
    public float deathTimer = 0.0F;
    public float escapeTimer = 0.0F;
    
    // 意图相关
    private PowerTip intentTip = new PowerTip();
    public Hitbox intentHb;
    private Texture intentImg = null;
    private Texture intentBg = null;
    private Color intentColor = Color.WHITE.cpy();
    
    // 视觉效果
    private ArrayList<AbstractGameEffect> intentVfx = new ArrayList<>();
    private BobEffect bobEffect = new BobEffect();
}
```

#### 意图系统

怪物的意图系统是战斗AI的核心：

```java
public enum Intent {
    ATTACK,           // 攻击
    ATTACK_BUFF,      // 攻击+增益
    ATTACK_DEBUFF,    // 攻击+减益
    ATTACK_DEFEND,    // 攻击+防御
    BUFF,             // 增益
    DEBUFF,           // 减益
    STRONG_DEBUFF,    // 强减益
    DEBUG,            // 调试
    DEFEND,           // 防御
    DEFEND_DEBUFF,    // 防御+减益
    DEFEND_BUFF,      // 防御+增益
    ESCAPE,           // 逃跑
    MAGIC,            // 魔法
    NONE,             // 无
    SLEEP,            // 睡眠
    STUN,             // 眩晕
    UNKNOWN;          // 未知
}
```

#### 核心方法

1. **takeTurn()** - 执行回合动作（抽象方法）
2. **getMove(int roll)** - 决定下一个动作（抽象方法）
3. **setMove()** - 设置怪物动作
4. **createIntent()** - 创建意图显示
5. **calculateDamage()** - 计算伤害值
6. **applyPowers()** - 应用能力效果
7. **damage()** - 处理受到的伤害
8. **die()** - 处理死亡逻辑

## 数据结构

### 角色属性系统

所有角色共享以下基本属性：

```java
// 生命值相关
public int currentHealth;    // 当前生命值
public int maxHealth;        // 最大生命值

// 格挡系统
public int currentBlock;     // 当前格挡值

// 位置和碰撞
public float drawX, drawY;   // 绘制位置
public Hitbox hb;            // 主碰撞箱
public Hitbox healthHb;      // 生命值碰撞箱

// 能力系统
public ArrayList<AbstractPower> powers;  // 能力列表

// 渲染相关
public TextureAtlas atlas;   // 纹理图集
public Skeleton skeleton;    // Spine骨骼
public AnimationState state; // 动画状态
public TintEffect tint;      // 色调效果
```

### 玩家特有数据结构

```java
// 卡牌管理
public CardGroup masterDeck;   // 主牌组
public CardGroup drawPile;     // 抽牌堆
public CardGroup hand;         // 手牌
public CardGroup discardPile;  // 弃牌堆
public CardGroup exhaustPile;  // 消耗牌堆
public CardGroup limbo;        // 临时区域

// 遗物和诅咒
public ArrayList<AbstractRelic> relics;   // 遗物列表
public ArrayList<AbstractBlight> blights; // 诅咒列表

// 药水系统
public int potionSlots;                    // 药水槽位数
public ArrayList<AbstractPotion> potions;  // 药水列表

// 能量系统
public EnergyManager energy;               // 能量管理器

// 球体系统（缺陷角色）
public ArrayList<AbstractOrb> orbs;       // 球体列表
public int maxOrbs;                        // 最大球体数
public AbstractStance stance;              // 当前姿态
```

### 怪物特有数据结构

```java
// 意图系统
public Intent intent;           // 当前意图
public byte nextMove;           // 下一个动作
public String moveName;         // 动作名称
public ArrayList<Byte> moveHistory;  // 动作历史

// 伤害计算
public ArrayList<DamageInfo> damage;  // 伤害信息列表
private int intentDmg;          // 意图伤害值
private int intentBaseDmg;      // 基础伤害值
private boolean isMultiDmg;     // 是否多重伤害

// 状态标志
public boolean escaped;         // 是否已逃跑
public boolean escapeNext;      // 下回合逃跑
public boolean cannotEscape;    // 不能逃跑

// 动画计时
public float deathTimer;        // 死亡动画计时
public float escapeTimer;       // 逃跑动画计时
```

## 算法与逻辑

### 伤害计算流程

角色受到伤害时的完整计算流程：

```java
public void damage(DamageInfo info) {
    // 1. 无形能力处理
    if (info.output > 0 && hasPower("IntangiblePlayer")) {
        info.output = 1;
    }
    
    int damageAmount = info.output;
    
    // 2. 状态检查
    if (this.isDying || this.isEscaping) {
        return;
    }
    
    // 3. 伤害下限处理
    if (damageAmount < 0) {
        damageAmount = 0;
    }
    
    // 4. 格挡处理
    damageAmount = decrementBlock(info, damageAmount);
    
    // 5. 伤害修正（攻击方）
    if (info.owner == AbstractDungeon.player) {
        for (AbstractRelic r : AbstractDungeon.player.relics) {
            damageAmount = r.onAttackToChangeDamage(info, damageAmount);
        }
    }
    
    // 6. 伤害修正（能力）
    for (AbstractPower p : this.powers) {
        damageAmount = p.onAttackedToChangeDamage(info, damageAmount);
    }
    
    // 7. 应用伤害
    if (damageAmount > 0) {
        this.currentHealth -= damageAmount;
        if (this.currentHealth < 0) {
            this.currentHealth = 0;
        }
    }
    
    // 8. 死亡检查
    if (this.currentHealth <= 0) {
        die();
    }
}
```

### 怪物AI决策流程

怪物的AI决策遵循以下流程：

```java
public void rollMove() {
    getMove(AbstractDungeon.aiRng.random(99));
}

protected abstract void getMove(int roll);

public void createIntent() {
    this.intent = this.move.intent;
    this.nextMove = this.move.nextMove;
    this.intentBaseDmg = this.move.baseDamage;
    
    // 计算伤害
    if (this.move.baseDamage > -1) {
        calculateDamage(this.intentBaseDmg);
    }
    
    // 更新意图显示
    this.intentImg = getIntentImg();
    this.intentAlpha = 0.0F;
    this.intentAlphaTarget = 1.0F;
    updateIntentTip();
}
```

### 玩家卡牌使用流程

```java
public void useCard(AbstractCard c, AbstractMonster monster) {
    // 1. 设置使用状态
    this.cardInUse = c;
    
    // 2. 消耗能量
    c.freeToPlayOnce = false;
    c.energyOnUse = c.costForTurn;
    
    // 3. 创建使用动作
    AbstractDungeon.actionManager.addToTop(
        new UseCardAction(c, monster)
    );
    
    // 4. 从手牌移除
    this.hand.removeCard(c);
    
    // 5. 触发相关效果
    for (AbstractPower p : this.powers) {
        p.onCardDraw(c);
    }
    
    for (AbstractRelic r : this.relics) {
        r.onUseCard(c, this.hand);
    }
}
```

## 系统交互

### 与动作系统的交互

角色系统与动作系统紧密集成：

```java
// 玩家使用卡牌
public void useCard(AbstractCard c, AbstractMonster monster) {
    AbstractDungeon.actionManager.addToTop(
        new UseCardAction(c, monster)
    );
}

// 怪物执行动作
public void takeTurn() {
    for (AbstractPower p : this.powers) {
        p.onStartOfTurn();
    }
    
    // 执行具体动作
    switch (this.nextMove) {
        case 1:
            addToBot(new DamageAction(player, damage));
            break;
        case 2:
            addToBot(new ApplyPowerAction(this, this, new StrengthPower(this, 3)));
            break;
    }
}
```

### 与能力系统的交互

角色通过能力系统获得各种效果：

```java
// 添加能力
public void addPower(AbstractPower power) {
    this.powers.add(power);
    power.onInitialApplication();
}

// 移除能力
public void removePower(AbstractPower power) {
    power.onRemove();
    this.powers.remove(power);
}

// 检查能力
public boolean hasPower(String powerID) {
    for (AbstractPower p : this.powers) {
        if (p.ID.equals(powerID)) {
            return true;
        }
    }
    return false;
}
```

### 与卡牌系统的交互

玩家角色与卡牌系统的交互：

```java
// 抽牌
public void draw(int numCards) {
    for (int i = 0; i < numCards; i++) {
        if (this.drawPile.isEmpty()) {
            reshuffleDeck();
        }
        
        if (!this.drawPile.isEmpty()) {
            AbstractCard c = this.drawPile.getTopCard();
            this.drawPile.removeTopCard();
            this.hand.addToTop(c);
        }
    }
    
    this.hand.refreshHandLayout();
}

// 重新洗牌
private void reshuffleDeck() {
    while (!this.discardPile.isEmpty()) {
        AbstractCard c = this.discardPile.getTopCard();
        this.discardPile.removeTopCard();
        this.drawPile.addToBottom(c);
    }
    this.drawPile.shuffle();
}
```

## 关键流程

### 战斗初始化流程

```java
// 玩家战斗初始化
public void combatUpdate() {
    // 1. 更新卡牌
    if (this.cardInUse != null) {
        this.cardInUse.update();
    }
    
    // 2. 更新牌组
    this.limbo.update();
    this.exhaustPile.update();
    
    // 3. 更新能力粒子效果
    for (AbstractPower p : this.powers) {
        p.updateParticles();
    }
    
    // 4. 更新球体
    for (AbstractOrb o : this.orbs) {
        o.update();
    }
    
    // 5. 更新姿态
    this.stance.update();
}

// 怪物战斗初始化
public void init() {
    rollMove();
    healthBarUpdatedEvent();
}
```

### 回合结束流程

```java
// 玩家回合结束
public void onEndOfTurn() {
    // 1. 清理手牌
    for (AbstractCard c : this.hand.group) {
        if (!c.dontTriggerOnEndOfTurn) {
            c.triggerOnEndOfTurnForPlayingCard();
        }
    }
    
    // 2. 移除手牌到弃牌堆
    this.hand.moveToDiscardPile(this.hand.group);
    
    // 3. 结束回合能力效果
    for (AbstractPower p : this.powers) {
        p.atEndOfTurn(this.isPlayer);
    }
    
    // 4. 重置能量
    this.energy.recharge();
}

// 怪物回合结束
public void takeTurn() {
    // 执行动作
    switch (this.nextMove) {
        // 具体动作实现
    }
    
    // 准备下一回合
    rollMove();
    createIntent();
}
```

### 死亡处理流程

```java
// 角色死亡处理
public void die(boolean triggerRelics) {
    if (!this.isDying) {
        this.isDying = true;
        
        // 1. 触发死亡能力
        if (this.currentHealth <= 0 && triggerRelics) {
            for (AbstractPower p : this.powers) {
                p.onDeath();
            }
        }
        
        // 2. 触发遗物效果
        if (triggerRelics) {
            for (AbstractRelic r : AbstractDungeon.player.relics) {
                r.onMonsterDeath(this);
            }
        }
        
        // 3. 检查战斗结束
        if (AbstractDungeon.getMonsters().areMonstersBasicallyDead()) {
            AbstractDungeon.overlayMenu.endTurnButton.disable();
            // 清理临时卡牌
            for (AbstractCard c : AbstractDungeon.player.limbo.group) {
                AbstractDungeon.effectList.add(new ExhaustCardEffect(c));
            }
            AbstractDungeon.player.limbo.clear();
        }
        
        // 4. 启动死亡动画
        this.deathTimer = Settings.FAST_MODE ? 1.0F : 1.8F;
    }
}
```

## 设计模式

### 继承模式

角色系统使用经典的继承模式：

```
AbstractCreature (抽象基类)
├── AbstractPlayer (玩家角色抽象类)
│   ├── Ironclad (铁甲战士)
│   ├── Silent (沉默者)
│   ├── Defect (缺陷)
│   └── Watcher (观者)
└── AbstractMonster (怪物抽象类)
    ├── NormalMonster (普通怪物)
    ├── EliteMonster (精英怪物)
    └── BossMonster (Boss怪物)
```

### 状态模式

角色的不同状态通过状态模式管理：

```java
// 角色状态
public boolean isDying = false;
public boolean isEscaping = false;
public boolean isDead = false;
public boolean isFlying = false;

// 状态相关方法
public void die() {
    this.isDying = true;
    // 死亡状态处理
}

public void escape() {
    this.isEscaping = true;
    this.escapeTimer = 3.0F;
    // 逃跑状态处理
}
```

### 观察者模式

角色系统通过观察者模式处理事件：

```java
// 能力系统作为观察者
public void addPower(AbstractPower power) {
    this.powers.add(power);
    power.onInitialApplication();
}

// 事件通知
public void damage(DamageInfo info) {
    // 通知所有能力
    for (AbstractPower p : this.powers) {
        damageAmount = p.onAttackedToChangeDamage(info, damageAmount);
    }
}
```

### 策略模式

怪物的AI决策使用策略模式：

```java
// 不同的AI策略
protected abstract void getMove(int roll);

// 具体实现
@Override
protected void getMove(int roll) {
    if (roll < 25) {
        setMove(MOVE_ATTACK, Intent.ATTACK, damage);
    } else if (roll < 50) {
        setMove(MOVE_DEFEND, Intent.DEFEND);
    } else {
        setMove(MOVE_BUFF, Intent.BUFF);
    }
}
```

## 性能考虑

### 渲染优化

```java
// 条件渲染
public void render(SpriteBatch sb) {
    if (!this.isDead && !this.escaped) {
        // 只渲染存活的角色
        renderCharacter(sb);
        
        // 条件渲染意图
        if (!this.isDying && !this.isEscaping && 
            AbstractDungeon.getCurrRoom().phase == AbstractRoom.RoomPhase.COMBAT) {
            renderIntent(sb);
        }
    }
}
```

### 内存管理

```java
// 资源释放
public void dispose() {
    if (this.img != null) {
        this.img.dispose();
        this.img = null;
    }
    
    for (Disposable d : this.disposables) {
        d.dispose();
    }
    
    if (this.atlas != null) {
        this.atlas.dispose();
        this.atlas = null;
    }
}
```

### 更新优化

```java
// 分帧更新
public void update() {
    // 基础更新
    this.hb.update();
    updateHealthBar();
    updatePowers();
    
    // 条件更新
    if (AbstractDungeon.getCurrRoom().phase != AbstractRoom.RoomPhase.EVENT) {
        for (AbstractOrb o : this.orbs) {
            o.updateAnimation();
        }
    }
}
```

## 扩展机制

### 角色自定义

游戏支持通过Mod添加新角色：

```java
public class CustomCharacter extends AbstractPlayer {
    public CustomCharacter(String name, PlayerClass setClass) {
        super(name, setClass);
    }
    
    @Override
    public ArrayList<String> getStartingDeck() {
        // 定义起始牌组
        ArrayList<String> starterDeck = new ArrayList<>();
        starterDeck.add("Strike_Custom");
        starterDeck.add("Defend_Custom");
        return starterDeck;
    }
    
    @Override
    public ArrayList<String> getStartingRelics() {
        // 定义起始遗物
        ArrayList<String> starterRelics = new ArrayList<>();
        starterRelics.add("CustomRelic");
        return starterRelics;
    }
}
```

### 怪物自定义

```java
public class CustomMonster extends AbstractMonster {
    public CustomMonster(String name, String id, int maxHealth) {
        super(name, id, maxHealth, 0.0F, 0.0F, 200.0F, 240.0F, "images/monsters/custom.png");
    }
    
    @Override
    public void takeTurn() {
        switch (this.nextMove) {
            case 1:
                attack();
                break;
            case 2:
                defend();
                break;
        }
    }
    
    @Override
    protected void getMove(int roll) {
        if (roll < 50) {
            setMove(MOVE_ATTACK, Intent.ATTACK, 10);
        } else {
            setMove(MOVE_DEFEND, Intent.DEFEND);
        }
    }
}
```

## 总结

角色系统是杀戮尖塔的核心机制，通过AbstractCreature基类统一了玩家和怪物的基本属性和行为。AbstractPlayer和AbstractMonster分别实现了玩家和怪物的特定功能，包括卡牌系统、意图系统、能力系统等。

该系统的设计特点包括：
1. 清晰的继承层次结构
2. 灵活的能力系统
3. 完整的状态管理
4. 高效的渲染和更新机制
5. 良好的扩展性

通过深入理解角色系统，可以更好地理解游戏的核心机制，并为Mod开发提供坚实的基础。