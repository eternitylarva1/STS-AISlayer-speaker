# 随机数系统深度解析

## 概述

杀戮尖塔的随机数系统是游戏的核心机制之一，它确保了游戏的可重玩性和公平性。该系统基于种子(seed)机制，通过多个独立的随机数生成器(RNG)来控制游戏中的各种随机事件，包括地图生成、怪物出现、卡牌奖励、遗物获取等。

## 核心类分析

### Random类

`com.megacrit.cardcrawl.random.Random`是游戏的核心随机数生成器类，它封装了LibGDX的RandomXS128实现，并添加了计数器功能。

```java
public class Random {
    private static final Logger logger = LogManager.getLogger(Random.class.getName());
    public RandomXS128 random;  // LibGDX的随机数生成器
    public int counter = 0;     // 随机数调用计数器
    
    // 构造函数
    public Random() {
        this(Long.valueOf(MathUtils.random(9999L)), MathUtils.random(99));
    }
    
    public Random(Long seed) {
        this.random = new RandomXS128(seed.longValue());
    }
    
    public Random(Long seed, int counter) {
        this.random = new RandomXS128(seed.longValue());
        for (int i = 0; i < counter; i++) {
            random(999);  // 推进随机数状态
        }
    }
}
```

#### 关键特性

1. **计数器机制**: 每次调用随机数方法都会增加计数器，用于保存和恢复随机数状态
2. **状态复制**: 支持创建随机数生成器的副本，保持相同的状态
3. **多种随机数类型**: 提供整数、浮点数、布尔值等多种随机数生成方法

#### 随机数生成方法

```java
// 生成0到range之间的整数(包含range)
public int random(int range) {
    this.counter++;
    return this.random.nextInt(range + 1);
}

// 生成start到end之间的整数(包含两端)
public int random(int start, int end) {
    this.counter++;
    return start + this.random.nextInt(end - start + 1);
}

// 生成随机布尔值
public boolean randomBoolean() {
    this.counter++;
    return this.random.nextBoolean();
}

// 生成带概率的随机布尔值
public boolean randomBoolean(float chance) {
    this.counter++;
    return (this.random.nextFloat() < chance);
}

// 生成随机长整数
public long randomLong() {
    this.counter++;
    return this.random.nextLong();
}
```

### 随机数生成器系统

杀戮尖塔使用多个独立的随机数生成器来控制不同方面的随机性：

```java
// AbstractDungeon类中的随机数生成器
public static Random monsterRng;      // 怪物相关随机
public static Random mapRng;          // 地图生成随机
public static Random eventRng;        // 事件相关随机
public static Random merchantRng;     // 商店相关随机
public static Random cardRng;         // 卡牌相关随机
public static Random treasureRng;     // 宝藏相关随机
public static Random relicRng;        // 遗物相关随机
public static Random monsterHpRng;    // 怪物生命值随机
public static Random potionRng;       // 药水相关随机
public static Random aiRng;           // AI决策随机
public static Random shuffleRng;      // 洗牌随机
public static Random cardRandomRng;   // 卡牌随机选择
public static Random miscRng;         // 杂项随机
```

## 种子系统

### 种子生成与设置

游戏的种子系统是确保可重玩性的关键：

```java
// CharacterSelectScreen.java中的随机种子生成
private void setRandomSeed() {
    long sourceTime = System.nanoTime();
    Random rng = new Random(Long.valueOf(sourceTime));
    Settings.seedSourceTimestamp = sourceTime;
    Settings.seed = Long.valueOf(SeedHelper.generateUnoffensiveSeed(rng));
    Settings.seedSet = false;
}
```

### 种子初始化

在新游戏开始时，系统会初始化所有随机数生成器：

```java
// AbstractDungeon.java中的种子生成
public static void generateSeeds() {
    logger.info("Generating seeds: " + Settings.seed);
    monsterRng = new Random(Settings.seed);
    eventRng = new Random(Settings.seed);
    merchantRng = new Random(Settings.seed);
    cardRng = new Random(Settings.seed);
    treasureRng = new Random(Settings.seed);
    relicRng = new Random(Settings.seed);
    monsterHpRng = new Random(Settings.seed);
    potionRng = new Random(Settings.seed);
    aiRng = new Random(Settings.seed);
    shuffleRng = new Random(Settings.seed);
    cardRandomRng = new Random(Settings.seed);
    miscRng = new Random(Settings.seed);
}
```

### 种子恢复

从存档加载时，系统会恢复所有随机数生成器的状态：

```java
// AbstractDungeon.java中的种子恢复
public static void loadSeeds(SaveFile save) {
    monsterRng = new Random(Settings.seed, save.monster_seed_count);
    eventRng = new Random(Settings.seed, save.event_seed_count);
    merchantRng = new Random(Settings.seed, save.merchant_seed_count);
    cardRng = new Random(Settings.seed, save.card_seed_count);
    cardBlizzRandomizer = save.card_random_seed_randomizer;
    treasureRng = new Random(Settings.seed, save.treasure_seed_count);
    relicRng = new Random(Settings.seed, save.relic_seed_count);
    potionRng = new Random(Settings.seed, save.potion_seed_count);
    // ... 其他随机数生成器的恢复
}
```

## 随机数应用场景

### 地图生成

地图生成使用专门的随机数生成器：

```java
// TheCity.java中的地图生成
public TheCity() {
    // ...
    mapRng = new Random(Long.valueOf(Settings.seed.longValue() + (AbstractDungeon.actNum * 100)));
    generateMap();
}

// 从存档加载时
public TheCity(SaveFile saveFile) {
    // ...
    mapRng = new Random(Long.valueOf(Settings.seed.longValue() + (saveFile.act_num * 100)));
    generateMap();
}
```

### 怪物生成

怪物的生成和属性由多个随机数生成器控制：

```java
// AbstractDungeon.java中的怪物随机数初始化
public static void initializeMonsterRng() {
    monsterHpRng = new Random(Long.valueOf(Settings.seed.longValue() + floorNum));
    aiRng = new Random(Long.valueOf(Settings.seed.longValue() + floorNum));
    shuffleRng = new Random(Long.valueOf(Settings.seed.longValue() + floorNum));
    cardRandomRng = new Random(Long.valueOf(Settings.seed.longValue() + floorNum));
    miscRng = new Random(Long.valueOf(Settings.seed.longValue() + floorNum));
}
```

### 卡牌奖励

卡牌奖励的随机性由cardRng和cardRandomRng控制：

```java
// AbstractDungeon.java中的卡牌获取
public static AbstractCard returnRandomCard() {
    ArrayList<AbstractCard> list = new ArrayList<>();
    // ... 构建卡牌列表
    return list.get(cardRandomRng.random(list.size() - 1));
}

public static AbstractCard.CardRarity rollRarity(Random rng) {
    int roll = cardRng.random(99);
    roll += cardBlizzRandomizer;
    // ... 根据roll值决定稀有度
}
```

### 遗物获取

遗物的获取由relicRng控制：

```java
// AbstractDungeon.java中的遗物获取
public static AbstractRelic returnRandomRelic(AbstractRelic.RelicTier tier) {
    logger.info("Returning " + tier.name() + " relic");
    return RelicLibrary.getRelic(returnRandomRelicKey(tier)).makeCopy();
}

public static AbstractRelic.RelicTier returnRandomRelicTier() {
    int roll = relicRng.random(0, 99);
    // ... 根据roll值决定遗物稀有度
}
```

### 事件生成

事件的生成由eventRng控制：

```java
// EventRoom.java中的事件生成
public EventRoom() {
    // ...
    Random eventRngDuplicate = new Random(Settings.seed, AbstractDungeon.eventRng.counter);
    this.event = AbstractDungeon.generateEvent(eventRngDuplicate);
}

// AbstractDungeon.java中的事件生成
public static AbstractEvent generateEvent(Random rng) {
    if (rng.random(1.0F) < shrineChance) {
        return getShrine(rng);
    }
    return getEvent(rng);
}
```

## 随机数状态管理

### 计数器保存

每个随机数生成器的计数器都会被保存到存档文件中：

```java
// SaveFile.java中的随机数状态保存
public void save() {
    // ...
    this.monster_seed_count = AbstractDungeon.monsterRng.counter;
    this.event_seed_count = AbstractDungeon.eventRng.counter;
    this.merchant_seed_count = AbstractDungeon.merchantRng.counter;
    this.card_seed_count = AbstractDungeon.cardRng.counter;
    this.card_random_seed_randomizer = AbstractDungeon.cardBlizzRandomizer;
    this.treasure_seed_count = AbstractDungeon.treasureRng.counter;
    this.relic_seed_count = AbstractDungeon.relicRng.counter;
    this.potion_seed_count = AbstractDungeon.potionRng.counter;
    // ... 其他随机数生成器的计数器
}
```

### 状态复制

随机数生成器支持状态复制，用于需要保持随机数一致性的场景：

```java
// Random.java中的状态复制
public Random copy() {
    Random copied = new Random();
    copied.random = new RandomXS128(this.random.getState(0), this.random.getState(1));
    copied.counter = this.counter;
    return copied;
}
```

## 特殊随机机制

### 卡牌随机化器

卡牌系统有一个特殊的随机化机制，用于调整卡牌稀有度：

```java
// AbstractDungeon.java中的卡牌随机化器
public static int cardBlizzStartOffset = 5;
public static int cardBlizzRandomizer = cardBlizzStartOffset;
public static int cardBlizzGrowth = 1;

// 在营地时减少随机化器
if (room.phase == AbstractRoom.RoomPhase.COMPLETE) {
    if (room.event instanceof CampfireUI) {
        cardBlizzRandomizer -= cardBlizzGrowth;
        if (cardBlizzRandomizer <= cardBlizzMaxOffset) {
            cardBlizzRandomizer = cardBlizzMaxOffset;
        }
    }
}
```

### 每日挑战种子

每日挑战使用特殊的种子生成机制：

```java
// DailyScreen.java中的每日种子生成
private void generateDaily() {
    long todaySeed = getTodaySeed();
    this.todayRng = new Random(Long.valueOf(todaySeed));
    this.todaysChar = CardCrawlGame.characterManager.getRandomCharacter(this.todayRng);
    Settings.seed = Long.valueOf(this.todayRng.randomLong());
    
    String seedText = SeedHelper.getString(Settings.seed.longValue());
    if (BadWordChecker.containsBadWord(seedText)) {
        Settings.seed = Long.valueOf(SeedHelper.generateUnoffensiveSeed(this.todayRng));
    }
}
```

### 种子字符串转换

种子与字符串之间的转换用于显示和输入：

```java
// SeedHelper.java中的种子转换
public static String getString(long seed) {
    String base36 = Long.toString(seed, 36);
    if (base36.length() < 2) {
        base36 = "0" + base36;
    }
    return base36.toUpperCase();
}

public static long getLong(String seedStr) {
    if (seedStr.isEmpty()) {
        return 0L;
    }
    try {
        return Long.parseLong(seedStr, 36);
    } catch (NumberFormatException e) {
        return 0L;
    }
}
```

## 随机数调试与日志

### 随机数日志

系统会记录重要的随机数信息用于调试：

```java
// AbstractDungeon.java中的随机数日志
public static void loadSeeds(SaveFile save) {
    // ...
    logger.info("Loading seeds: " + Settings.seed);
    logger.info("Monster seed:  " + monsterRng.counter);
    logger.info("Event seed:    " + eventRng.counter);
    logger.info("Merchant seed: " + merchantRng.counter);
    // ... 其他随机数生成器的日志
}
```

### 种子验证

系统提供种子验证机制确保随机数的一致性：

```java
// SeedHelper.java中的种子验证
public static boolean isValidSeed(String seedStr) {
    if (seedStr == null || seedStr.isEmpty()) {
        return false;
    }
    try {
        Long.parseLong(seedStr, 36);
        return true;
    } catch (NumberFormatException e) {
        return false;
    }
}
```

## 性能优化

### 随机数生成器池

为了提高性能，系统可能会重用随机数生成器：

```java
// Random.java中的计数器设置
public void setCounter(int targetCounter) {
    if (this.counter < targetCounter) {
        int count = targetCounter - this.counter;
        for (int i = 0; i < count; i++) {
            randomBoolean();  // 推进随机数状态
        }
    } else {
        logger.info("ERROR: Counter is already higher than target counter!");
    }
}
```

### 随机数缓存

某些情况下，系统会缓存随机数结果：

```java
// SeedHelper.java中的种子缓存
public static String getUserFacingSeedString() {
    if (Settings.seed != null) {
        if (cachedSeed == null) {
            cachedSeed = getString(Settings.seed.longValue());
        }
        return cachedSeed;
    }
    return "";
}
```

## 设计模式与最佳实践

### 单一职责原则

每个随机数生成器负责特定领域的随机性：
- `monsterRng`: 怪物相关
- `cardRng`: 卡牌相关
- `relicRng`: 遗物相关
- 等等

### 状态可恢复性

通过计数器机制确保随机数状态可以完全恢复，保证存档/读档的一致性。

### 独立性原则

不同领域的随机数生成器相互独立，避免一个领域的随机性影响其他领域。

### 可预测性

相同的种子总是产生相同的随机数序列，确保游戏的可重玩性。

## 总结

杀戮尖塔的随机数系统是一个精心设计的复杂系统，它通过以下机制确保游戏的公平性和可重玩性：

1. **基于种子的随机数生成**: 确保相同种子产生相同结果
2. **多独立随机数生成器**: 不同领域使用独立的随机数生成器
3. **状态保存与恢复**: 通过计数器机制保存和恢复随机数状态
4. **特殊随机机制**: 如卡牌随机化器等特殊机制
5. **调试支持**: 完善的日志和验证机制

这个系统的设计使得游戏既保持了随机性的乐趣，又确保了公平性和可重玩性，是游戏设计中的一个优秀范例。