# 核心游戏架构分析

## 概述

杀戮尖塔的核心架构基于LibGDX框架构建，采用面向对象的设计模式，通过模块化的方式组织游戏逻辑。本文档深入分析游戏的核心架构，包括主要类、系统初始化、游戏循环和状态管理。

## 核心类分析

### CardCrawlGame - 游戏主类

`CardCrawlGame`是游戏的主入口类，实现了LibGDX的`ApplicationListener`接口，负责整个游戏的生命周期管理。

#### 类结构
```java
public class CardCrawlGame implements ApplicationListener {
    // 游戏版本信息
    public static String VERSION_NUM = "[V2.3.4] (12-18-2022)";
    public static String TRUE_VERSION_NUM = "2022-12-18";
    
    // 渲染相关
    private OrthographicCamera camera;
    public static FitViewport viewport;
    public static PolygonSpriteBatch psb;
    private SpriteBatch sb;
    
    // 游戏状态
    public static AbstractDungeon dungeon;
    public static GameMode mode = GameMode.CHAR_SELECT;
    
    // 系统管理器
    public static MusicMaster music;
    public static SoundMaster sound;
    public static MetricData metricData;
    public static LocalizedStrings languagePack;
    
    // UI组件
    public static GameCursor cursor;
    public static SingleCardViewPopup cardPopup;
    public static SingleRelicViewPopup relicPopup;
}
```

#### 游戏模式枚举
```java
public enum GameMode {
    CHAR_SELECT,      // 角色选择
    GAMEPLAY,         // 游戏进行中
    DUNGEON_TRANSITION, // 地城转换
    SPLASH            // 启动画面
}
```

#### 初始化流程 (create方法)

1. **构建设置加载**
   ```java
   BuildSettings buildSettings = new BuildSettings(Gdx.files.internal("build.properties").reader());
   publisherIntegration = DistributorFactory.getEnabledDistributor(buildSettings.getDistributor());
   ```

2. **保存迁移**
   ```java
   saveMigration(); // 处理旧版本保存文件的迁移
   ```

3. **偏好设置初始化**
   ```java
   saveSlotPref = SaveHelper.getPrefs("STSSaveSlots");
   playerPref = SaveHelper.getPrefs("STSPlayer");
   ```

4. **设置系统初始化**
   ```java
   Settings.initialize(false);
   ```

5. **渲染系统设置**
   ```java
   this.camera = new OrthographicCamera(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
   viewport = new FitViewport(Settings.WIDTH, Settings.HEIGHT, this.camera);
   this.sb = new SpriteBatch();
   psb = new PolygonSpriteBatch();
   ```

6. **核心系统初始化**
   ```java
   // 按顺序初始化各个系统
   AbstractCreature.initialize();
   AbstractCard.initialize();
   GameDictionary.initialize();
   ImageMaster.initialize();
   AbstractPower.initialize();
   FontHelper.initialize();
   CardLibrary.initialize();
   RelicLibrary.initialize();
   // ... 更多系统初始化
   ```

#### 游戏主循环 (render方法)

```java
public void render() {
    try {
        TimeHelper.update();
        
        // 帧率限制
        if (Gdx.graphics.getRawDeltaTime() > 0.1F) {
            return;
        }
        
        update(); // 更新游戏逻辑
        
        // 渲染设置
        this.sb.setProjectionMatrix(this.camera.combined);
        psb.setProjectionMatrix(this.camera.combined);
        Gdx.gl.glClear(16384);
        this.sb.begin();
        this.sb.setColor(Color.WHITE);
        
        // 根据游戏模式渲染不同内容
        switch (mode) {
            case GAMEPLAY:
                if (dungeon != null) {
                    dungeon.render(this.sb);
                }
                break;
            case CHAR_SELECT:
                mainMenuScreen.render(this.sb);
                break;
            // ... 其他模式
        }
        
        // 渲染UI层
        DrawMaster.draw(this.sb);
        
        // 渲染弹窗
        if (cardPopup.isOpen) {
            cardPopup.render(this.sb);
        }
        if (relicPopup.isOpen) {
            relicPopup.render(this.sb);
        }
        
        TipHelper.render(this.sb);
        
        // 渲染黑屏淡入淡出
        if (mode != GameMode.SPLASH) {
            renderBlackFadeScreen(this.sb);
        }
        
        this.sb.end();
    } catch (Exception e) {
        ExceptionHandler.handleException(e, logger);
        Gdx.app.exit();
    }
}
```

#### 更新逻辑 (update方法)

```java
public void update() {
    cursor.update();
    screenShake.update(viewport);
    
    if (mode != GameMode.SPLASH) {
        updateFade();
    }
    
    music.update();
    sound.update();
    
    // 输入处理
    InputHelper.updateFirst();
    
    // 弹窗更新
    if (cardPopup.isOpen) {
        cardPopup.update();
    }
    if (relicPopup.isOpen) {
        relicPopup.update();
    }
    
    // 根据游戏模式更新
    switch (mode) {
        case GAMEPLAY:
            if (dungeonTransitionScreen != null) {
                dungeonTransitionScreen.update();
                if (dungeonTransitionScreen.isComplete) {
                    dungeonTransitionScreen = null;
                    // 进入地城
                    getDungeon(nextDungeon, AbstractDungeon.player);
                }
            } else if (dungeon != null) {
                dungeon.update();
            }
            break;
        case CHAR_SELECT:
            mainMenuScreen.update();
            if (mainMenuScreen.fadedOut) {
                // 准备进入游戏
                mode = GameMode.GAMEPLAY;
                dungeonTransitionScreen = new DungeonTransitionScreen("Exordium");
            }
            break;
    }
}
```

### AbstractDungeon - 地城管理核心

`AbstractDungeon`是游戏的核心管理类，负责地城生成、房间管理、游戏状态控制等。

#### 核心字段
```java
public abstract class AbstractDungeon {
    // 玩家和怪物
    public static AbstractPlayer player;
    public static MonsterGroup monsters;
    
    // 房间管理
    public static AbstractRoom currRoom;
    public static ArrayList<MapRoomNode> map;
    public static int mapRng;
    
    // 随机数生成器
    public static Random monsterRng;
    public static Random treasureRng;
    public static Random eventRng;
    public static Random cardRng;
    public static Random relicRng;
    public static Random potionRng;
    public static Random shuffleRng;
    public static Random miscRng;
    
    // 游戏状态
    public static int floorNum;
    public static int ascensionLevel;
    public static boolean isAscensionMode;
    
    // 屏幕管理
    public static CurrentScreen screen;
    public static boolean isFadingOut;
    
    // 动作管理
    public static GameActionManager actionManager;
    
    // 效果管理
    public static ArrayList<AbstractGameEffect> effectList;
    public static ArrayList<AbstractGameEffect> topLevelEffects;
}
```

#### 屏幕状态枚举
```java
public enum CurrentScreen {
    NONE,            // 无屏幕
    MASTER_DECK_VIEW, // 主牌组查看
    DISCARD_PILE_VIEW, // 弃牌堆查看
    EXHAUST_PILE_VIEW, // 消耗牌堆查看
    DRAW_PILE_VIEW,   // 抽牌堆查看
    MAP,             // 地图
    COMBAT_REWARD,   // 战斗奖励
    CHEST,           // 宝箱
    SHOP,            // 商店
    REST,            // 休息
    EVENT,           // 事件
    BOSS_REWARD,     // Boss奖励
    CARD_REWARD,     // 卡牌奖励
    GAME_OVER,       // 游戏结束
    VICTORY,         // 胜利
    SETTINGS,        // 设置
    ABSTRACT,        // 抽象屏幕
    INPUT,           // 输入
    UNLOCK,          // 解锁
    JOURNAL,         // 日志
    NEOW,            // Neow
    GRID,            // 网格
    SELECT,          // 选择
    TRANSITION,      // 转换
    STATS,           // 统计
    PURIFY,          // 净化
    TOP,             // 顶部
    TUTORIAL,        // 教程
    CUSTOM,          // 自定义
    METRICS          // 指标
}
```

### Settings - 配置管理

`Settings`类管理游戏的全局配置和设置。

#### 关键配置项
```java
public class Settings {
    // 显示设置
    public static int WIDTH = 1920;
    public static int HEIGHT = 1080;
    public static float scale = 1.0F;
    
    // 游戏模式
    public static boolean isDailyRun = false;
    public static boolean isTrial = false;
    public static boolean isEndless = false;
    public static boolean isAscensionMode = false;
    public static int ascensionLevel = 0;
    
    // 调试选项
    public static boolean isDebug = false;
    public static boolean isInfo = false;
    public static boolean isDev = false;
    
    // UI设置
    public static boolean hideRelics = false;
    public static boolean hideCards = false;
    public static boolean hideEndTurn = false;
    public static boolean hideCombatElements = false;
    
    // 种子系统
    public static Long seed = null;
    public static boolean seedSet = false;
    public static Long specialSeed = null;
}
```

## 系统交互关系

### 核心系统依赖图

```
CardCrawlGame (主控制器)
    ├── AbstractDungeon (地城管理)
    │   ├── GameActionManager (动作管理)
    │   ├── AbstractRoom (房间管理)
    │   ├── AbstractPlayer (玩家管理)
    │   └── MonsterGroup (怪物管理)
    ├── Settings (配置管理)
    ├── MusicMaster (音频管理)
    ├── SoundMaster (音效管理)
    ├── LocalizedStrings (本地化)
    └── MetricData (数据收集)
```

### 初始化顺序

1. **基础系统初始化**
   - Settings
   - 语言包
   - 输入系统

2. **游戏对象初始化**
   - AbstractCreature
   - AbstractCard
   - AbstractPower

3. **资源库初始化**
   - CardLibrary
   - RelicLibrary
   - ImageMaster

4. **UI系统初始化**
   - FontHelper
   - 游戏光标
   - 弹窗系统

5. **音频系统初始化**
   - MusicMaster
   - SoundMaster

## 关键流程分析

### 游戏启动流程

```
应用启动 → CardCrawlGame.create() → 系统初始化 → 进入主循环
```

1. **应用启动**: LibGDX调用`create()`方法
2. **系统初始化**: 按依赖顺序初始化各个系统
3. **进入主循环**: 开始`render()`循环

### 游戏模式转换流程

```
SPLASH → CHAR_SELECT → GAMEPLAY → DUNGEON_TRANSITION → GAMEPLAY
```

1. **SPLASH**: 显示启动画面
2. **CHAR_SELECT**: 角色选择界面
3. **GAMEPLAY**: 游戏进行中
4. **DUNGEON_TRANSITION**: 地城转换画面

### 地城生成流程

```
角色选择 → 创建地城实例 → 生成地图 → 初始化房间 → 进入第一房间
```

1. **角色选择**: 玩家选择角色
2. **创建地城**: 根据地城类型创建实例
3. **生成地图**: 使用算法生成房间布局
4. **初始化房间**: 设置房间内容和连接
5. **进入第一房间**: 开始游戏

## 设计模式分析

### 单例模式

多个核心类使用单例模式确保全局唯一性：
- `CardCrawlGame`: 游戏主类
- `Settings`: 配置管理
- `AbstractDungeon`: 地城管理

### 状态模式

游戏使用状态模式管理不同的游戏模式：
- `GameMode`枚举定义不同状态
- 每个状态有对应的更新和渲染逻辑

### 工厂模式

地城创建使用工厂模式：
```java
public AbstractDungeon getDungeon(String key, AbstractPlayer p) {
    switch (key) {
        case "Exordium":
            return new Exordium(p, emptyList);
        case "TheCity":
            return new TheCity(p, AbstractDungeon.specialOneTimeEventList);
        // ...
    }
}
```

### 观察者模式

游戏事件系统使用观察者模式：
- 各种钩子方法允许系统响应游戏事件
- 例如：遗物的`onPlayCard()`方法

## 性能考虑

### 渲染优化

1. **批量渲染**: 使用`SpriteBatch`减少绘制调用
2. **视口裁剪**: 只渲染可见区域
3. **对象池**: 重用游戏对象减少GC压力

### 内存管理

1. **资源释放**: 实现`Disposable`接口正确释放资源
2. **异步保存**: 使用独立线程处理保存操作
3. **垃圾回收**: 在适当时机手动触发GC

### 帧率控制

```java
if (Gdx.graphics.getRawDeltaTime() > 0.1F) {
    return; // 跳过过长的帧
}
```

## 错误处理

### 异常捕获

```java
try {
    // 游戏逻辑
} catch (Exception e) {
    logger.info("Exception occurred in CardCrawlGame render method!");
    ExceptionHandler.handleException(e, logger);
    Gdx.app.exit();
}
```

### 日志系统

使用Log4j进行日志记录：
- 不同级别的日志输出
- 异常堆栈跟踪
- 性能监控信息

## 总结

杀戮尖塔的核心架构采用了模块化设计，通过清晰的职责分离和依赖管理，实现了复杂的游戏逻辑。主要特点包括：

1. **模块化设计**: 各系统职责明确，便于维护和扩展
2. **状态管理**: 通过枚举和状态机管理游戏流程
3. **资源管理**: 统一的资源加载和释放机制
4. **性能优化**: 多种优化策略确保流畅运行
5. **错误处理**: 完善的异常处理和日志系统

这种架构设计为游戏的稳定运行和后续扩展提供了坚实的基础。