# 姿态系统深度解析

## 概述

杀戮尖塔的姿态系统是观者角色（Watcher）的核心机制，通过不同的姿态状态来改变角色的战斗风格和能力。该系统提供了灵活的状态切换机制，每个姿态都有独特的视觉效果、音效和游戏效果，为玩家提供了丰富的战术选择。

## 核心类分析

### AbstractStance 抽象基类

`AbstractStance` 是所有姿态的抽象基类，定义了姿态系统的核心接口和通用功能。

```java
public abstract class AbstractStance {
    private static final Logger logger = LogManager.getLogger(AbstractStance.class.getName());
    
    // 基本属性
    public String name;        // 姿态名称
    public String description; // 姿态描述
    public String ID;          // 姿态标识符
    
    // 提示系统
    protected ArrayList<PowerTip> tips = new ArrayList<>();
    
    // 视觉效果
    protected Color c = Color.WHITE.cpy(); // 姿态颜色
    protected static final int W = 512;     // 图像宽度
    protected Texture img = null;          // 姿态图像
    
    // 动画系统
    protected float particleTimer = 0.0F, particleTimer2 = 0.0F; // 粒子计时器
    protected float angle; // 旋转角度
}
```

#### 生命周期方法

```java
// 抽象方法 - 必须实现
public abstract void updateDescription();

// 生命周期钩子方法 - 可选择性重写
public void atStartOfTurn() {}      // 回合开始时触发
public void onEndOfTurn() {}        // 回合结束时触发
public void onEnterStance() {}      // 进入姿态时触发
public void onExitStance() {}       // 离开姿态时触发
public void onPlayCard(AbstractCard card) {} // 打出卡牌时触发
```

#### 伤害修改方法

```java
// 造成伤害修改（基础版本）
public float atDamageGive(float damage, DamageInfo.DamageType type) {
    return damage;
}

// 造成伤害修改（带卡牌信息）
public float atDamageGive(float damage, DamageInfo.DamageType type, AbstractCard card) {
    return atDamageGive(damage, type);
}

// 受到伤害修改
public float atDamageReceive(float damage, DamageInfo.DamageType damageType) {
    return damage;
}
```

#### 更新和渲染系统

```java
// 主更新方法
public void update() {
    updateAnimation();
}

// 动画更新方法
public void updateAnimation() {}

// 渲染方法
public void render(SpriteBatch sb) {
    if (this.img == null) {
        return;
    }
    
    sb.setColor(this.c);
    sb.setBlendFunction(770, 1); // 设置混合模式为加法混合
    
    // 在玩家位置渲染姿态图像
    sb.draw(this.img, 
        AbstractDungeon.player.drawX - 256.0F + AbstractDungeon.player.animX, 
        AbstractDungeon.player.drawY - 256.0F + AbstractDungeon.player.animY + AbstractDungeon.player.hb_h / 2.0F, 
        256.0F, 256.0F, 512.0F, 512.0F, 
        Settings.scale, Settings.scale, 
        -this.angle, 0, 0, 512, 512, false, false);
    
    sb.setBlendFunction(770, 771); // 恢复默认混合模式
}

// 停止音效
public void stopIdleSfx() {}
```

#### 姿态工厂方法

```java
public static AbstractStance getStanceFromName(String name) {
    if (name.equals("Calm"))
        return new CalmStance(); 
    if (name.equals("Wrath"))
        return new WrathStance(); 
    if (name.equals("Divinity"))
        return new DivinityStance(); 
    if (name.equals("Neutral")) {
        return new NeutralStance();
    }
    
    logger.info("[ERROR] Unknown stance: " + name + " called for in getStanceFromName()");
    return null;
}
```

## 具体姿态实现

### CalmStance（平静姿态）

平静姿态是观者的基础姿态之一，注重能量管理和防御。

```java
public class CalmStance extends AbstractStance {
    private static final StanceStrings stanceString = CardCrawlGame.languagePack.getStanceString("Calm");
    public static final String STANCE_ID = "Calm";
    private static long sfxId = -1L; // 音效ID
    
    public CalmStance() {
        this.ID = "Calm";
        this.name = stanceString.NAME;
        updateDescription();
    }
    
    @Override
    public void updateDescription() {
        this.description = stanceString.DESCRIPTION[0];
    }
    
    @Override
    public void updateAnimation() {
        if (!Settings.DISABLE_EFFECTS) {
            // 粒子效果生成
            this.particleTimer -= Gdx.graphics.getDeltaTime();
            if (this.particleTimer < 0.0F) {
                this.particleTimer = 0.04F; // 每0.04秒生成一个粒子
                AbstractDungeon.effectsQueue.add(new CalmParticleEffect());
            }
        }
        
        // 光环效果生成
        this.particleTimer2 -= Gdx.graphics.getDeltaTime();
        if (this.particleTimer2 < 0.0F) {
            this.particleTimer2 = MathUtils.random(0.45F, 0.55F); // 随机间隔
            AbstractDungeon.effectsQueue.add(new StanceAuraEffect("Calm"));
        }
    }
    
    @Override
    public void onEnterStance() {
        if (sfxId != -1L) {
            stopIdleSfx();
        }
        
        // 播放音效
        CardCrawlGame.sound.play("STANCE_ENTER_CALM");
        sfxId = CardCrawlGame.sound.playAndLoop("STANCE_LOOP_CALM");
        
        // 视觉效果
        AbstractDungeon.effectsQueue.add(new BorderFlashEffect(Color.SKY, true));
    }
    
    @Override
    public void onExitStance() {
        // 离开姿态时获得2点能量
        AbstractDungeon.actionManager.addToBottom(new GainEnergyAction(2));
        stopIdleSfx();
    }
    
    @Override
    public void stopIdleSfx() {
        if (sfxId != -1L) {
            CardCrawlGame.sound.stop("STANCE_LOOP_CALM", sfxId);
            sfxId = -1L;
        }
    }
}
```

### WrathStance（愤怒姿态）

愤怒姿态是攻击性姿态，提供伤害加成但也会增加受到的伤害。

```java
public class WrathStance extends AbstractStance {
    public static final String STANCE_ID = "Wrath";
    private static final StanceStrings stanceString = CardCrawlGame.languagePack.getStanceString("Wrath");
    private static long sfxId = -1L;
    
    public WrathStance() {
        this.ID = "Wrath";
        this.name = stanceString.NAME;
        updateDescription();
    }
    
    @Override
    public float atDamageGive(float damage, DamageInfo.DamageType type) {
        if (type == DamageInfo.DamageType.NORMAL) {
            return damage * 2.0F; // 造成伤害翻倍
        }
        return damage;
    }
    
    @Override
    public float atDamageReceive(float damage, DamageInfo.DamageType type) {
        if (type == DamageInfo.DamageType.NORMAL) {
            return damage * 2.0F; // 受到伤害也翻倍
        }
        return damage;
    }
    
    @Override
    public void updateAnimation() {
        if (!Settings.DISABLE_EFFECTS) {
            // 愤怒粒子效果
            this.particleTimer -= Gdx.graphics.getDeltaTime();
            if (this.particleTimer < 0.0F) {
                this.particleTimer = 0.05F;
                AbstractDungeon.effectsQueue.add(new WrathParticleEffect());
            }
        }
        
        // 愤怒光环效果
        this.particleTimer2 -= Gdx.graphics.getDeltaTime();
        if (this.particleTimer2 < 0.0F) {
            this.particleTimer2 = MathUtils.random(0.3F, 0.4F);
            AbstractDungeon.effectsQueue.add(new StanceAuraEffect("Wrath"));
        }
    }
    
    @Override
    public void updateDescription() {
        this.description = stanceString.DESCRIPTION[0];
    }
    
    @Override
    public void onEnterStance() {
        if (sfxId != -1L) {
            stopIdleSfx();
        }
        
        CardCrawlGame.sound.play("STANCE_ENTER_WRATH");
        sfxId = CardCrawlGame.sound.playAndLoop("STANCE_LOOP_WRATH");
        
        // 红色边框闪光效果
        AbstractDungeon.effectsQueue.add(new BorderFlashEffect(Color.SCARLET, true));
        AbstractDungeon.effectsQueue.add(new StanceChangeParticleGenerator(
            AbstractDungeon.player.hb.cX, AbstractDungeon.player.hb.cY, "Wrath"));
    }
    
    @Override
    public void onExitStance() {
        stopIdleSfx();
    }
    
    @Override
    public void stopIdleSfx() {
        if (sfxId != -1L) {
            CardCrawlGame.sound.stop("STANCE_LOOP_WRATH", sfxId);
            sfxId = -1L;
        }
    }
}
```

### DivinityStance（神性姿态）

神性姿态是强大的临时姿态，提供巨额伤害加成但只能持续一回合。

```java
public class DivinityStance extends AbstractStance {
    private static final StanceStrings stanceString = CardCrawlGame.languagePack.getStanceString("Divinity");
    public static final String STANCE_ID = "Divinity";
    private static long sfxId = -1L;
    
    public DivinityStance() {
        this.ID = "Divinity";
        this.name = stanceString.NAME;
        updateDescription();
    }
    
    @Override
    public void updateAnimation() {
        if (!Settings.DISABLE_EFFECTS) {
            // 神性粒子效果
            this.particleTimer -= Gdx.graphics.getDeltaTime();
            if (this.particleTimer < 0.0F) {
                this.particleTimer = 0.2F; // 较慢的粒子生成速度
                AbstractDungeon.effectsQueue.add(new DivinityParticleEffect());
            }
        }
        
        // 神性光环效果
        this.particleTimer2 -= Gdx.graphics.getDeltaTime();
        if (this.particleTimer2 < 0.0F) {
            this.particleTimer2 = MathUtils.random(0.45F, 0.55F);
            AbstractDungeon.effectsQueue.add(new StanceAuraEffect("Divinity"));
        }
    }
    
    @Override
    public void atStartOfTurn() {
        // 回合开始时自动切换到中性姿态
        AbstractDungeon.actionManager.addToBottom(new ChangeStanceAction("Neutral"));
    }
    
    @Override
    public float atDamageGive(float damage, DamageInfo.DamageType type) {
        if (type == DamageInfo.DamageType.NORMAL) {
            return damage * 3.0F; // 造成伤害三倍
        }
        return damage;
    }
    
    @Override
    public void updateDescription() {
        this.description = stanceString.DESCRIPTION[0];
    }
    
    @Override
    public void onEnterStance() {
        if (sfxId != -1L) {
            stopIdleSfx();
        }
        
        CardCrawlGame.sound.play("STANCE_ENTER_DIVINITY");
        sfxId = CardCrawlGame.sound.playAndLoop("STANCE_LOOP_DIVINITY");
        
        // 粉色边框闪光效果
        AbstractDungeon.effectsQueue.add(new BorderFlashEffect(Color.PINK, true));
        AbstractDungeon.effectsQueue.add(new StanceChangeParticleGenerator(
            AbstractDungeon.player.hb.cX, AbstractDungeon.player.hb.cY, "Divinity"));
        
        // 进入时获得3点能量
        AbstractDungeon.actionManager.addToBottom(new GainEnergyAction(3));
    }
    
    @Override
    public void onExitStance() {
        stopIdleSfx();
    }
    
    @Override
    public void stopIdleSfx() {
        if (sfxId != -1L) {
            CardCrawlGame.sound.stop("STANCE_LOOP_DIVINITY", sfxId);
            sfxId = -1L;
        }
    }
}
```

### NeutralStance（中性姿态）

中性姿态是默认姿态，没有特殊效果。

```java
public class NeutralStance extends AbstractStance {
    public static final String STANCE_ID = "Neutral";
    
    public NeutralStance() {
        this.ID = "Neutral";
        this.name = "中性";
        updateDescription();
    }
    
    @Override
    public void updateDescription() {
        this.description = "没有特殊效果。";
    }
}
```

## 姿态切换系统

### ChangeStanceAction 动作类

姿态切换通过 `ChangeStanceAction` 实现，这是一个游戏动作，负责处理姿态切换的逻辑。

```java
public class ChangeStanceAction extends AbstractGameAction {
    private String newStanceID;
    private boolean freeToPlay = false;
    
    public ChangeStanceAction(String newStanceID) {
        this.newStanceID = newStanceID;
        this.actionType = ActionType.SPECIAL;
    }
    
    @Override
    public void update() {
        if (this.duration == 0.0F) {
            // 获取当前姿态
            AbstractStance currentStance = AbstractDungeon.player.stance;
            
            // 如果当前姿态与新姿态相同，不执行切换
            if (currentStance != null && currentStance.ID.equals(newStanceID)) {
                this.isDone = true;
                return;
            }
            
            // 触发当前姿态的退出事件
            if (currentStance != null) {
                currentStance.onExitStance();
            }
            
            // 创建新姿态
            AbstractStance newStance = AbstractStance.getStanceFromName(newStanceID);
            if (newStance != null) {
                // 设置新姿态
                AbstractDungeon.player.stance = newStance;
                
                // 触发新姿态的进入事件
                newStance.onEnterStance();
            }
        }
        
        this.tickDuration();
    }
}
```

## 视觉效果系统

### 粒子效果系统

每个姿态都有独特的粒子效果，通过定时生成不同的粒子来营造氛围。

```java
// 粒子生成模式示例
protected void updateAnimation() {
    if (!Settings.DISABLE_EFFECTS) {
        // 主要粒子效果
        this.particleTimer -= Gdx.graphics.getDeltaTime();
        if (this.particleTimer < 0.0F) {
            this.particleTimer = PARTICLE_INTERVAL; // 每个姿态有不同的间隔
            AbstractDungeon.effectsQueue.add(new SpecificParticleEffect());
        }
    }
    
    // 光环效果
    this.particleTimer2 -= Gdx.graphics.getDeltaTime();
    if (this.particleTimer2 < 0.0F) {
        this.particleTimer2 = MathUtils.random(MIN_INTERVAL, MAX_INTERVAL);
        AbstractDungeon.effectsQueue.add(new StanceAuraEffect("StanceName"));
    }
}
```

### 边框闪光效果

姿态切换时会产生边框闪光效果，使用不同的颜色来区分姿态：

- **平静姿态** - 天空蓝 (Color.SKY)
- **愤怒姿态** - 鲜红色 (Color.SCARLET)
- **神性姿态** - 粉红色 (Color.PINK)

```java
AbstractDungeon.effectsQueue.add(new BorderFlashEffect(Color.SKY, true));
```

### 姿态图像渲染

姿态图像在玩家位置渲染，支持旋转和颜色混合：

```java
public void render(SpriteBatch sb) {
    if (this.img == null) {
        return;
    }
    
    sb.setColor(this.c);
    sb.setBlendFunction(770, 1); // 加法混合模式
    
    // 计算渲染位置
    float x = AbstractDungeon.player.drawX - 256.0F + AbstractDungeon.player.animX;
    float y = AbstractDungeon.player.drawY - 256.0F + AbstractDungeon.player.animY + 
              AbstractDungeon.player.hb_h / 2.0F;
    
    // 渲染姿态图像
    sb.draw(this.img, x, y, 256.0F, 256.0F, 512.0F, 512.0F, 
            Settings.scale, Settings.scale, -this.angle, 
            0, 0, 512, 512, false, false);
    
    sb.setBlendFunction(770, 771); // 恢复默认混合
}
```

## 音效系统

### 音效管理

每个姿态都有进入音效和循环音效，通过静态变量管理音效ID：

```java
private static long sfxId = -1L;

@Override
public void onEnterStance() {
    if (sfxId != -1L) {
        stopIdleSfx();
    }
    
    // 播放进入音效
    CardCrawlGame.sound.play("STANCE_ENTER_" + STANCE_ID);
    
    // 播放循环音效并保存ID
    sfxId = CardCrawlGame.sound.playAndLoop("STANCE_LOOP_" + STANCE_ID);
}

@Override
public void stopIdleSfx() {
    if (sfxId != -1L) {
        CardCrawlGame.sound.stop("STANCE_LOOP_" + STANCE_ID, sfxId);
        sfxId = -1L;
    }
}
```

## 游戏机制集成

### 伤害计算集成

姿态系统与伤害计算系统深度集成：

```java
// 在 AbstractCard 的 damage 方法中调用
public void calculateCardDamage(AbstractMonster mo) {
    // ... 其他伤害计算逻辑
    
    // 应用姿态伤害修正
    if (AbstractDungeon.player.stance != null) {
        float tmp = AbstractDungeon.player.stance.atDamageGive(
            this.damage, this.damageTypeForTurn, this);
        if (this.baseDamage != (int)tmp) {
            this.isDamageModified = true;
        }
        this.damage = (int)tmp;
    }
    
    // ... 其他伤害计算逻辑
}
```

### 能量系统集成

某些姿态与能量系统交互：

```java
// 平静姿态退出时获得能量
@Override
public void onExitStance() {
    AbstractDungeon.actionManager.addToBottom(new GainEnergyAction(2));
    stopIdleSfx();
}

// 神性姿态进入时获得能量
@Override
public void onEnterStance() {
    // ... 其他逻辑
    AbstractDungeon.actionManager.addToBottom(new GainEnergyAction(3));
}
```

## 本地化支持

### 姿态字符串

每个姿态都有对应的本地化字符串：

```java
private static final StanceStrings stanceString = 
    CardCrawlGame.languagePack.getStanceString("StanceID");

@Override
public void updateDescription() {
    this.description = stanceString.DESCRIPTION[0];
}
```

本地化文件结构示例：
```json
{
  "STANCE_NAME": "平静",
  "DESCRIPTION": [
    "离开这个姿态时，获得 #b2 点 #y能量 。"
  ]
}
```

## 性能优化

### 条件渲染

```java
// 只在启用特效时生成粒子
if (!Settings.DISABLE_EFFECTS) {
    // 粒子生成逻辑
}
```

### 音效资源管理

```java
// 确保只有一个循环音效在播放
if (sfxId != -1L) {
    stopIdleSfx();
}
sfxId = CardCrawlGame.sound.playAndLoop("STANCE_LOOP_" + STANCE_ID);
```

### 粒子生成频率控制

不同姿态使用不同的粒子生成频率来平衡视觉效果和性能：

- **平静姿态** - 0.04秒间隔（高频率）
- **愤怒姿态** - 0.05秒间隔（中高频率）
- **神性姿态** - 0.2秒间隔（低频率）

## 扩展性设计

### 新姿态添加

添加新姿态的步骤：

1. 创建继承 `AbstractStance` 的新类
2. 实现必要的方法
3. 在 `getStanceFromName` 中添加映射
4. 添加对应的本地化字符串
5. 创建相应的视觉效果和音效

### 模组支持

姿态系统设计为易于扩展：

```java
// 模组可以通过反射添加新姿态
public static void registerStance(String name, Class<? extends AbstractStance> stanceClass) {
    // 注册逻辑
}
```

## 总结

杀戮尖塔的姿态系统是一个精心设计的机制系统，具有以下特点：

1. **模块化设计** - 清晰的抽象基类和具体实现分离
2. **生命周期管理** - 完整的姿态进入、维持和退出流程
3. **视觉效果丰富** - 粒子效果、光环效果和边框闪光
4. **音效系统完善** - 进入音效和循环音效管理
5. **游戏机制深度集成** - 与伤害计算、能量系统等紧密结合
6. **性能优化** - 条件渲染和资源管理
7. **本地化支持** - 多语言字符串管理
8. **扩展性强** - 易于添加新姿态和模组支持

该系统通过不同的姿态状态为玩家提供了丰富的战术选择，每个姿态都有独特的玩法风格和视觉表现，是观者角色核心玩法的重要组成部分。