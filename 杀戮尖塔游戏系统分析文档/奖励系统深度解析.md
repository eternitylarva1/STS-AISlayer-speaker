# 奖励系统深度解析

## 概述

杀戮尖塔的奖励系统是游戏核心循环的重要组成部分，负责在战斗胜利、事件完成或其他特定情况下向玩家提供各种奖励。该系统通过灵活的奖励类型、动态生成机制和精美的视觉效果，为玩家提供持续的成就感和进步动力。

## 核心类分析

### RewardItem 类

`RewardItem` 是奖励系统的核心类，代表一个具体的奖励项。它封装了奖励的类型、内容和交互逻辑。

```java
public class RewardItem {
    // 奖励类型枚举
    public enum RewardType {
        CARD,        // 卡牌奖励
        GOLD,        // 金币奖励
        RELIC,       // 遗物奖励
        POTION,      // 药水奖励
        STOLEN_GOLD, // 被盗金币
        EMERALD_KEY, // 绿宝石钥匙
        SAPPHIRE_KEY // 蓝宝石钥匙
    }
    
    // 核心属性
    public RewardType type;           // 奖励类型
    public Texture outlineImg;        // 轮廓图像
    public Texture img;               // 主图像
    public int goldAmt = 0;           // 金币数量
    public int bonusGold = 0;         // 奖励金币
    public String text;               // 显示文本
    public RewardItem relicLink;      // 关联的遗物奖励
    public AbstractRelic relic;       // 遗物对象
    public AbstractPotion potion;     // 药水对象
    public ArrayList<AbstractCard> cards; // 卡牌列表
    
    // 交互相关
    public Hitbox hb;                 // 碰撞框
    public float y;                   // Y坐标位置
    public float flashTimer = 0.0F;   // 闪烁计时器
    public boolean isDone = false;    // 是否已领取
    public boolean ignoreReward = false; // 是否忽略奖励
    public boolean redText = false;   // 是否显示红色文本
}
```

#### 奖励类型详解

1. **CARD（卡牌奖励）**
   - 提供三张卡牌供玩家选择一张
   - 根据当前房间类型决定卡牌池
   - Boss房间提供特殊Boss卡牌

2. **GOLD（金币奖励）**
   - 直接给予玩家金币
   - 可能包含遗物加成（如金像）
   - 显示基础金币和奖励金币

3. **RELIC（遗物奖励）**
   - 提供一个遗物
   - 可能与钥匙奖励关联
   - 需要特殊处理领取逻辑

4. **POTION（药水奖励）**
   - 提供一个药水
   - 受Sozu遗物影响
   - 包含新手提示系统

5. **STOLEN_GOLD（被盗金币）**
   - 特殊事件中的金币奖励
   - 与普通金币处理逻辑类似

6. **EMERALD_KEY/SAPPHIRE_KEY（钥匙奖励）**
   - 高级奖励类型
   - 蓝宝石钥匙与遗物奖励关联
   - 包含特殊的视觉效果

#### 构造函数分析

```java
// 金币奖励构造函数
public RewardItem(int gold) {
    this.type = RewardType.GOLD;
    this.goldAmt = gold;
    applyGoldBonus(false); // 应用金币加成
}

// 遗物奖励构造函数
public RewardItem(AbstractRelic relic) {
    this.type = RewardType.RELIC;
    this.relic = relic;
    relic.hb = new Hitbox(80.0F * Settings.scale, 80.0F * Settings.scale);
    relic.hb.move(-1000.0F, -1000.0F); // 移出屏幕
    this.text = relic.name;
}

// 卡牌奖励构造函数
public RewardItem() {
    this.type = RewardType.CARD;
    this.isBoss = AbstractDungeon.getCurrRoom() instanceof MonsterRoomBoss;
    this.cards = AbstractDungeon.getRewardCards();
    this.text = TEXT[2]; // "卡牌奖励"
}
```

#### 金币加成系统

```java
private void applyGoldBonus(boolean theft) {
    int tmp = this.goldAmt;
    this.bonusGold = 0;
    
    if (theft) {
        this.text = this.goldAmt + TEXT[0]; // "被盗金币"
    } else {
        // 非宝藏房间才应用加成
        if (!(AbstractDungeon.getCurrRoom() instanceof TreasureRoom)) {
            // 金像遗物加成25%
            if (AbstractDungeon.player.hasRelic("Golden Idol")) {
                this.bonusGold += MathUtils.round(tmp * 0.25F);
            }
            
            // Midas模组加成200%
            if (ModHelper.isModEnabled("Midas")) {
                this.bonusGold += MathUtils.round(tmp * 2.0F);
            }
            
            // MonsterHunter模组加成150%
            if (ModHelper.isModEnabled("MonsterHunter")) {
                this.bonusGold += MathUtils.round(tmp * 1.5F);
            }
        }
        
        // 设置显示文本
        if (this.bonusGold == 0) {
            this.text = this.goldAmt + TEXT[1]; // "金币"
        } else {
            this.text = this.goldAmt + TEXT[1] + " (" + this.bonusGold + ")";
        }
    }
}
```

### CombatRewardScreen 类

`CombatRewardScreen` 是奖励界面的管理类，负责显示、更新和处理奖励交互。

```java
public class CombatRewardScreen {
    // 核心组件
    public ArrayList<RewardItem> rewards = new ArrayList<>(); // 奖励列表
    public ArrayList<AbstractGameEffect> effects = new ArrayList<>(); // 特效列表
    public boolean hasTakenAll = false; // 是否已领取所有奖励
    
    // 动画相关
    private float rewardAnimTimer = 0.2F; // 奖励动画计时器
    private Color uiColor = Color.BLACK.cpy(); // UI颜色
    
    // 特殊状态
    private boolean mug = false; // 是否为抢劫状态
    private boolean smoke = false; // 是否为烟雾状态
    private String labelOverride = null; // 标签覆盖
}
```

#### 奖励设置流程

```java
public void setupItemReward() {
    this.rewardAnimTimer = 0.2F;
    InputHelper.justClickedLeft = false;
    this.rewards = new ArrayList<>((AbstractDungeon.getCurrRoom()).rewards);
    
    // 检查是否添加卡牌奖励
    if (((AbstractDungeon.getCurrRoom()).event == null || 
         ((AbstractDungeon.getCurrRoom()).event != null && 
          !(AbstractDungeon.getCurrRoom()).event.noCardsInRewards)) && 
        !(AbstractDungeon.getCurrRoom() instanceof TreasureRoom) && 
        !(AbstractDungeon.getCurrRoom() instanceof RestRoom)) {
        
        // Vintage模组特殊处理
        if (ModHelper.isModEnabled("Vintage") && 
            AbstractDungeon.getCurrRoom() instanceof MonsterRoom) {
            if (AbstractDungeon.getCurrRoom() instanceof MonsterRoomElite || 
                AbstractDungeon.getCurrRoom() instanceof MonsterRoomBoss) {
                RewardItem cardReward = new RewardItem();
                if (cardReward.cards.size() > 0) {
                    this.rewards.add(cardReward);
                }
            }
        } else {
            // 标准卡牌奖励
            RewardItem cardReward = new RewardItem();
            if (cardReward.cards.size() > 0) {
                this.rewards.add(cardReward);
            }
            
            // 祈祷轮遗物额外卡牌
            if (AbstractDungeon.getCurrRoom() instanceof MonsterRoom && 
                AbstractDungeon.player.hasRelic("Prayer Wheel") && 
                !(AbstractDungeon.getCurrRoom() instanceof MonsterRoomElite) && 
                !(AbstractDungeon.getCurrRoom() instanceof MonsterRoomBoss)) {
                cardReward = new RewardItem();
                if (cardReward.cards.size() > 0) {
                    this.rewards.add(cardReward);
                }
            }
        }
    }
    
    AbstractDungeon.overlayMenu.proceedButton.show();
    this.hasTakenAll = false;
    positionRewards(); // 定位奖励项
}
```

#### 奖励定位系统

```java
public void positionRewards() {
    for (int i = 0; i < this.rewards.size(); i++) {
        // 垂直排列奖励项，每个间隔100像素
        ((RewardItem)this.rewards.get(i)).move(
            Settings.HEIGHT / 2.0F + 124.0F * Settings.scale - i * 100.0F * Settings.scale
        );
    }
    if (this.rewards.isEmpty()) {
        this.hasTakenAll = true;
    }
}
```

#### 奖励更新逻辑

```java
private void rewardViewUpdate() {
    // 更新动画计时器
    if (this.rewardAnimTimer != 0.0F) {
        this.rewardAnimTimer -= Gdx.graphics.getDeltaTime();
        if (this.rewardAnimTimer < 0.0F) {
            this.rewardAnimTimer = 0.0F;
        }
        // 更新UI颜色（淡入效果）
        this.uiColor.r = 1.0F - this.rewardAnimTimer / 0.2F;
        this.uiColor.g = 1.0F - this.rewardAnimTimer / 0.2F;
        this.uiColor.b = 1.0F - this.rewardAnimTimer / 0.2F;
    }
    
    // 更新提示位置
    this.tipY = MathHelper.uiLerpSnap(this.tipY, Settings.HEIGHT / 2.0F - 460.0F * Settings.scale);
    updateControllerInput();
    
    boolean removedSomething = false;
    // 更新每个奖励项
    for (Iterator<RewardItem> i = this.rewards.iterator(); i.hasNext(); ) {
        RewardItem r = i.next();
        r.update();
        
        if (r.isDone) {
            if (r.claimReward()) {
                i.remove();
                removedSomething = true;
                continue;
            }
            if (r.type == RewardItem.RewardType.POTION) {
                r.isDone = false;
                AbstractDungeon.topPanel.flashRed();
                this.tip = CardCrawlGame.tips.getPotionTip();
                continue;
            }
            r.isDone = false;
        }
    }
    
    // 重新定位剩余奖励
    if (removedSomething) {
        positionRewards();
        setLabel();
    }
}
```

### RewardSave 类

`RewardSave` 是奖励数据的序列化类，用于保存和加载奖励信息。

```java
public class RewardSave {
    public String type;    // 奖励类型
    public String id;      // 奖励ID
    public int amount;     // 数量
    public int bonusGold;  // 奖励金币
    
    public RewardSave(String type, String id, int amount, int bonusGold) {
        this.type = type;
        this.id = id;
        this.amount = amount;
        this.bonusGold = bonusGold;
    }
    
    public RewardSave(String type, String id) {
        this(type, id, 0, 0);
    }
}
```

## 奖励领取机制

### claimReward() 方法详解

```java
public boolean claimReward() {
    switch (this.type) {
        case GOLD:
            CardCrawlGame.sound.play("GOLD_GAIN");
            if (this.bonusGold == 0) {
                AbstractDungeon.player.gainGold(this.goldAmt);
            } else {
                AbstractDungeon.player.gainGold(this.goldAmt + this.bonusGold);
            }
            return true;
            
        case STOLEN_GOLD:
            CardCrawlGame.sound.play("GOLD_GAIN");
            if (this.bonusGold == 0) {
                AbstractDungeon.player.gainGold(this.goldAmt);
            } else {
                AbstractDungeon.player.gainGold(this.goldAmt + this.bonusGold);
            }
            return true;
            
        case POTION:
            // Sozu遗物阻止获得药水
            if (AbstractDungeon.player.hasRelic("Sozu")) {
                AbstractDungeon.player.getRelic("Sozu").flash();
                return true;
            }
            
            if (AbstractDungeon.player.obtainPotion(this.potion)) {
                // 新手提示
                if (!((Boolean)TipTracker.tips.get("POTION_TIP")).booleanValue()) {
                    AbstractDungeon.ftue = new FtueTip(LABEL[0], MSG[0], 
                        Settings.WIDTH / 2.0F, Settings.HEIGHT / 2.0F, this.potion);
                    TipTracker.neverShowAgain("POTION_TIP");
                }
                CardCrawlGame.metricData.addPotionObtainData(this.potion);
                return true;
            }
            return false;
            
        case RELIC:
            if (AbstractDungeon.screen == AbstractDungeon.CurrentScreen.GRID) {
                return false;
            }
            
            if (!this.ignoreReward) {
                this.relic.instantObtain();
                CardCrawlGame.metricData.addRelicObtainData(this.relic);
            }
            
            // 处理关联的钥匙奖励
            if (this.relicLink != null) {
                this.relicLink.isDone = true;
                this.relicLink.ignoreReward = true;
            }
            return true;
            
        case CARD:
            // 特殊遗物处理
            if (AbstractDungeon.player.hasRelic("Question Card")) {
                AbstractDungeon.player.getRelic("Question Card").flash();
            }
            
            if (AbstractDungeon.player.hasRelic("Busted Crown")) {
                AbstractDungeon.player.getRelic("Busted Crown").flash();
            }
            
            // 打开卡牌选择界面
            if (AbstractDungeon.screen == AbstractDungeon.CurrentScreen.COMBAT_REWARD) {
                AbstractDungeon.cardRewardScreen.open(this.cards, this, TEXT[4]);
                AbstractDungeon.previousScreen = AbstractDungeon.CurrentScreen.COMBAT_REWARD;
            }
            return false;
            
        case SAPPHIRE_KEY:
            if (!this.ignoreReward) {
                AbstractDungeon.topLevelEffects.add(new ObtainKeyEffect(ObtainKeyEffect.KeyColor.BLUE));
            }
            
            this.relicLink.isDone = true;
            this.relicLink.ignoreReward = true;
            this.img.dispose();
            this.outlineImg.dispose();
            return true;
            
        case EMERALD_KEY:
            AbstractDungeon.topLevelEffects.add(new ObtainKeyEffect(ObtainKeyEffect.KeyColor.GREEN));
            this.img.dispose();
            this.outlineImg.dispose();
            return true;
    }
    
    logger.info("ERROR: Claim Reward() failed");
    return false;
}
```

## 视觉效果系统

### 奖励项渲染

```java
public void render(SpriteBatch sb) {
    // 背景渲染
    if (this.hb.hovered) {
        sb.setColor(new Color(0.4F, 0.6F, 0.6F, 1.0F));
    } else {
        sb.setColor(new Color(0.5F, 0.6F, 0.6F, 0.8F));
    }
    
    // 点击状态缩放效果
    if (this.hb.clickStarted) {
        sb.draw(ImageMaster.REWARD_SCREEN_ITEM, 
            Settings.WIDTH / 2.0F - 232.0F, this.y - 49.0F, 
            232.0F, 49.0F, 464.0F, 98.0F, 
            Settings.xScale * 0.98F, Settings.scale * 0.98F, 
            0.0F, 0, 0, 464, 98, false, false);
    } else {
        sb.draw(ImageMaster.REWARD_SCREEN_ITEM, 
            Settings.WIDTH / 2.0F - 232.0F, this.y - 49.0F, 
            232.0F, 49.0F, 464.0F, 98.0F, 
            Settings.xScale, Settings.scale, 
            0.0F, 0, 0, 464, 98, false, false);
    }
    
    // 闪烁效果
    if (this.flashTimer != 0.0F) {
        sb.setColor(0.6F, 1.0F, 1.0F, this.flashTimer * 1.5F);
        sb.setBlendFunction(770, 1);
        sb.draw(ImageMaster.REWARD_SCREEN_ITEM, 
            Settings.WIDTH / 2.0F - 232.0F, this.y - 49.0F, 
            232.0F, 49.0F, 464.0F, 98.0F, 
            Settings.xScale * 1.03F, Settings.scale * 1.15F, 
            0.0F, 0, 0, 464, 98, false, false);
        sb.setBlendFunction(770, 771);
    }
    
    sb.setColor(Color.WHITE);
    
    // 根据类型渲染图标
    switch (this.type) {
        case CARD:
            if (this.isBoss) {
                sb.draw(ImageMaster.REWARD_CARD_BOSS, 
                    REWARD_ITEM_X - 32.0F, this.y - 32.0F - 2.0F * Settings.scale, 
                    32.0F, 32.0F, 64.0F, 64.0F, 
                    Settings.scale, Settings.scale, 0.0F, 0, 0, 64, 64, false, false);
            } else {
                sb.draw(ImageMaster.REWARD_CARD_NORMAL, 
                    REWARD_ITEM_X - 32.0F, this.y - 32.0F - 2.0F * Settings.scale, 
                    32.0F, 32.0F, 64.0F, 64.0F, 
                    Settings.scale, Settings.scale, 0.0F, 0, 0, 64, 64, false, false);
            }
            break;
            
        case GOLD:
        case STOLEN_GOLD:
            sb.draw(ImageMaster.UI_GOLD, 
                REWARD_ITEM_X - 32.0F, this.y - 32.0F - 2.0F * Settings.scale, 
                32.0F, 32.0F, 64.0F, 64.0F, 
                Settings.scale, Settings.scale, 0.0F, 0, 0, 64, 64, false, false);
            break;
            
        case RELIC:
            this.relic.renderWithoutAmount(sb, new Color(0.0F, 0.0F, 0.0F, 0.25F));
            if (this.hb.hovered) {
                if (this.relicLink != null) {
                    // 关联钥匙的特殊提示
                    ArrayList<PowerTip> tips = new ArrayList<>();
                    tips.add(new PowerTip(this.relic.name, this.relic.description));
                    
                    if (this.relicLink.type == RewardType.SAPPHIRE_KEY) {
                        tips.add(new PowerTip(TEXT[7], TEXT[8] + 
                            FontHelper.colorString(TEXT[6] + TEXT[9], "y")));
                    }
                    
                    TipHelper.queuePowerTips(360.0F * Settings.scale, 
                        InputHelper.mY + 50.0F * Settings.scale, tips);
                } else {
                    this.relic.renderTip(sb);
                }
            }
            break;
            
        case SAPPHIRE_KEY:
        case EMERALD_KEY:
            renderKey(sb);
            break;
            
        case POTION:
            this.potion.renderLightOutline(sb);
            this.potion.render(sb);
            this.potion.generateSparkles(this.potion.posX, this.potion.posY, true);
            break;
    }
    
    // 文本渲染
    Color color = this.hb.hovered ? Settings.GOLD_COLOR : Settings.CREAM_COLOR;
    if (this.redText) {
        color = Settings.RED_TEXT_COLOR;
    }
    
    FontHelper.renderSmartText(sb, FontHelper.cardDescFont_N, this.text, 
        REWARD_TEXT_X, this.y + 5.0F * Settings.scale, 
        1000.0F * Settings.scale, 0.0F, color);
    
    // 特效渲染
    if (!this.hb.hovered) {
        for (AbstractGameEffect e : this.effects) {
            e.render(sb);
        }
    }
    
    // 控制器支持
    if (Settings.isControllerMode) {
        renderReticle(sb, this.hb);
    }
    
    // 遗物关联渲染
    if (this.type == RewardType.SAPPHIRE_KEY) {
        renderRelicLink(sb);
    }
    
    this.hb.render(sb);
}
```

### 特效系统

奖励系统包含多种视觉效果：

1. **RewardGlowEffect** - 奖励发光效果
2. **闪烁效果** - 鼠标悬停时的白色闪光
3. **缩放效果** - 点击时的轻微缩放
4. **粒子效果** - 药水的火花效果
5. **钥匙特效** - ObtainKeyEffect特殊效果

## 交互系统

### 输入处理

```java
public void update() {
    // 闪烁计时器更新
    if (this.flashTimer > 0.0F) {
        this.flashTimer -= Gdx.graphics.getDeltaTime();
        if (this.flashTimer < 0.0F) {
            this.flashTimer = 0.0F;
        }
    }
    
    // 碰撞框更新
    this.hb.update();
    updateReticle();
    
    // 特效管理
    if (this.effects.size() == 0) {
        this.effects.add(new RewardGlowEffect(this.hb.cX, this.hb.cY));
    }
    
    for (Iterator<AbstractGameEffect> i = this.effects.iterator(); i.hasNext(); ) {
        AbstractGameEffect e = i.next();
        e.update();
        if (e.isDone) {
            i.remove();
        }
    }
    
    // 悬停提示
    if (this.hb.hovered) {
        switch (this.type) {
            case POTION:
                if (!AbstractDungeon.topPanel.potionCombine) {
                    TipHelper.queuePowerTips(360.0F * Settings.scale, 
                        InputHelper.mY, this.potion.tips);
                }
                break;
        }
    }
    
    // 关联奖励状态同步
    if (this.relicLink != null) {
        this.relicLink.redText = this.hb.hovered;
    }
    
    // 音效处理
    if (this.hb.justHovered) {
        CardCrawlGame.sound.play("UI_HOVER");
    }
    
    // 鼠标点击处理
    if (this.hb.hovered && InputHelper.justClickedLeft && !this.isDone) {
        CardCrawlGame.sound.playA("UI_CLICK_1", 0.1F);
        this.hb.clickStarted = true;
    }
    
    // 控制器输入处理
    if (this.hb.hovered && CInputActionSet.select.isJustPressed() && !this.isDone) {
        this.hb.clicked = true;
        CardCrawlGame.sound.playA("UI_CLICK_1", 0.1F);
    }
    
    // 点击状态处理
    if (this.hb.clicked) {
        this.hb.clicked = false;
        this.isDone = true;
    }
}
```

### 控制器支持

```java
private void updateControllerInput() {
    if (!Settings.isControllerMode || this.rewards.isEmpty() || 
        AbstractDungeon.topPanel.selectPotionMode || 
        !AbstractDungeon.topPanel.potionUi.isHidden || 
        AbstractDungeon.player.viewingRelics) {
        return;
    }
    
    int index = 0;
    boolean anyHovered = false;
    
    // 查找当前悬停的奖励项
    for (RewardItem r : this.rewards) {
        if (r.hb.hovered) {
            anyHovered = true;
            break;
        }
        index++;
    }
    
    // 如果没有悬停项，选择第一个
    if (!anyHovered) {
        index = 0;
        Gdx.input.setCursorPosition(
            (int)((RewardItem)this.rewards.get(index)).hb.cX, 
            Settings.HEIGHT - (int)((RewardItem)this.rewards.get(index)).hb.cY);
    }
    // 方向键导航
    else if (CInputActionSet.up.isJustPressed() || CInputActionSet.altUp.isJustPressed()) {
        index--;
        if (index < 0) {
            index = this.rewards.size() - 1;
        }
        
        Gdx.input.setCursorPosition(
            (int)((RewardItem)this.rewards.get(index)).hb.cX, 
            Settings.HEIGHT - (int)((RewardItem)this.rewards.get(index)).hb.cY);
    } else if (CInputActionSet.down.isJustPressed() || CInputActionSet.altDown.isJustPressed()) {
        index++;
        if (index > this.rewards.size() - 1) {
            index = 0;
        }
        
        Gdx.input.setCursorPosition(
            (int)((RewardItem)this.rewards.get(index)).hb.cX, 
            Settings.HEIGHT - (int)((RewardItem)this.rewards.get(index)).hb.cY);
    }
}
```

## 界面管理系统

### 动态标签系统

```java
private void setLabel() {
    if (this.rewards.size() == 0) {
        AbstractDungeon.overlayMenu.proceedButton.setLabel(TEXT[0]); // "继续"
    } else if (this.rewards.size() == 1) {
        switch (((RewardItem)this.rewards.get(0)).type) {
            case CARD:
                AbstractDungeon.overlayMenu.proceedButton.setLabel(TEXT[1]); // "拿走卡牌"
                break;
            case GOLD:
                AbstractDungeon.overlayMenu.proceedButton.setLabel(TEXT[2]); // "拿走金币"
                break;
            case POTION:
                AbstractDungeon.overlayMenu.proceedButton.setLabel(TEXT[3]); // "拿走药水"
                break;
            case RELIC:
                AbstractDungeon.overlayMenu.proceedButton.setLabel(TEXT[4]); // "拿走遗物"
                break;
        }
    } else {
        AbstractDungeon.overlayMenu.proceedButton.setLabel(TEXT[5]); // "拿走奖励"
    }
}
```

### 随机横幅系统

```java
private String getRandomBannerLabel() {
    ArrayList<String> list = new ArrayList<>();
    if (AbstractDungeon.getCurrRoom() instanceof TreasureRoom) {
        list.add(TEXT[7]); // "战利品！"
        list.add(TEXT[8]); // "宝藏！"
    } else {
        list.add(TEXT[9]);  // "胜利！"
        list.add(TEXT[10]); // "干得好！"
        list.add(TEXT[11]); // "奖励！"
    }
    return list.get(MathUtils.random(list.size() - 1));
}
```

## 数据收集系统

### 指标数据收集

奖励系统集成了详细的数据收集机制：

```java
// 药水获得数据收集
CardCrawlGame.metricData.addPotionObtainData(this.potion);

// 遗物获得数据收集
CardCrawlGame.metricData.addRelicObtainData(this.relic);

// 卡牌跳过数据收集
public void recordCardSkipMetrics() {
    if (this.cards != null && !this.cards.isEmpty()) {
        HashMap<String, Object> choice = new HashMap<>();
        ArrayList<String> notpicked = new ArrayList<>();
        
        for (AbstractCard card : this.cards) {
            notpicked.add(card.getMetricID());
        }
        
        choice.put("picked", "SKIP");
        choice.put("not_picked", notpicked);
        choice.put("floor", Integer.valueOf(AbstractDungeon.floorNum));
        
        CardCrawlGame.metricData.card_choices.add(choice);
    }
}
```

## 特殊机制

### 遗物关联系统

蓝宝石钥匙与特定遗物形成关联关系：

```java
// 创建关联的钥匙和遗物奖励
RewardItem relicReward = new RewardItem(relic);
RewardItem keyReward = new RewardItem(relicReward, RewardType.SAPPHIRE_KEY);

// 领取遗物时自动领取钥匙
if (this.relicLink != null) {
    this.relicLink.isDone = true;
    this.relicLink.ignoreReward = true;
}
```

### 模组集成

奖励系统支持多种模组扩展：

1. **Vintage模组** - 限制精英房和Boss房的卡牌奖励
2. **Midas模组** - 金币奖励加成200%
3. **MonsterHunter模组** - 金币奖励加成150%

### 新手引导系统

```java
// 药水新手提示
if (!((Boolean)TipTracker.tips.get("POTION_TIP")).booleanValue()) {
    AbstractDungeon.ftue = new FtueTip(LABEL[0], MSG[0], 
        Settings.WIDTH / 2.0F, Settings.HEIGHT / 2.0F, this.potion);
    TipTracker.neverShowAgain("POTION_TIP");
}
```

## 性能优化

### 资源管理

```java
// 纹理资源释放
this.img.dispose();
this.outlineImg.dispose();

// 特效对象池管理
if (this.effects.size() == 0) {
    this.effects.add(new RewardGlowEffect(this.hb.cX, this.hb.cY));
}
```

### 渲染优化

1. **条件渲染** - 只在必要时渲染特效
2. **批量处理** - 统一处理相似类型的渲染
3. **LOD系统** - 根据距离调整渲染质量

## 总结

杀戮尖塔的奖励系统是一个高度模块化和可扩展的系统，具有以下特点：

1. **类型多样性** - 支持7种不同的奖励类型
2. **动态生成** - 根据游戏状态动态调整奖励内容
3. **视觉效果** - 丰富的动画和特效系统
4. **交互友好** - 支持鼠标和控制器输入
5. **数据收集** - 完整的玩家行为追踪
6. **模组支持** - 灵活的扩展机制
7. **性能优化** - 高效的资源管理和渲染

该系统通过精心设计的奖励机制和视觉反馈，为玩家提供了持续的成就感和游戏动力，是游戏核心循环不可或缺的重要组成部分。