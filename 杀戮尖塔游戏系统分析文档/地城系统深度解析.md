# 地城系统深度解析

## 概述

地城系统是《杀戮尖塔》的核心框架，负责管理整个游戏的流程、状态和资源。AbstractDungeon类是整个地城系统的核心，它协调所有其他系统，管理游戏进程，并处理玩家在地城中的冒险。

## 核心架构

### AbstractDungeon类结构

AbstractDungeon是一个抽象类，作为所有具体地城实现的基础。它管理着整个游戏的核心状态和系统。

```java
public abstract class AbstractDungeon {
    // 基本地城信息
    public static String name;
    public static String levelNum;
    public static String id;
    public static int floorNum = 0;
    public static int actNum = 0;
    public static AbstractPlayer player;
    
    // 随机数生成器
    public static Random monsterRng;
    public static Random mapRng;
    public static Random eventRng;
    public static Random merchantRng;
    public static Random cardRng;
    public static Random treasureRng;
    public static Random relicRng;
    public static Random potionRng;
    public static Random monsterHpRng;
    public static Random aiRng;
    public static Random shuffleRng;
    public static Random cardRandomRng;
    public static Random miscRng;
    
    // 卡牌池
    public static CardGroup srcColorlessCardPool;
    public static CardGroup srcCurseCardPool;
    public static CardGroup srcCommonCardPool;
    public static CardGroup srcUncommonCardPool;
    public static CardGroup srcRareCardPool;
    public static CardGroup colorlessCardPool;
    public static CardGroup curseCardPool;
    public static CardGroup commonCardPool;
    public static CardGroup uncommonCardPool;
    public static CardGroup rareCardPool;
    
    // 遗物池
    public static ArrayList<String> commonRelicPool;
    public static ArrayList<String> uncommonRelicPool;
    public static ArrayList<String> rareRelicPool;
    public static ArrayList<String> shopRelicPool;
    public static ArrayList<String> bossRelicPool;
    
    // 怪物列表
    public static ArrayList<String> monsterList;
    public static ArrayList<String> eliteMonsterList;
    public static ArrayList<String> bossList;
    
    // 事件列表
    public static ArrayList<String> eventList;
    public static ArrayList<String> shrineList;
    public static ArrayList<String> specialOneTimeEventList;
    
    // 地图系统
    public static MapRoomNode currMapNode;
    public static ArrayList<ArrayList<MapRoomNode>> map;
    public static ArrayList<Integer> pathX;
    public static ArrayList<Integer> pathY;
    
    // 游戏管理器
    public static GameActionManager actionManager;
    
    // 屏幕管理
    public static CurrentScreen screen;
    public static CurrentScreen previousScreen;
    public static boolean isScreenUp = false;
    
    // 视觉效果
    public static ArrayList<AbstractGameEffect> topLevelEffects;
    public static ArrayList<AbstractGameEffect> effectList;
    public static ArrayList<AbstractGameEffect> effectsQueue;
    
    // 场景管理
    public static AbstractScene scene;
    public static RenderScene rs = RenderScene.NORMAL;
    
    // 地图系统
    public static MapRoomNode currMapNode;
    public static ArrayList<ArrayList<MapRoomNode>> map;
    public static ArrayList<Integer> pathX = new ArrayList<>();
    public static ArrayList<Integer> pathY = new ArrayList<>();
    
    // 屏幕管理
    public static TopPanel topPanel;
    public static CardRewardScreen cardRewardScreen;
    public static CombatRewardScreen combatRewardScreen;
    public static BossRelicSelectScreen bossRelicScreen;
    public static MasterDeckViewScreen deckViewScreen;
    // ... 更多屏幕对象
}
```

### 地城初始化流程

地城的初始化是一个复杂的过程，涉及多个系统的协调：

```java
public AbstractDungeon(String name, String levelId, AbstractPlayer p, ArrayList<String> newSpecialOneTimeEventList) {
    ascensionCheck = UnlockTracker.isAscensionUnlocked(p);
    CardCrawlGame.dungeon = this;
    long startTime = System.currentTimeMillis();
    
    // 基本设置
    AbstractDungeon.name = name;
    id = levelId;
    player = p;
    topPanel.setPlayerName();
    actionManager = new GameActionManager();
    overlayMenu = new OverlayMenu(p);
    dynamicBanner = new DynamicBanner();
    unlocks.clear();
    
    specialOneTimeEventList = newSpecialOneTimeEventList;
    
    // 状态初始化
    isFadingIn = false;
    isFadingOut = false;
    waitingOnFadeOut = false;
    fadeTimer = 1.0F;
    isDungeonBeaten = false;
    isScreenUp = false;
    
    // 核心系统初始化
    dungeonTransitionSetup();
    generateMonsters();
    initializeBoss();
    setBoss(bossList.get(0));
    initializeEventList();
    initializeEventImg();
    initializeShrineList();
    initializeCardPools();
    
    // 玩家初始化
    if (floorNum == 0) {
        p.initializeStarterDeck();
    }
    initializePotions();
    BlightHelper.initialize();
    
    // 屏幕设置
    if (id.equals("Exordium")) {
        screen = CurrentScreen.NONE;
        isScreenUp = false;
    } else {
        screen = CurrentScreen.MAP;
        isScreenUp = true;
    }
    
    logger.info("Content generation time: " + (System.currentTimeMillis() - startTime) + "ms");
}
```

## 地图生成系统

### 地图生成算法

地图生成是地城系统的核心功能之一，使用MapGenerator类创建地城布局：

```java
protected static void generateMap() {
    long startTime = System.currentTimeMillis();
    
    // 地图参数
    int mapHeight = 15;
    int mapWidth = 7;
    int mapPathDensity = 6;
    
    ArrayList<AbstractRoom> roomList = new ArrayList<>();
    map = MapGenerator.generateDungeon(mapHeight, mapWidth, mapPathDensity, mapRng);
    
    // 计算可用房间数量
    int count = 0;
    for (ArrayList<MapRoomNode> a : map) {
        for (MapRoomNode n : a) {
            if (!n.hasEdges() || n.y == map.size() - 2) {
                continue;
            }
            count++;
        }
    }
    
    // 生成房间类型
    generateRoomTypes(roomList, count);
    
    // 设置特殊行
    RoomTypeAssigner.assignRowAsRoomType(map.get(map.size() - 1), RestRoom.class);
    RoomTypeAssigner.assignRowAsRoomType(map.get(0), MonsterRoom.class);
    if (Settings.isEndless && player.hasBlight("MimicInfestation")) {
        RoomTypeAssigner.assignRowAsRoomType(map.get(8), MonsterRoomElite.class);
    } else {
        RoomTypeAssigner.assignRowAsRoomType(map.get(8), TreasureRoom.class);
    }
    
    // 分配房间到地图
    map = RoomTypeAssigner.distributeRoomsAcrossMap(mapRng, map, roomList);
    
    // 设置翡翠钥匙精英房
    setEmeraldElite();
    
    logger.info("Generated the following dungeon map:");
    logger.info(MapGenerator.toString(map, Boolean.valueOf(true)));
    logger.info("Game Seed: " + Settings.seed);
    logger.info("Map generation time: " + (System.currentTimeMillis() - startTime) + "ms");
    firstRoomChosen = false;
    
    fadeIn();
}
```

### 房间类型生成

房间类型的生成基于概率分布，受多种因素影响：

```java
private static void generateRoomTypes(ArrayList<AbstractRoom> roomList, int availableRoomCount) {
    int eliteCount;
    logger.info("Generating Room Types! There are " + availableRoomCount + " rooms:");
    
    // 计算各类型房间数量
    int shopCount = Math.round(availableRoomCount * shopRoomChance);
    logger.info(" SHOP (" + toPercentage(shopRoomChance) + "): " + shopCount);
    
    int restCount = Math.round(availableRoomCount * restRoomChance);
    logger.info(" REST (" + toPercentage(restRoomChance) + "): " + restCount);
    
    int treasureCount = Math.round(availableRoomCount * treasureRoomChance);
    logger.info(" TRSRE (" + toPercentage(treasureRoomChance) + "): " + treasureCount);
    
    // 精英房间数量受模组和 ascension 影响
    if (ModHelper.isModEnabled("Elite Swarm")) {
        eliteCount = Math.round(availableRoomCount * eliteRoomChance * 2.5F);
        logger.info(" ELITE (" + toPercentage(eliteRoomChance) + "): " + eliteCount);
    } else if (ascensionLevel >= 1) {
        eliteCount = Math.round(availableRoomCount * eliteRoomChance * 1.6F);
        logger.info(" ELITE (" + toPercentage(eliteRoomChance) + "): " + eliteCount);
    } else {
        eliteCount = Math.round(availableRoomCount * eliteRoomChance);
        logger.info(" ELITE (" + toPercentage(eliteRoomChance) + "): " + eliteCount);
    }
    
    int eventCount = Math.round(availableRoomCount * eventRoomChance);
    logger.info(" EVNT (" + toPercentage(eventRoomChance) + "): " + eventCount);
    
    // 计算怪物房间数量
    int monsterCount = availableRoomCount - shopCount - restCount - treasureCount - eliteCount - eventCount;
    logger.info(" MSTR (" + 
        toPercentage(1.0F - shopRoomChance - restRoomChance - treasureRoomChance - eliteRoomChance - eventRoomChance) + 
        "): " + monsterCount);
    
    // 创建房间实例
    for (int i = 0; i < shopCount; i++) {
        roomList.add(new ShopRoom());
    }
    for (int i = 0; i < restCount; i++) {
        roomList.add(new RestRoom());
    }
    for (int i = 0; i < eliteCount; i++) {
        roomList.add(new MonsterRoomElite());
    }
    for (int i = 0; i < eventCount; i++) {
        roomList.add(new EventRoom());
    }
}
```

## 随机数管理系统

### 种子生成与加载

地城使用多个独立的随机数生成器，确保不同系统的随机性：

```java
public static void generateSeeds() {
    logger.info("Generating seeds: " + Settings.seed);
    monsterRng = new Random(Settings.seed);
    eventRng = new Random(Settings.seed);
    merchantRng = new Random(Settings.seed);
    cardRng = new Random(Settings.seed);
    treasureRng = new Random(Settings.seed);
    relicRng = new Random(Settings.seed);
    monsterHpRng = new Random(Settings.seed);
    potionRng = new Random(Settings.seed);
    aiRng = new Random(Settings.seed);
    shuffleRng = new Random(Settings.seed);
    cardRandomRng = new Random(Settings.seed);
    miscRng = new Random(Settings.seed);
}

public static void loadSeeds(SaveFile save) {
    // 处理每日挑战和试炼模式
    if (save.is_daily || save.is_trial) {
        Settings.isDailyRun = save.is_daily;
        Settings.isTrial = save.is_trial;
        Settings.specialSeed = Long.valueOf(save.special_seed);
        if (save.is_daily) {
            ModHelper.setTodaysMods(save.special_seed, player.chosenClass);
        } else {
            ModHelper.setTodaysMods(save.seed, player.chosenClass);
        }
    }
    
    // 加载各系统的随机数状态
    monsterRng = new Random(Settings.seed, save.monster_seed_count);
    eventRng = new Random(Settings.seed, save.event_seed_count);
    merchantRng = new Random(Settings.seed, save.merchant_seed_count);
    cardRng = new Random(Settings.seed, save.card_seed_count);
    cardBlizzRandomizer = save.card_random_seed_randomizer;
    treasureRng = new Random(Settings.seed, save.treasure_seed_count);
    relicRng = new Random(Settings.seed, save.relic_seed_count);
    potionRng = new Random(Settings.seed, save.potion_seed_count);
    
    logger.info("Loading seeds: " + Settings.seed);
    logger.info("Monster seed:  " + monsterRng.counter);
    logger.info("Event seed:    " + eventRng.counter);
    logger.info("Merchant seed: " + merchantRng.counter);
    logger.info("Card seed:     " + cardRng.counter);
    logger.info("Treasure seed: " + treasureRng.counter);
    logger.info("Relic seed:    " + relicRng.counter);
    logger.info("Potion seed:   " + potionRng.counter);
}
```

## 卡牌池管理系统

### 卡牌池初始化

卡牌池是地城系统的核心资源管理部分：

```java
public void initializeCardPools() {
    logger.info("INIT CARD POOL");
    long startTime = System.currentTimeMillis();
    
    // 清空现有卡牌池
    commonCardPool.clear();
    uncommonCardPool.clear();
    rareCardPool.clear();
    colorlessCardPool.clear();
    curseCardPool.clear();
    
    // 创建临时卡牌池
    ArrayList<AbstractCard> tmpPool = new ArrayList<>();
    
    // 根据模组添加卡牌
    if (ModHelper.isModEnabled("Colorless Cards")) {
        CardLibrary.addColorlessCards(tmpPool);
    }
    if (ModHelper.isModEnabled("Diverse")) {
        CardLibrary.addRedCards(tmpPool);
        CardLibrary.addGreenCards(tmpPool);
        CardLibrary.addBlueCards(tmpPool);
        if (!UnlockTracker.isCharacterLocked("Watcher")) {
            CardLibrary.addPurpleCards(tmpPool);
        }
    } else {
        player.getCardPool(tmpPool);
    }
    
    // 添加无色和诅咒卡牌
    addColorlessCards();
    addCurseCards();
    
    // 按稀有度分类卡牌
    for (AbstractCard c : tmpPool) {
        switch (c.rarity) {
            case COMMON:
                commonCardPool.addToTop(c);
                continue;
            case UNCOMMON:
                uncommonCardPool.addToTop(c);
                continue;
            case RARE:
                rareCardPool.addToTop(c);
                continue;
            case CURSE:
                curseCardPool.addToTop(c);
                continue;
        }
        logger.info("Unspecified rarity: " + c.rarity.name() + " when creating pools! AbstractDungeon: Line 827");
    }
    
    // 创建源卡牌池副本
    srcColorlessCardPool = new CardGroup(CardGroup.CardGroupType.CARD_POOL);
    srcCurseCardPool = new CardGroup(CardGroup.CardGroupType.CARD_POOL);
    srcRareCardPool = new CardGroup(CardGroup.CardGroupType.CARD_POOL);
    srcUncommonCardPool = new CardGroup(CardGroup.CardGroupType.CARD_POOL);
    srcCommonCardPool = new CardGroup(CardGroup.CardGroupType.CARD_POOL);
    
    // 复制卡牌到源池
    for (AbstractCard c : colorlessCardPool.group) {
        srcColorlessCardPool.addToBottom(c);
    }
    for (AbstractCard c : curseCardPool.group) {
        srcCurseCardPool.addToBottom(c);
    }
    for (AbstractCard c : rareCardPool.group) {
        srcRareCardPool.addToBottom(c);
    }
    for (AbstractCard c : uncommonCardPool.group) {
        srcUncommonCardPool.addToBottom(c);
    }
    for (AbstractCard c : commonCardPool.group) {
        srcCommonCardPool.addToBottom(c);
    }
    
    logger.info("Cardpool load time: " + (System.currentTimeMillis() - startTime) + "ms");
}
```

### 卡牌稀有度计算

卡牌稀有度的计算考虑了多种因素：

```java
public static AbstractCard.CardRarity rollRarity(Random rng) {
    int roll = cardRng.random(99);
    roll += cardBlizzRandomizer;
    
    if (currMapNode == null) {
        return getCardRarityFallback(roll);
    }
    return getCurrRoom().getCardRarity(roll);
}

private static AbstractCard.CardRarity getCardRarityFallback(int roll) {
    int rareRate = 3;
    if (roll < rareRate)
        return AbstractCard.CardRarity.RARE;
    if (roll < 40) {
        return AbstractCard.CardRarity.UNCOMMON;
    }
    return AbstractCard.CardRarity.COMMON;
}
```

## 遗物池管理系统

### 遗物池初始化

遗物池的管理与卡牌池类似，但考虑了更多因素：

```java
protected void initializeRelicList() {
    // 清空现有遗物池
    commonRelicPool.clear();
    uncommonRelicPool.clear();
    rareRelicPool.clear();
    shopRelicPool.clear();
    bossRelicPool.clear();
    
    // 填充遗物池
    RelicLibrary.populateRelicPool(commonRelicPool, AbstractRelic.RelicTier.COMMON, player.chosenClass);
    RelicLibrary.populateRelicPool(uncommonRelicPool, AbstractRelic.RelicTier.UNCOMMON, player.chosenClass);
    RelicLibrary.populateRelicPool(rareRelicPool, AbstractRelic.RelicTier.RARE, player.chosenClass);
    RelicLibrary.populateRelicPool(shopRelicPool, AbstractRelic.RelicTier.SHOP, player.chosenClass);
    RelicLibrary.populateRelicPool(bossRelicPool, AbstractRelic.RelicTier.BOSS, player.chosenClass);
    
    // 移除已获得的遗物
    if (floorNum >= 1) {
        for (AbstractRelic r : player.relics) {
            relicsToRemoveOnStart.add(r.relicId);
        }
    }
    
    // 随机打乱遗物池
    Collections.shuffle(commonRelicPool, new Random(relicRng.randomLong()));
    Collections.shuffle(uncommonRelicPool, new Random(relicRng.randomLong()));
    Collections.shuffle(rareRelicPool, new Random(relicRng.randomLong()));
    Collections.shuffle(shopRelicPool, new Random(relicRng.randomLong()));
    Collections.shuffle(bossRelicPool, new Random(relicRng.randomLong()));
    
    // 根据模组移除特定遗物
    if (ModHelper.isModEnabled("Flight") || ModHelper.isModEnabled("Uncertain Future")) {
        relicsToRemoveOnStart.add("WingedGreaves");
    }
    if (ModHelper.isModEnabled("Diverse")) {
        relicsToRemoveOnStart.add("PrismaticShard");
    }
    // ... 更多模组检查
    
    // 从池中移除指定遗物
    for (String remove : relicsToRemoveOnStart) {
        // 从各个池中移除遗物的逻辑
    }
}
```

## 房间转换系统

### 房间转换流程

房间之间的转换是地城探索的核心机制：

```java
public void nextRoomTransition(SaveFile saveFile) {
    overlayMenu.proceedButton.setLabel(TEXT[0]);
    combatRewardScreen.clear();
    
    // 清理下一个房间的奖励
    if (nextRoom != null && nextRoom.room != null) {
        nextRoom.room.rewards.clear();
    }
    
    // 更新怪物列表
    if (getCurrRoom() instanceof MonsterRoomElite) {
        if (!eliteMonsterList.isEmpty()) {
            logger.info("Removing elite: " + eliteMonsterList.get(0) + " from monster list.");
            eliteMonsterList.remove(0);
        } else {
            generateElites(10);
        }
    } else if (getCurrRoom() instanceof MonsterRoom) {
        if (!monsterList.isEmpty()) {
            logger.info("Removing monster: " + monsterList.get(0) + " from monster list.");
            monsterList.remove(0);
        } else {
            generateStrongEnemies(12);
        }
    }
    
    // 清理状态
    resetPlayer();
    
    // 更新楼层
    if (!CardCrawlGame.loadingSave) {
        incrementFloorBasedMetrics();
        floorNum++;
        SaveHelper.saveIfAppropriate(SaveFile.SaveType.ENTER_ROOM);
    }
    
    // 更新随机数生成器
    monsterHpRng = new Random(Long.valueOf(Settings.seed.longValue() + floorNum));
    aiRng = new Random(Long.valueOf(Settings.seed.longValue() + floorNum));
    shuffleRng = new Random(Long.valueOf(Settings.seed.longValue() + floorNum));
    cardRandomRng = new Random(Long.valueOf(Settings.seed.longValue() + floorNum));
    miscRng = new Random(Long.valueOf(Settings.seed.longValue() + floorNum));
}
```

## 房间转换系统

### 房间转换流程

房间之间的转换是地城系统的核心流程：

```java
public void nextRoomTransition(SaveFile saveFile) {
    // 重置UI状态
    overlayMenu.proceedButton.setLabel(TEXT[0]);
    combatRewardScreen.clear();
    
    // 清理下一个房间的奖励
    if (nextRoom != null && nextRoom.room != null) {
        nextRoom.room.rewards.clear();
    }
    
    // 处理特殊房间逻辑
    if (getCurrRoom() instanceof MonsterRoomElite) {
        if (!eliteMonsterList.isEmpty()) {
            logger.info("Removing elite: " + eliteMonsterList.get(0) + " from monster list.");
            eliteMonsterList.remove(0);
        } else {
            generateElites(10);
        }
    } else if (getCurrRoom() instanceof MonsterRoom) {
        if (!monsterList.isEmpty()) {
            logger.info("Removing monster: " + monsterList.get(0) + " from monster list.");
            monsterList.remove(0);
        } else {
            generateStrongEnemies(12);
        }
    }
    
    // 清理效果和状态
    effectList.clear();
    topLevelEffectsQueue.clear();
    effectsQueue.clear();
    
    // 重置玩家状态
    resetPlayer();
    
    // 处理事件房间
    if (nextRoom != null && nextRoom.room instanceof EventRoom) {
        Random eventRngDuplicate = new Random(Settings.seed, eventRng.counter);
        EventHelper.RoomResult roomResult = EventHelper.roll(eventRngDuplicate);
        
        boolean isLoadingCompletedEvent = (CardCrawlGame.loadingSave && saveFile != null && saveFile.post_combat && roomResult == EventHelper.RoomResult.EVENT);
        if (!isLoadingCompletedEvent) {
            eventRng = eventRngDuplicate;
            nextRoom.room = generateRoom(roomResult);
        }
        
        nextRoom.room.setMapSymbol("?");
        nextRoom.room.setMapImg(ImageMaster.MAP_NODE_EVENT, ImageMaster.MAP_NODE_EVENT_OUTLINE);
    }
    
    // 设置当前房间
    setCurrMapNode(nextRoom);
    
    // 触发遗物进入房间效果
    if (getCurrRoom() != null && !CardCrawlGame.loadingSave) {
        for (AbstractRelic r : player.relics) {
            r.justEnteredRoom(getCurrRoom());
        }
    }
    
    // 处理加载状态
    if (isLoadingCompletedEvent) {
        getCurrRoom().phase = AbstractRoom.RoomPhase.COMPLETE;
        String eventKey = (String)((HashMap)saveFile.metric_event_choices.get(saveFile.metric_event_choices.size() - 1)).get("event_name");
        ((EventRoom)getCurrRoom()).event = EventHelper.getEvent(eventKey);
    } else {
        getCurrRoom().onPlayerEntry();
    }
    
    // 设置玩家位置
    if (currMapNode.room instanceof MonsterRoom && lastCombatMetricKey.equals("Shield and Spear")) {
        player.movePosition(Settings.WIDTH / 2.0F, floorY);
    } else {
        player.movePosition(Settings.WIDTH * 0.25F, floorY);
        player.flipHorizontal = false;
    }
    
    // 战前准备
    if (currMapNode.room instanceof MonsterRoom && !CardCrawlGame.loadingSave) {
        player.preBattlePrep();
    }
    
    // 更新场景
    scene.nextRoom(currMapNode.room);
    
    // 设置渲染场景
    if (currMapNode.room instanceof RestRoom) {
        rs = RenderScene.CAMPFIRE;
    } else if (currMapNode.room.event instanceof com.megacrit.cardcrawl.events.AbstractImageEvent) {
        rs = RenderScene.EVENT;
    } else {
        rs = RenderScene.NORMAL;
    }
}
```

## 事件系统

### 事件生成

事件是地城探索的重要组成部分：

```java
public static AbstractEvent generateEvent(Random rng) {
    // 25%概率生成神龛事件
    if (rng.random(1.0F) < shrineChance) {
        if (!shrineList.isEmpty() || !specialOneTimeEventList.isEmpty())
            return getShrine(rng);
        if (!eventList.isEmpty()) {
            return getEvent(rng);
        }
        logger.info("No events or shrines left");
        return null;
    }
    
    AbstractEvent retVal = getEvent(rng);
    if (retVal == null) {
        return getShrine(rng);
    }
    return retVal;
}

public static AbstractEvent getShrine(Random rng) {
    ArrayList<String> tmp = new ArrayList<>();
    tmp.addAll(shrineList);
    
    // 检查特殊一次性事件的可用性
    for (String e : specialOneTimeEventList) {
        switch (e) {
            case "Fountain of Cleansing":
                if (player.isCursed()) {
                    tmp.add(e);
                }
                continue;
            case "Designer":
                if ((id.equals("TheCity") || id.equals("TheBeyond")) && player.gold >= 75) {
                    tmp.add(e);
                }
                continue;
            case "Duplicator":
                if (id.equals("TheCity") || id.equals("TheBeyond")) {
                    tmp.add(e);
                }
                continue;
            // ... 更多条件检查
        }
        tmp.add(e);
    }
    
    String tmpKey = tmp.get(rng.random(tmp.size() - 1));
    shrineList.remove(tmpKey);
    specialOneTimeEventList.remove(tmpKey);
    logger.info("Removed event: " + tmpKey + " from pool.");
    
    return EventHelper.getEvent(tmpKey);
}
```

## 地城更新循环

### 主更新方法

地城的更新循环是游戏的核心循环：

```java
public void update() {
    // 更新游戏时间
    if (!CardCrawlGame.stopClock) {
        CardCrawlGame.playtime += Gdx.graphics.getDeltaTime();
    }
    
    // 处理屏幕计时器
    if (CardCrawlGame.screenTimer > 0.0F) {
        InputHelper.justClickedLeft = false;
        CInputActionSet.select.unpress();
    }
    
    // 更新UI元素
    topPanel.update();
    dynamicBanner.update();
    updateFading();
    currMapNode.room.updateObjects();
    
    // 更新渐变效果
    if (isScreenUp) {
        topGradientColor.a = MathHelper.fadeLerpSnap(topGradientColor.a, 0.25F);
        botGradientColor.a = MathHelper.fadeLerpSnap(botGradientColor.a, 0.25F);
    } else {
        topGradientColor.a = MathHelper.fadeLerpSnap(topGradientColor.a, 0.1F);
        botGradientColor.a = MathHelper.fadeLerpSnap(botGradientColor.a, 0.1F);
    }
    
    // 根据当前屏幕更新
    switch (screen) {
        case NORMAL:
        case CAMPFIRE:
            dungeonMapScreen.update();
            currMapNode.room.update();
            scene.update();
            currMapNode.room.eventControllerInput();
            break;
        case EVENT:
            ftue.update();
            InputHelper.justClickedRight = false;
            InputHelper.justClickedLeft = false;
            currMapNode.room.update();
            break;
        // ... 更多屏幕类型
    }
    
    // 更新效果
    updateEffects();
    
    // 更新覆盖菜单
    overlayMenu.update();
}

private void updateEffects() {
    turnPhaseEffectActive = false;
    
    // 更新顶层效果
    Iterator<AbstractGameEffect> i;
    for (i = topLevelEffects.iterator(); i.hasNext(); ) {
        AbstractGameEffect e = i.next();
        e.update();
        
        if (e.isDone) {
            i.remove();
        }
    }
    
    // 更新普通效果
    for (i = effectList.iterator(); i.hasNext(); ) {
        AbstractGameEffect e = i.next();
        e.update();
        if (e instanceof com.megacrit.cardcrawl.vfx.PlayerTurnEffect) {
            turnPhaseEffectActive = true;
        }
        
        if (e.isDone) {
            i.remove();
        }
    }
    
    // 处理效果队列
    for (i = effectsQueue.iterator(); i.hasNext(); ) {
        AbstractGameEffect e = i.next();
        effectList.add(e);
        i.remove();
    }
    
    for (i = topLevelEffectsQueue.iterator(); i.hasNext(); ) {
        AbstractGameEffect e = i.next();
        topLevelEffects.add(e);
        i.remove();
    }
}
```

## 地城渲染系统

### 主渲染方法

地城的渲染系统负责绘制所有视觉元素：

```java
public void render(SpriteBatch sb) {
    // 根据渲染场景渲染背景
    switch (rs) {
        case NORMAL:
            scene.renderCombatRoomBg(sb);
            break;
        case CAMPFIRE:
            scene.renderCampfireRoom(sb);
            renderLetterboxGradient(sb);
            break;
        case EVENT:
            scene.renderEventRoom(sb);
            break;
    }
    
    // 渲染背景效果
    for (AbstractGameEffect e : effectList) {
        if (e.renderBehind) {
            e.render(sb);
        }
    }
    
    // 渲染房间
    currMapNode.room.render(sb);
    
    // 渲染前景
    if (rs == RenderScene.NORMAL) {
        scene.renderCombatRoomFg(sb);
    }
    
    // 渲染信箱渐变
    if (rs != RenderScene.CAMPFIRE) {
        renderLetterboxGradient(sb);
    }
    
    // 渲染事件文本
    AbstractRoom room = getCurrRoom();
    if (room instanceof EventRoom || room instanceof NeowRoom || room instanceof VictoryRoom) {
        room.renderEventTexts(sb);
    }
    
    // 渲染前景效果
    for (AbstractGameEffect e : effectList) {
        if (!e.renderBehind) {
            e.render(sb);
        }
    }
    
    // 渲染覆盖层
    overlayMenu.render(sb);
    overlayMenu.renderBlackScreen(sb);
    
    // 根据当前屏幕渲染UI
    switch (screen) {
        case CAMPFIRE:
            dungeonMapScreen.render(sb);
            break;
        case MASTER_DECK_VIEW:
            deckViewScreen.render(sb);
            break;
        // ... 更多屏幕类型
    }
    
    // 渲染顶部和底部渐变
    if (screen != CurrentScreen.UNLOCK) {
        sb.setColor(topGradientColor);
        if (!Settings.hideTopBar) {
            sb.draw(ImageMaster.SCROLL_GRADIENT, 0.0F, Settings.HEIGHT - 128.0F * Settings.scale, Settings.WIDTH, 64.0F * Settings.scale);
        }
        
        sb.setColor(botGradientColor);
        if (!Settings.hideTopBar) {
            sb.draw(ImageMaster.SCROLL_GRADIENT, 0.0F, 64.0F * Settings.scale, Settings.WIDTH, -64.0F * Settings.scale);
        }
    }
    
    // 渲染FTUE
    if (screen == CurrentScreen.FTUE) {
        ftue.render(sb);
    }
    
    // 渲染顶层UI
    overlayMenu.cancelButton.render(sb);
    dynamicBanner.render(sb);
    if (screen != CurrentScreen.UNLOCK) {
        topPanel.render(sb);
    }
    currMapNode.room.renderAboveTopPanel(sb);
    
    // 渲染顶层效果
    for (AbstractGameEffect e : topLevelEffects) {
        if (!e.renderBehind) {
            e.render(sb);
        }
    }
    
    // 渲染淡入淡出效果
    sb.setColor(fadeColor);
    sb.draw(ImageMaster.WHITE_SQUARE_IMG, 0.0F, 0.0F, Settings.WIDTH, Settings.HEIGHT);
}
```

## 地城转换设置

### 地城转换初始化

地城转换设置负责准备新地城的状态：

```java
public static void dungeonTransitionSetup() {
    actNum++;
    
    // 调整卡牌随机数计数器
    if (cardRng.counter > 0 && cardRng.counter < 250) {
        cardRng.setCounter(250);
    } else if (cardRng.counter > 250 && cardRng.counter < 500) {
        cardRng.setCounter(500);
    } else if (cardRng.counter > 500 && cardRng.counter < 750) {
        cardRng.setCounter(750);
    }
    logger.info("CardRng Counter: " + cardRng.counter);
    
    // 重置UI
    topPanel.unhoverHitboxes();
    
    // 清空路径
    pathX.clear();
    pathY.clear();
    
    // 重置事件系统
    EventHelper.resetProbabilities();
    eventList.clear();
    shrineList.clear();
    
    // 清空怪物列表
    monsterList.clear();
    eliteMonsterList.clear();
    bossList.clear();
    
    // 重置药水修改器
    AbstractRoom.blizzardPotionMod = 0;
    
    // 处理升华模式治疗
    if (ascensionLevel >= 5) {
        player.heal(MathUtils.round((player.maxHealth - player.currentHealth) * 0.75F), false);
    } else {
        player.heal(player.maxHealth, false);
    }
    
    // 显示治疗效果
    if (floorNum > 1) {
        topPanel.panelHealEffect();
    }
    
    // 处理第一层特殊效果
    if (floorNum <= 1) {
        if (CardCrawlGame.dungeon instanceof Exordium) {
            if (ascensionLevel >= 14) {
                player.decreaseMaxHealth(player.getAscensionMaxHPLoss());
            }
            if (ascensionLevel >= 6) {
                player.currentHealth = MathUtils.round(player.maxHealth * 0.9F);
            }
            if (ascensionLevel >= 10) {
                player.masterDeck.addToTop((AbstractCard)new AscendersBane());
                UnlockTracker.markCardAsSeen("AscendersBane");
            }
            CardCrawlGame.playtime = 0.0F;
        }
    }
    
    // 重置地图状态
    dungeonMapScreen.map.atBoss = false;
}
```

## 总结

地城系统是《杀戮尖塔》的核心架构，它整合了游戏的所有主要系统：

1. **地图生成**：使用算法生成随机但平衡的地城布局
2. **随机数管理**：确保不同系统的独立随机性
3. **资源池管理**：管理卡牌、遗物、事件等资源的分配
4. **房间转换**：处理不同房间类型之间的平滑过渡
5. **事件系统**：提供叙事和选择元素
6. **渲染系统**：负责所有视觉元素的呈现
7. **状态管理**：维护游戏的整体状态和进度

地城系统的设计体现了游戏的核心设计理念：提供可重玩的随机体验，同时保持平衡和趣味性。通过精心设计的算法和系统，每次游戏都能提供独特的挑战和体验。