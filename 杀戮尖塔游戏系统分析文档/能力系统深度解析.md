# 能力系统深度解析

## 概述

能力系统是杀戮尖塔的核心机制之一，通过AbstractPower类实现了各种临时和永久的角色状态效果。能力系统为角色提供了丰富的属性修改、触发效果和状态管理，是游戏策略深度的重要来源。

## 核心类分析

### AbstractPower - 能力基类

AbstractPower是所有能力的抽象基类，定义了能力的基本属性和行为：

```java
public abstract class AbstractPower implements Comparable<AbstractPower> {
    // 基本属性
    public String ID;              // 能力唯一标识
    public String name;            // 能力名称
    public String description;     // 能力描述
    public AbstractCreature owner; // 能力拥有者
    
    // 数值相关
    public int amount = -1;        // 能力数值（-1表示不显示数值）
    public int priority = 5;       // 渲染优先级
    public boolean canGoNegative = false; // 是否可以为负值
    
    // 类型相关
    public PowerType type = PowerType.BUFF; // 能力类型
    protected boolean isTurnBased = false;  // 是否基于回合
    public boolean isPostActionPower = false; // 是否是动作后能力
    
    // 视觉资源
    public Texture img;                    // 能力图标
    public TextureAtlas.AtlasRegion region48;   // 48x48图标
    public TextureAtlas.AtlasRegion region128;  // 128x128图标
    
    // 渲染相关
    protected float fontScale = 1.0F;      // 字体缩放
    private Color color = new Color(1.0F, 1.0F, 1.0F, 0.0F);
    private Color redColor = new Color(1.0F, 0.0F, 0.0F, 1.0F);
    private Color greenColor = new Color(0.0F, 1.0F, 0.0F, 1.0F);
    private ArrayList<AbstractGameEffect> effect = new ArrayList<>();
    
    // 静态资源
    public static TextureAtlas atlas;      // 能力图集
    public static String[] DESCRIPTIONS;   // 描述数组
}
```

#### 能力类型枚举

```java
public enum PowerType {
    BUFF,   // 增益效果
    DEBUFF  // 减益效果
}
```

#### 核心方法

1. **stackPower(int stackAmount)** - 叠加能力
2. **reducePower(int reduceAmount)** - 减少能力数值
3. **updateDescription()** - 更新描述
4. **flash()** - 闪烁效果
5. **atStartOfTurn()** - 回合开始时触发
6. **atEndOfTurn(boolean isPlayer)** - 回合结束时触发
7. **onAttack()** - 攻击时触发
8. **onAttacked()** - 被攻击时触发

### 能力生命周期

#### 初始化流程

```java
// 1. 静态初始化
public static void initialize() {
    atlas = new TextureAtlas(Gdx.files.internal("powers/powers.atlas"));
}

// 2. 实例初始化
public AbstractPower() {
    // 加载图标资源
    loadRegion("power_name");
    
    // 设置基本属性
    this.name = "Power Name";
    this.ID = "PowerID";
    this.owner = null;
    this.amount = 3;
    this.type = PowerType.BUFF;
}

// 3. 资源加载
protected void loadRegion(String fileName) {
    this.region48 = atlas.findRegion("48/" + fileName);
    this.region128 = atlas.findRegion("128/" + fileName);
}
```

#### 应用流程

```java
// 应用能力到角色
public void apply(AbstractCreature target) {
    this.owner = target;
    
    // 1. 初始应用
    onInitialApplication();
    
    // 2. 添加到角色能力列表
    target.powers.add(this);
    
    // 3. 播放音效
    playApplyPowerSfx();
    
    // 4. 视觉效果
    flash();
    
    // 5. 更新描述
    updateDescription();
}
```

#### 移除流程

```java
// 移除能力
public void remove() {
    // 1. 触发移除事件
    onRemove();
    
    // 2. 从角色能力列表移除
    if (owner != null) {
        owner.powers.remove(this);
    }
    
    // 3. 清理资源
    this.effect.clear();
}
```

## 数据结构

### 能力属性系统

```java
// 基本属性
public String ID;              // 唯一标识符
public String name;            // 显示名称
public String description;     // 描述文本
public AbstractCreature owner; // 拥有者

// 数值系统
public int amount;             // 能力数值
public int priority;           // 渲染优先级
public boolean canGoNegative;  // 是否允许负值

// 类型系统
public PowerType type;         // 能力类型
public boolean isTurnBased;    // 是否基于回合
public boolean isPostActionPower; // 是否动作后触发
```

### 视觉资源系统

```java
// 图标资源
public Texture img;                    // 自定义图标
public TextureAtlas.AtlasRegion region48;   // 48x48图标
public TextureAtlas.AtlasRegion region128;  // 128x128图标

// 渲染属性
protected float fontScale;             // 字体缩放
private Color color;                   // 基础颜色
private Color redColor;                // 负值颜色
private Color greenColor;              // 正值颜色

// 特效列表
private ArrayList<AbstractGameEffect> effect; // 视觉效果
```

### 事件回调系统

```java
// 回合事件
public void atStartOfTurn();                    // 回合开始
public void atStartOfTurnPostDraw();            // 回合开始后抽牌
public void duringTurn();                       // 回合中
public void atEndOfTurn(boolean isPlayer);      // 回合结束
public void atEndOfTurnPreEndTurnCards(boolean isPlayer); // 回合结束前结束卡牌
public void atEndOfRound();                     // 回合轮结束

// 伤害事件
public float atDamageGive(float damage, DamageInfo.DamageType type); // 造成伤害
public float atDamageReceive(float damage, DamageInfo.DamageType type); // 受到伤害
public float atDamageFinalGive(float damage, DamageInfo.DamageType type); // 最终造成伤害
public float atDamageFinalReceive(float damage, DamageInfo.DamageType type); // 最终受到伤害

// 卡牌事件
public void onCardDraw(AbstractCard card);      // 抽牌时
public void onPlayCard(AbstractCard card, AbstractMonster m); // 打出卡牌时
public void onUseCard(AbstractCard card, UseCardAction action); // 使用卡牌时
public void onAfterUseCard(AbstractCard card, UseCardAction action); // 使用卡牌后
public void onExhaust(AbstractCard card);       // 消耗卡牌时

// 其他事件
public void onHeal(int healAmount);             // 治疗时
public void onAttack(DamageInfo info, int damageAmount, AbstractCreature target); // 攻击时
public void onAttacked(DamageInfo info, int damageAmount); // 被攻击时
public void onDeath();                          // 死亡时
public void onVictory();                        // 胜利时
```

## 算法与逻辑

### 能力叠加算法

```java
public void stackPower(int stackAmount) {
    // 检查是否可叠加
    if (this.amount == -1) {
        logger.info(this.name + " does not stack");
        return;
    }
    
    // 触发字体缩放动画
    this.fontScale = 8.0F;
    
    // 叠加数值
    this.amount += stackAmount;
    
    // 更新描述
    updateDescription();
}

public void reducePower(int reduceAmount) {
    // 计算新数值
    int newAmount = this.amount - reduceAmount;
    
    // 触发字体缩放动画
    this.fontScale = 8.0F;
    
    // 设置新数值
    if (newAmount <= 0) {
        this.amount = 0;
    } else {
        this.amount = newAmount;
    }
    
    // 更新描述
    updateDescription();
}
```

### 伤害计算流程

能力系统在伤害计算中的完整流程：

```java
// 1. 造成伤害前的修正
public float atDamageGive(float damage, DamageInfo.DamageType type) {
    return damage; // 默认不修正
}

// 2. 受到伤害前的修正
public float atDamageReceive(float damage, DamageInfo.DamageType type) {
    return damage; // 默认不修正
}

// 3. 造成伤害的最终修正
public float atDamageFinalGive(float damage, DamageInfo.DamageType type) {
    return damage; // 默认不修正
}

// 4. 受到伤害的最终修正
public float atDamageFinalReceive(float damage, DamageInfo.DamageType type) {
    return damage; // 默认不修正
}

// 实际伤害计算流程
public int calculateDamage(int baseDamage, AbstractCreature target) {
    float damage = baseDamage;
    
    // 应用所有攻击方能力
    for (AbstractPower p : owner.powers) {
        damage = p.atDamageGive(damage, DamageInfo.DamageType.NORMAL);
    }
    
    // 应用所有防御方能力
    for (AbstractPower p : target.powers) {
        damage = p.atDamageReceive(damage, DamageInfo.DamageType.NORMAL);
    }
    
    // 应用姿态效果
    damage = owner.stance.atDamageGive(damage, DamageInfo.DamageType.NORMAL);
    damage = target.stance.atDamageReceive(damage, DamageInfo.DamageType.NORMAL);
    
    // 应用最终修正
    for (AbstractPower p : owner.powers) {
        damage = p.atDamageFinalGive(damage, DamageInfo.DamageType.NORMAL);
    }
    
    for (AbstractPower p : target.powers) {
        damage = p.atDamageFinalReceive(damage, DamageInfo.DamageType.NORMAL);
    }
    
    return MathUtils.floor(damage);
}
```

### 回合管理算法

```java
// 回合开始处理
public void atStartOfTurn() {
    // 基础实现为空，子类可重写
}

// 回合结束处理
public void atEndOfTurn(boolean isPlayer) {
    // 基于回合的能力处理
    if (isTurnBased) {
        // 减少回合数
        this.amount--;
        
        // 检查是否移除
        if (this.amount <= 0) {
            // 创建移除动作
            AbstractDungeon.actionManager.addToBottom(
                new RemoveSpecificPowerAction(owner, owner, this.ID)
            );
        }
    }
}

// 回合轮结束处理
public void atEndOfRound() {
    // 处理跨回合的效果
}
```

### 能力搜索和管理

```java
// 查找能力
public static AbstractPower getPower(AbstractCreature target, String powerID) {
    for (AbstractPower p : target.powers) {
        if (p.ID.equals(powerID)) {
            return p;
        }
    }
    return null;
}

// 检查是否有能力
public static boolean hasPower(AbstractCreature target, String powerID) {
    return getPower(target, powerID) != null;
}

// 获取能力数值
public static int getPowerAmount(AbstractCreature target, String powerID) {
    AbstractPower p = getPower(target, powerID);
    return p != null ? p.amount : 0;
}
```

## 系统交互

### 与角色系统的交互

```java
// 角色添加能力
public void addPower(AbstractPower power) {
    power.owner = this;
    this.powers.add(power);
    
    // 按优先级排序
    this.powers.sort(null);
    
    // 触发初始应用
    power.onInitialApplication();
    
    // 视觉效果
    power.flash();
}

// 角色移除能力
public void removePower(AbstractPower power) {
    power.onRemove();
    this.powers.remove(power);
}
```

### 与动作系统的交互

```java
// 通过动作应用能力
public void applyPower(AbstractCreature target, AbstractPower power) {
    AbstractDungeon.actionManager.addToBottom(
        new ApplyPowerAction(target, this, power)
    );
}

// 通过动作移除能力
public void removePower(AbstractCreature target, String powerID) {
    AbstractDungeon.actionManager.addToBottom(
        new RemoveSpecificPowerAction(target, this, powerID)
    );
}
```

### 与卡牌系统的交互

```java
// 卡牌使用时触发能力
public void useCard(AbstractCard card, AbstractMonster target) {
    // 通知所有能力
    for (AbstractPower p : this.powers) {
        p.onUseCard(card, new UseCardAction(card, target));
    }
}

// 抽牌时触发能力
public void drawCard() {
    AbstractCard card = this.drawPile.getTopCard();
    
    // 通知所有能力
    for (AbstractPower p : this.powers) {
        p.onCardDraw(card);
    }
}
```

## 关键流程

### 能力应用流程

```java
// 1. 创建能力实例
AbstractPower power = new StrengthPower(target, 3);

// 2. 应用能力
AbstractDungeon.actionManager.addToBottom(
    new ApplyPowerAction(target, source, power, 3)
);

// 3. ApplyPowerAction执行
public void update() {
    if (this.duration == 0.1F) {
        // 应用能力
        target.powers.add(powerToApply);
        powerToApply.onInitialApplication();
        
        // 视觉和音效
        powerToApply.flash();
        powerToApply.playApplyPowerSfx();
    }
    
    this.duration -= Gdx.graphics.getDeltaTime();
    if (this.duration < 0.0F) {
        this.isDone = true;
    }
}
```

### 能力更新流程

```java
// 每帧更新能力
public void update(int slot) {
    // 1. 更新闪烁效果
    updateFlash();
    
    // 2. 更新字体缩放
    updateFontScale();
    
    // 3. 更新颜色
    updateColor();
    
    // 4. 更新粒子效果
    updateParticles();
}

private void updateFlash() {
    for (Iterator<AbstractGameEffect> i = this.effect.iterator(); i.hasNext(); ) {
        AbstractGameEffect e = i.next();
        e.update();
        if (e.isDone) {
            i.remove();
        }
    }
}

private void updateFontScale() {
    if (this.fontScale != 1.0F) {
        this.fontScale = MathUtils.lerp(
            this.fontScale, 1.0F, 
            Gdx.graphics.getDeltaTime() * 10.0F
        );
        
        if (Math.abs(this.fontScale - 1.0F) < 0.05F) {
            this.fontScale = 1.0F;
        }
    }
}
```

### 能量管理流程

```java
// 能量获得时触发
public void atEnergyGain() {
    // 默认空实现，子类可重写
}

// 能量充能时触发
public void onEnergyRecharge() {
    // 默认空实现，子类可重写
}

// 实际能量管理
public void rechargeEnergy() {
    this.energy.recharge();
    
    // 通知所有能力
    for (AbstractPower p : this.powers) {
        p.onEnergyRecharge();
    }
}
```

## 设计模式

### 模板方法模式

AbstractPower使用模板方法模式定义了能力的基本结构：

```java
public abstract class AbstractPower {
    // 模板方法
    public final void apply(AbstractCreature target) {
        this.owner = target;
        onInitialApplication();
        target.powers.add(this);
        playApplyPowerSfx();
        flash();
        updateDescription();
    }
    
    // 钩子方法
    protected abstract void onInitialApplication();
    protected abstract void updateDescription();
}
```

### 观察者模式

能力系统作为观察者监听游戏事件：

```java
// 事件通知
public void onAttack(DamageInfo info, int damageAmount, AbstractCreature target) {
    // 通知所有观察者（能力）
    for (AbstractPower p : owner.powers) {
        p.onAttack(info, damageAmount, target);
    }
}
```

### 策略模式

不同的能力实现不同的策略：

```java
// 伤害修正策略
public class StrengthPower extends AbstractPower {
    @Override
    public float atDamageGive(float damage, DamageInfo.DamageType type) {
        return damage + this.amount;
    }
}

public class WeakPower extends AbstractPower {
    @Override
    public float atDamageGive(float damage, DamageInfo.DamageType type) {
        return damage * 0.75F;
    }
}
```

### 工厂模式

能力创建使用工厂模式：

```java
public class PowerFactory {
    public static AbstractPower createPower(String powerID, AbstractCreature target, int amount) {
        switch (powerID) {
            case "Strength":
                return new StrengthPower(target, amount);
            case "Dexterity":
                return new DexterityPower(target, amount);
            case "Weak":
                return new WeakPower(target, amount);
            default:
                return null;
        }
    }
}
```

## 性能考虑

### 渲染优化

```java
// 条件渲染
public void renderIcons(SpriteBatch sb, float x, float y, Color c) {
    // 只渲染可见的能力
    if (this.amount == 0 && !this.canGoNegative) {
        return;
    }
    
    // 使用缓存的图标
    if (this.region48 != null) {
        sb.setColor(c);
        sb.draw(this.region48, x, y);
    }
}
```

### 内存管理

```java
// 及时清理特效
private void updateFlash() {
    for (Iterator<AbstractGameEffect> i = this.effect.iterator(); i.hasNext(); ) {
        AbstractGameEffect e = i.next();
        e.update();
        if (e.isDone) {
            i.remove(); // 及时移除完成的特效
        }
    }
}
```

### 更新优化

```java
// 分帧更新
public void update(int slot) {
    // 只更新需要更新的部分
    if (this.fontScale != 1.0F) {
        updateFontScale();
    }
    
    if (this.color.a != 1.0F) {
        updateColor();
    }
    
    if (!this.effect.isEmpty()) {
        updateFlash();
    }
}
```

## 扩展机制

### 自定义能力

```java
public class CustomPower extends AbstractPower {
    public static final String POWER_ID = "CustomPower";
    
    public CustomPower(AbstractCreature owner, int amount) {
        this.name = "Custom Power";
        this.ID = POWER_ID;
        this.owner = owner;
        this.amount = amount;
        this.type = PowerType.BUFF;
        this.isTurnBased = true;
        
        loadRegion("custom");
        updateDescription();
    }
    
    @Override
    public void updateDescription() {
        this.description = DESCRIPTIONS[0] + this.amount + DESCRIPTIONS[1];
    }
    
    @Override
    public void atStartOfTurn() {
        // 自定义回合开始效果
        flash();
    }
    
    @Override
    public float atDamageGive(float damage, DamageInfo.DamageType type) {
        // 自定义伤害修正
        return damage + this.amount;
    }
}
```

### 能力组合

```java
// 复合能力
public class ComboPower extends AbstractPower {
    @Override
    public void onInitialApplication() {
        // 添加子能力
        owner.powers.add(new StrengthPower(owner, 2));
        owner.powers.add(new DexterityPower(owner, 1));
    }
    
    @Override
    public void onRemove() {
        // 移除子能力
        removePower(owner, "Strength");
        removePower(owner, "Dexterity");
    }
}
```

## 总结

能力系统是杀戮尖塔的核心机制之一，通过AbstractPower基类提供了灵活的状态管理框架。该系统的设计特点包括：

1. **灵活的事件系统** - 通过丰富的回调方法支持各种游戏事件
2. **可扩展的架构** - 易于添加新的能力类型和效果
3. **高效的渲染机制** - 优化的图标和数值显示
4. **完整的生命周期管理** - 从应用到移除的完整流程
5. **强大的交互能力** - 与其他系统的深度集成

能力系统为游戏提供了丰富的策略深度和可玩性，是游戏设计的重要组成部分。通过深入理解能力系统，可以更好地理解游戏的核心机制，并为Mod开发提供坚实的基础。