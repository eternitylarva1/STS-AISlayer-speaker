# 商店系统深度解析

## 概述

杀戮尖塔的商店系统是游戏中的重要经济系统，为玩家提供了在游戏过程中获取卡牌、遗物和药水的途径。商店系统通过精心设计的价格机制、折扣系统和库存管理，为玩家提供了战略性的资源获取选择。

## 核心类分析

### ShopScreen类

`com.megacrit.cardcrawl.shop.ShopScreen`是商店系统的核心类，负责管理商店的UI、商品展示、价格计算和购买逻辑。

```java
public class ShopScreen {
    private static final Logger logger = LogManager.getLogger(ShopScreen.class.getName());
    private static final TutorialStrings tutorialStrings = CardCrawlGame.languagePack.getTutorialString("Shop Tip");
    public static final String[] MSG = tutorialStrings.TEXT;
    public static final String[] LABEL = tutorialStrings.LABEL;
    
    private static final CharacterStrings characterStrings = CardCrawlGame.languagePack.getCharacterString("Shop Screen");
    public static final String[] NAMES = characterStrings.NAMES;
    public static final String[] TEXT = characterStrings.TEXT;
    
    public boolean isActive = true;
    
    // 商品列表
    public ArrayList<AbstractCard> coloredCards = new ArrayList<>();
    public ArrayList<AbstractCard> colorlessCards = new ArrayList<>();
    private ArrayList<StoreRelic> relics = new ArrayList<>();
    private ArrayList<StorePotion> potions = new ArrayList<>();
    
    // 价格相关
    public static int purgeCost = 75;
    public static int actualPurgeCost = 75;
    private static final int PURGE_COST_RAMP = 25;
    
    // UI组件
    public ConfirmButton confirmButton = new ConfirmButton();
    private OnSaleTag saleTag;
    
    // 商人相关
    private float speechTimer = 0.0F;
    private ShopSpeechBubble speechBubble = null;
    private SpeechTextEffect dialogTextEffect = null;
    private ArrayList<String> idleMessages = new ArrayList<>();
    private boolean saidWelcome = false;
}
```

#### 关键常量

```java
// 布局常量
private static final float DRAW_START_X = Settings.WIDTH * 0.16F;
private static final int NUM_CARDS_PER_LINE = 5;
private static final float TOP_ROW_Y = 760.0F * Settings.yScale;
private static final float BOTTOM_ROW_Y = 337.0F * Settings.yScale;

// 价格波动
private static final float CARD_PRICE_JITTER = 0.1F;
private static final float RELIC_PRICE_JITTER = 0.05F;
private static final float POTION_PRICE_JITTER = 0.05F;

// 无色卡牌价格加成
private static final float COLORLESS_PRICE_BUMP = 1.2F;

// 语音相关
private static final float MIN_IDLE_MSG_TIME = 40.0F;
private static final float MAX_IDLE_MSG_TIME = 60.0F;
private static final float SPEECH_DURATION = 4.0F;
```

### StoreRelic类

`com.megacrit.cardcrawl.shop.StoreRelic`是商店中遗物的包装类，负责管理遗物的显示、价格和购买逻辑。

```java
public class StoreRelic {
    public AbstractRelic relic;
    private ShopScreen shopScreen;
    public int price;
    public boolean isPurchased = false;
    
    public StoreRelic(AbstractRelic relic, int slot, ShopScreen screenRef) {
        this.relic = relic;
        this.price = relic.getPrice();
        this.shopScreen = screenRef;
    }
    
    public void purchaseRelic() {
        if (AbstractDungeon.player.gold >= this.price) {
            AbstractDungeon.player.loseGold(this.price);
            AbstractDungeon.player.loseRelic(this.relic.relicId);
            this.shopScreen.playBuySfx();
            this.shopScreen.createSpeech(ShopScreen.getBuyMsg());
            
            // 特殊遗物效果
            if (this.relic.relicId.equals("The Courier") || AbstractDungeon.player.hasRelic("The Courier")) {
                AbstractRelic tempRelic = AbstractDungeon.returnRandomRelicEnd(ShopScreen.rollRelicTier());
                if (tempRelic.relicId.equals("The Courier") || AbstractDungeon.player.hasRelic("The Courier")) {
                    tempRelic = AbstractDungeon.returnRandomRelicEnd(ShopScreen.rollRelicTier());
                }
                this.relic = tempRelic;
                this.price = this.relic.getPrice();
            } else {
                this.isPurchased = true;
            }
        } else {
            this.shopScreen.playCantBuySfx();
            this.shopScreen.createSpeech(ShopScreen.getCantBuyMsg());
        }
    }
}
```

### StorePotion类

`com.megacrit.cardcrawl.shop.StorePotion`是商店中药水的包装类，负责管理药水的显示、价格和购买逻辑。

```java
public class StorePotion {
    public AbstractPotion potion;
    private ShopScreen shopScreen;
    public int price;
    public boolean isPurchased = false;
    
    public StorePotion(AbstractPotion potion, int slot, ShopScreen screenRef) {
        this.potion = potion;
        this.price = potion.getPrice();
        this.shopScreen = screenRef;
    }
    
    public void purchasePotion() {
        if (AbstractDungeon.player.gold >= this.price) {
            AbstractDungeon.player.loseGold(this.price);
            AbstractDungeon.player.obtainPotion(this.potion);
            this.shopScreen.playBuySfx();
            this.shopScreen.createSpeech(ShopScreen.getBuyMsg());
            this.isPurchased = true;
        } else {
            this.shopScreen.playCantBuySfx();
            this.shopScreen.createSpeech(ShopScreen.getCantBuyMsg());
        }
    }
}
```

## 商店初始化

### init方法

商店的初始化过程包括设置商品、价格计算和特殊效果应用：

```java
public void init(ArrayList<AbstractCard> coloredCards, ArrayList<AbstractCard> colorlessCards) {
    // 初始化空闲消息
    this.idleMessages.clear();
    if (AbstractDungeon.id.equals("TheEnding")) {
        Collections.addAll(this.idleMessages, Merchant.ENDING_TEXT);
    } else {
        Collections.addAll(this.idleMessages, TEXT);
    }
    
    // 加载本地化图像
    loadLocalizedImages();
    
    // 设置商品
    this.coloredCards.clear();
    this.colorlessCards.clear();
    this.coloredCards = coloredCards;
    this.colorlessCards = colorlessCards;
    
    // 初始化各个系统
    initCards();
    initRelics();
    initPotions();
    
    // 设置删除服务
    this.purgeAvailable = true;
    actualPurgeCost = purgeCost;
    
    // 应用特殊效果
    applySpecialEffects();
}
```

### 卡牌初始化

卡牌的初始化包括价格计算和位置设置：

```java
private void initCards() {
    int tmp = (int)(Settings.WIDTH - DRAW_START_X * 2.0F - AbstractCard.IMG_WIDTH_S * 5.0F) / 4;
    float padX = (int)(tmp + AbstractCard.IMG_WIDTH_S);
    
    // 初始化有色卡牌
    for (int i = 0; i < this.coloredCards.size(); i++) {
        float tmpPrice = AbstractCard.getPrice(((AbstractCard)this.coloredCards.get(i)).rarity) * 
                        AbstractDungeon.merchantRng.random(0.9F, 1.1F);
        
        AbstractCard c = this.coloredCards.get(i);
        c.price = (int)tmpPrice;
        c.current_x = (Settings.WIDTH / 2);
        c.target_x = DRAW_START_X + AbstractCard.IMG_WIDTH_S / 2.0F + padX * i;
        
        // 触发遗物预览效果
        for (AbstractRelic r : AbstractDungeon.player.relics) {
            r.onPreviewObtainCard(c);
        }
    }
    
    // 初始化无色卡牌
    for (int i = 0; i < this.colorlessCards.size(); i++) {
        float tmpPrice = AbstractCard.getPrice(((AbstractCard)this.colorlessCards.get(i)).rarity) * 
                        AbstractDungeon.merchantRng.random(0.9F, 1.1F);
        tmpPrice *= 1.2F; // 无色卡牌价格加成
        
        AbstractCard c = this.colorlessCards.get(i);
        c.price = (int)tmpPrice;
        c.current_x = (Settings.WIDTH / 2);
        c.target_x = DRAW_START_X + AbstractCard.IMG_WIDTH_S / 2.0F + padX * i;
        
        // 触发遗物预览效果
        for (AbstractRelic r : AbstractDungeon.player.relics) {
            r.onPreviewObtainCard(c);
        }
    }
    
    // 设置打折卡牌
    AbstractCard saleCard = this.coloredCards.get(AbstractDungeon.merchantRng.random(0, 4));
    saleCard.price /= 2;
    this.saleTag = new OnSaleTag(saleCard);
    
    setStartingCardPositions();
}
```

### 遗物初始化

遗物的初始化包括随机生成和价格计算：

```java
private void initRelics() {
    this.relics.clear();
    this.relics = new ArrayList<>();
    
    for (int i = 0; i < 3; i++) {
        AbstractRelic tempRelic = null;
        
        // 前两个位置随机稀有度，第三个位置商店稀有度
        if (i != 2) {
            tempRelic = AbstractDungeon.returnRandomRelicEnd(rollRelicTier());
        } else {
            tempRelic = AbstractDungeon.returnRandomRelicEnd(AbstractRelic.RelicTier.SHOP);
        }
        
        StoreRelic relic = new StoreRelic(tempRelic, i, this);
        
        // 非每日挑战时价格随机波动
        if (!Settings.isDailyRun) {
            relic.price = MathUtils.round(relic.price * AbstractDungeon.merchantRng.random(0.95F, 1.05F));
        }
        
        this.relics.add(relic);
    }
}
```

### 药水初始化

药水的初始化包括随机生成和价格计算：

```java
private void initPotions() {
    this.potions.clear();
    this.potions = new ArrayList<>();
    
    for (int i = 0; i < 3; i++) {
        StorePotion potion = new StorePotion(AbstractDungeon.returnRandomPotion(), i, this);
        
        // 非每日挑战时价格随机波动
        if (!Settings.isDailyRun) {
            potion.price = MathUtils.round(potion.price * AbstractDungeon.merchantRng.random(0.95F, 1.05F));
        }
        
        this.potions.add(potion);
    }
}
```

## 价格系统

### 遗物稀有度计算

遗物的稀有度通过随机数决定：

```java
public static AbstractRelic.RelicTier rollRelicTier() {
    int roll = AbstractDungeon.merchantRng.random(99);
    logger.info("ROLL " + roll);
    
    if (roll < 48) {
        return AbstractRelic.RelicTier.COMMON;  // 48% 概率
    }
    if (roll < 82) {
        return AbstractRelic.RelicTier.UNCOMMON; // 34% 概率
    }
    
    return AbstractRelic.RelicTier.RARE; // 18% 概率
}
```

### 价格计算

商品价格的计算考虑多个因素：

```java
private void setPrice(AbstractCard card) {
    float tmpPrice = AbstractCard.getPrice(card.rarity) * 
                    AbstractDungeon.merchantRng.random(0.9F, 1.1F);
    
    // 无色卡牌价格加成
    if (card.color == AbstractCard.CardColor.COLORLESS) {
        tmpPrice *= 1.2F;
    }
    
    // 应用遗物折扣
    if (AbstractDungeon.player.hasRelic("The Courier")) {
        tmpPrice *= 0.8F;
    }
    
    if (AbstractDungeon.player.hasRelic("Membership Card")) {
        tmpPrice *= 0.5F;
    }
    
    card.price = (int)tmpPrice;
}
```

### 折扣系统

商店支持多种折扣机制：

```java
public void applyDiscount(float multiplier, boolean affectPurge) {
    // 应用到遗物
    for (StoreRelic r : this.relics) {
        r.price = MathUtils.round(r.price * multiplier);
    }
    
    // 应用到药水
    for (StorePotion p : this.potions) {
        p.price = MathUtils.round(p.price * multiplier);
    }
    
    // 应用到卡牌
    for (AbstractCard c : this.coloredCards) {
        c.price = MathUtils.round(c.price * multiplier);
    }
    for (AbstractCard c : this.colorlessCards) {
        c.price = MathUtils.round(c.price * multiplier);
    }
    
    // 应用到删除服务
    if (AbstractDungeon.player.hasRelic("Smiling Mask")) {
        actualPurgeCost = 50;
    } else if (affectPurge) {
        actualPurgeCost = MathUtils.round(purgeCost * multiplier);
    }
}
```

## 特殊效果处理

### 特殊遗物效果

某些遗物会影响商店的行为：

```java
private void applySpecialEffects() {
    // 16层以上价格增加
    if (AbstractDungeon.ascensionLevel >= 16) {
        applyDiscount(1.1F, false);
    }
    
    // The Courier遗物折扣
    if (AbstractDungeon.player.hasRelic("The Courier")) {
        applyDiscount(0.8F, true);
    }
    
    // Membership Card遗物折扣
    if (AbstractDungeon.player.hasRelic("Membership Card")) {
        applyDiscount(0.5F, true);
    }
    
    // Smiling Mask遗物影响删除价格
    if (AbstractDungeon.player.hasRelic("Smiling Mask")) {
        actualPurgeCost = 50;
    }
}
```

### The Courier遗物特殊处理

The Courier遗物在购买后会替换为新的遗物：

```java
// 在StoreRelic.purchaseRelic()方法中
if (this.relic.relicId.equals("The Courier") || AbstractDungeon.player.hasRelic("The Courier")) {
    AbstractRelic tempRelic = AbstractDungeon.returnRandomRelicEnd(ShopScreen.rollRelicTier());
    if (tempRelic.relicId.equals("The Courier") || AbstractDungeon.player.hasRelic("The Courier")) {
        tempRelic = AbstractDungeon.returnRandomRelicEnd(ShopScreen.rollRelicTier());
    }
    this.relic = tempRelic;
    this.price = this.relic.getPrice();
} else {
    this.isPurchased = true;
}
```

## 删除服务

### 删除服务机制

删除服务允许玩家移除牌组中的卡牌：

```java
public static void purgeCard() {
    AbstractDungeon.player.loseGold(actualPurgeCost);
    CardCrawlGame.sound.play("SHOP_PURCHASE", 0.1F);
    purgeCost += 25; // 价格递增
    actualPurgeCost = purgeCost;
    
    // 应用特殊遗物效果
    if (AbstractDungeon.player.hasRelic("Smiling Mask")) {
        actualPurgeCost = 50;
        AbstractDungeon.player.getRelic("Smiling Mask").stopPulse();
    } else if (AbstractDungeon.player.hasRelic("The Courier") && 
               AbstractDungeon.player.hasRelic("Membership Card")) {
        actualPurgeCost = MathUtils.round(purgeCost * 0.8F * 0.5F);
    } else if (AbstractDungeon.player.hasRelic("The Courier")) {
        actualPurgeCost = MathUtils.round(purgeCost * 0.8F);
    } else if (AbstractDungeon.player.hasRelic("Membership Card")) {
        actualPurgeCost = MathUtils.round(purgeCost * 0.5F);
    }
}
```

### 删除服务更新

```java
public void updatePurge() {
    if (!AbstractDungeon.gridSelectScreen.selectedCards.isEmpty()) {
        purgeCard();
        for (AbstractCard card : AbstractDungeon.gridSelectScreen.selectedCards) {
            CardCrawlGame.metricData.addPurgedItem(card.getMetricID());
            AbstractDungeon.topLevelEffects.add(new PurgeCardEffect(card, Settings.WIDTH / 2.0F, Settings.HEIGHT / 2.0F));
            
            AbstractDungeon.player.masterDeck.removeCard(card);
        }
        AbstractDungeon.gridSelectScreen.selectedCards.clear();
        AbstractDungeon.shopScreen.purgeAvailable = false;
    }
}
```

## 商人交互系统

### 语音系统

商人会根据不同情况播放不同的语音：

```java
public void playBuySfx() {
    int roll = MathUtils.random(2);
    if (roll == 0) {
        CardCrawlGame.sound.play("VO_MERCHANT_KA");
    } else if (roll == 1) {
        CardCrawlGame.sound.play("VO_MERCHANT_KB");
    } else {
        CardCrawlGame.sound.play("VO_MERCHANT_KC");
    }
}

public void playCantBuySfx() {
    int roll = MathUtils.random(2);
    if (roll == 0) {
        CardCrawlGame.sound.play("VO_MERCHANT_2A");
    } else if (roll == 1) {
        CardCrawlGame.sound.play("VO_MERCHANT_2B");
    } else {
        CardCrawlGame.sound.play("VO_MERCHANT_2C");
    }
}
```

### 对话气泡系统

商人会显示对话气泡来与玩家交互：

```java
public void createSpeech(String msg) {
    boolean isRight = MathUtils.randomBoolean();
    float x = MathUtils.random(660.0F, 1260.0F) * Settings.scale;
    float y = Settings.HEIGHT - 380.0F * Settings.scale;
    this.speechBubble = new ShopSpeechBubble(x, y, 4.0F, msg, isRight);
    
    float offset_x = 0.0F;
    if (isRight) {
        offset_x = SPEECH_TEXT_R_X;
    } else {
        offset_x = SPEECH_TEXT_L_X;
    }
    
    this.dialogTextEffect = new SpeechTextEffect(x + offset_x, y + SPEECH_TEXT_Y, 4.0F, msg, DialogWord.AppearEffect.BUMP_IN);
}
```

### 空闲消息系统

商人在空闲时会显示随机消息：

```java
private String getIdleMsg() {
    return this.idleMessages.get(MathUtils.random(this.idleMessages.size() - 1));
}

private void updateSpeech() {
    // 更新语音气泡和文本效果
    if (this.speechBubble != null) {
        this.speechBubble.update();
        if (this.speechBubble.hb.hovered && this.speechBubble.duration > 0.3F) {
            this.speechBubble.duration = 0.3F;
            this.dialogTextEffect.duration = 0.3F;
        }
        if (this.speechBubble.isDone) {
            this.speechBubble = null;
        }
    }
    
    if (this.dialogTextEffect != null) {
        this.dialogTextEffect.update();
        if (this.dialogTextEffect.isDone) {
            this.dialogTextEffect = null;
        }
    }
    
    // 定期显示空闲消息
    this.speechTimer -= Gdx.graphics.getDeltaTime();
    if (this.speechBubble == null && this.dialogTextEffect == null && this.speechTimer <= 0.0F) {
        this.speechTimer = MathUtils.random(40.0F, 60.0F);
        if (!this.saidWelcome) {
            createSpeech(WELCOME_MSG);
            this.saidWelcome = true;
            welcomeSfx();
        } else {
            playMiscSfx();
            createSpeech(getIdleMsg());
        }
    }
}
```

## 手势动画系统

### 手势跟踪

商店中有一个手势系统会跟随鼠标移动：

```java
public void moveHand(float x, float y) {
    this.handTargetX = x - 50.0F * Settings.xScale;
    this.handTargetY = y + 90.0F * Settings.yScale;
}

private void updateHand() {
    if (this.handTimer == 0.0F) {
        if (this.handX != this.handTargetX) {
            this.handX = MathUtils.lerp(this.handX, this.handTargetX, Gdx.graphics.getDeltaTime() * 6.0F);
        }
        if (this.handY != this.handTargetY) {
            if (this.handY > this.handTargetY) {
                this.handY = MathUtils.lerp(this.handY, this.handTargetY, Gdx.graphics.getDeltaTime() * 6.0F);
            } else {
                this.handY = MathUtils.lerp(this.handY, this.handTargetY, Gdx.graphics.getDeltaTime() * 6.0F / 4.0F);
            }
        }
    }
}
```

## 控制器支持

### 控制器输入处理

商店系统完全支持控制器操作：

```java
private void updateControllerInput() {
    if (!Settings.isControllerMode || !shouldProcessControllerInput()) {
        return;
    }
    
    StoreSelectionType type = null;
    int index = 0;
    
    // 检测当前选中的项目类型
    type = detectCurrentSelection();
    
    if (type == null) {
        // 如果没有选中项目，移动到第一个可用项目
        moveToFirstAvailableItem();
    } else {
        // 处理控制器导航
        handleControllerNavigation(type, index);
    }
}
```

## 本地化支持

### 多语言图像加载

商店系统根据语言设置加载不同的图像：

```java
private void loadLocalizedImages() {
    if (rugImg == null) {
        switch (Settings.language) {
            case ZHS:
                rugImg = ImageMaster.loadImage("images/npcs/rug/zhs.png");
                removeServiceImg = ImageMaster.loadImage("images/npcs/purge/zhs.png");
                soldOutImg = ImageMaster.loadImage("images/npcs/sold_out/zhs.png");
                break;
            case JPN:
                rugImg = ImageMaster.loadImage("images/npcs/rug/jpn.png");
                removeServiceImg = ImageMaster.loadImage("images/npcs/purge/jpn.png");
                soldOutImg = ImageMaster.loadImage("images/npcs/sold_out/jpn.png");
                break;
            // ... 其他语言
            default:
                rugImg = ImageMaster.loadImage("images/npcs/rug/eng.png");
                removeServiceImg = ImageMaster.loadImage("images/npcs/purge/eng.png");
                soldOutImg = ImageMaster.loadImage("images/npcs/sold_out/eng.png");
                break;
        }
        handImg = ImageMaster.loadImage("images/npcs/merchantHand.png");
    }
}
```

## 触摸屏支持

### 触摸屏交互

商店系统专门为触摸屏设备提供了交互支持：

```java
private void resetTouchscreenVars() {
    if (Settings.isTouchScreen) {
        this.confirmButton.hide();
        this.confirmButton.isDisabled = false;
        this.touchRelic = null;
        this.touchCard = null;
        this.touchPotion = null;
        this.touchPurge = false;
    }
}

// 在update方法中处理触摸屏输入
if (Settings.isTouchScreen) {
    this.confirmButton.update();
    if (InputHelper.justClickedLeft && this.confirmButton.hb.hovered) {
        this.confirmButton.hb.clickStarted = true;
    }
    
    if (InputHelper.justReleasedClickLeft && !this.confirmButton.hb.hovered) {
        resetTouchscreenVars();
    } else if (this.confirmButton.hb.clicked) {
        this.confirmButton.hb.clicked = false;
        processTouchscreenPurchase();
    }
}
```

## 性能优化

### 价格缓存

系统会缓存价格计算结果以提高性能：

```java
public void getNewPrice(StoreRelic r) {
    int retVal = r.price;
    
    if (!Settings.isDailyRun) {
        retVal = MathUtils.round(retVal * AbstractDungeon.merchantRng.random(0.95F, 1.05F));
    }
    
    // 应用折扣
    if (AbstractDungeon.player.hasRelic("The Courier")) {
        retVal = applyDiscountToRelic(retVal, 0.8F);
    }
    if (AbstractDungeon.player.hasRelic("Membership Card")) {
        retVal = applyDiscountToRelic(retVal, 0.5F);
    }
    
    r.price = retVal;
}
```

## 设计模式与最佳实践

### 策略模式

不同类型商品使用不同的定价策略：
- 卡牌：基于稀有度的基础价格 + 随机波动
- 遗物：基于稀有度的固定价格
- 药水：统一的基础价格

### 观察者模式

遗物系统通过观察者模式影响商店价格：
- `The Courier`: 20%折扣
- `Membership Card`: 50%折扣
- `Smiling Mask`: 固定删除价格

### 状态模式

商店的不同状态（打开、关闭、购买中）通过状态模式管理。

### 工厂模式

商品通过工厂方法创建：
- `StoreRelic`工厂方法
- `StorePotion`工厂方法

## 总结

杀戮尖塔的商店系统是一个精心设计的经济系统，它通过以下机制为玩家提供了丰富的战略选择：

1. **多样化商品**: 卡牌、遗物、药水和删除服务
2. **动态定价**: 基于稀有度、随机波动和折扣的价格系统
3. **特殊效果**: 遗物对商店行为的独特影响
4. **丰富的交互**: 语音、对话气泡和手势动画
5. **完整的输入支持**: 鼠标、键盘、控制器和触摸屏
6. **本地化支持**: 多语言图像和文本
7. **性能优化**: 价格缓存和高效的更新机制

这个系统的设计使得商店成为游戏策略的重要组成部分，玩家需要在有限的金币和多样化的商品之间做出明智的选择。