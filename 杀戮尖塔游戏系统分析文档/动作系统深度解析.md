# 杀戮尖塔动作系统深度解析

## 概述

杀戮尖塔的动作系统是游戏的核心机制之一，负责管理所有游戏中的动作执行，包括卡牌使用、伤害计算、能力应用等。该系统采用队列式设计，确保动作按顺序执行，并提供了丰富的动作类型和执行控制机制。

## 核心组件

### 1. AbstractGameAction - 动作基类

`AbstractGameAction` 是所有动作的抽象基类，定义了动作的基本框架和生命周期。

```java
public abstract class AbstractGameAction {
    protected static final float DEFAULT_DURATION = 0.5F;
    protected float duration;
    protected float startDuration;
    public ActionType actionType;
    public DamageInfo.DamageType damageType;
    public boolean isDone = false;
    public int amount;
    public AttackEffect attackEffect = AttackEffect.NONE;
    public AbstractCreature target;
    public AbstractCreature source;
    
    public abstract void update();
    
    protected void tickDuration() {
        this.duration -= Gdx.graphics.getDeltaTime();
        if (this.duration < 0.0F) {
            this.isDone = true;
        }
    }
}
```

#### 关键属性

- **duration**: 动作持续时间，用于控制动画和时序
- **actionType**: 动作类型枚举，用于分类和识别
- **damageType**: 伤害类型，影响伤害计算和抗性
- **isDone**: 动作完成标志
- **target/source**: 动作的目标和来源

#### 动作类型 (ActionType)

```java
public enum ActionType {
    BLOCK, POWER, CARD_MANIPULATION, DAMAGE, DEBUFF, 
    DISCARD, DRAW, EXHAUST, HEAL, ENERGY, TEXT, USE, 
    CLEAR_CARD_QUEUE, DIALOG, SPECIAL, WAIT, SHUFFLE, REDUCE_POWER
}
```

#### 攻击效果 (AttackEffect)

```java
public enum AttackEffect {
    BLUNT_LIGHT, BLUNT_HEAVY, SLASH_DIAGONAL, SMASH, 
    SLASH_HEAVY, SLASH_HORIZONTAL, SLASH_VERTICAL, 
    NONE, FIRE, POISON, SHIELD, LIGHTNING
}
```

### 2. GameActionManager - 动作管理器

`GameActionManager` 是动作系统的核心管理类，负责动作队列的管理和执行调度。

```java
public class GameActionManager {
    private ArrayList<AbstractGameAction> nextCombatActions = new ArrayList<>();
    public ArrayList<AbstractGameAction> actions = new ArrayList<>();
    public ArrayList<AbstractGameAction> preTurnActions = new ArrayList<>();
    public ArrayList<CardQueueItem> cardQueue = new ArrayList<>();
    public ArrayList<MonsterQueueItem> monsterQueue = new ArrayList<>();
    
    public AbstractGameAction currentAction;
    public Phase phase = Phase.WAITING_ON_USER;
    public boolean hasControl = true;
    public boolean turnHasEnded = false;
    public boolean usingCard = false;
    
    public enum Phase {
        WAITING_ON_USER, EXECUTING_ACTIONS;
    }
}
```

#### 队列系统

动作管理器维护多个队列，用于不同类型的动作：

1. **actions**: 主要动作队列，按顺序执行
2. **preTurnActions**: 回合开始前动作队列
3. **nextCombatActions**: 下场战斗动作队列
4. **cardQueue**: 卡牌使用队列
5. **monsterQueue**: 怪物动作队列

#### 动作添加方法

```java
// 添加到队列底部
public void addToBottom(AbstractGameAction action) {
    if ((AbstractDungeon.getCurrRoom()).phase == AbstractRoom.RoomPhase.COMBAT) {
        this.actions.add(action);
    }
}

// 添加到队列顶部
public void addToTop(AbstractGameAction action) {
    if ((AbstractDungeon.getCurrRoom()).phase == AbstractRoom.RoomPhase.COMBAT) {
        this.actions.add(0, action);
    }
}

// 添加到回合开始前
public void addToTurnStart(AbstractGameAction action) {
    if ((AbstractDungeon.getCurrRoom()).phase == AbstractRoom.RoomPhase.COMBAT) {
        this.preTurnActions.add(0, action);
    }
}
```

### 3. 动作执行流程

#### 主更新循环

```java
public void update() {
    switch (this.phase) {
        case WAITING_ON_USER:
            getNextAction();
            return;
        case EXECUTING_ACTIONS:
            if (this.currentAction != null && !this.currentAction.isDone) {
                this.currentAction.update();
            } else {
                this.previousAction = this.currentAction;
                this.currentAction = null;
                getNextAction();
                
                if (this.currentAction == null && 
                    (AbstractDungeon.getCurrRoom()).phase == AbstractRoom.RoomPhase.COMBAT && 
                    !this.usingCard) {
                    this.phase = Phase.WAITING_ON_USER;
                    AbstractDungeon.player.hand.refreshHandLayout();
                    this.hasControl = false;
                }
                this.usingCard = false;
            }
            return;
    }
}
```

#### 动作获取逻辑

```java
private void getNextAction() {
    // 1. 优先执行主动作队列
    if (!this.actions.isEmpty()) {
        this.currentAction = this.actions.remove(0);
        this.phase = Phase.EXECUTING_ACTIONS;
        this.hasControl = true;
    }
    // 2. 然后执行回合前动作
    else if (!this.preTurnActions.isEmpty()) {
        this.currentAction = this.preTurnActions.remove(0);
        this.phase = Phase.EXECUTING_ACTIONS;
        this.hasControl = true;
    }
    // 3. 然后处理卡牌队列
    else if (!this.cardQueue.isEmpty()) {
        // 处理卡牌使用逻辑
        processCardQueue();
    }
    // 4. 然后处理怪物队列
    else if (!this.monsterAttacksQueued) {
        this.monsterAttacksQueued = true;
        if (!(AbstractDungeon.getCurrRoom()).skipMonsterTurn) {
            (AbstractDungeon.getCurrRoom()).monsters.queueMonsters();
        }
    }
    // 5. 最后处理回合结束逻辑
    else if (this.turnHasEnded && !AbstractDungeon.getMonsters().areMonstersBasicallyDead()) {
        processEndOfTurn();
    }
}
```

## 具体动作实现

### 1. DamageAction - 伤害动作

`DamageAction` 是最常用的动作之一，负责处理伤害计算和应用。

```java
public class DamageAction extends AbstractGameAction {
    private DamageInfo info;
    private int goldAmount = 0;
    private static final float DURATION = 0.1F;
    private boolean skipWait = false, muteSfx = false;
    
    public void update() {
        if (shouldCancelAction() && this.info.type != DamageInfo.DamageType.THORNS) {
            this.isDone = true;
            return;
        }
        
        if (this.duration == 0.1F) {
            // 检查攻击者是否死亡
            if (this.info.type != DamageInfo.DamageType.THORNS && 
                (this.info.owner.isDying || this.info.owner.halfDead)) {
                this.isDone = true;
                return;
            }
            
            // 添加攻击特效
            AbstractDungeon.effectList.add(new FlashAtkImgEffect(
                this.target.hb.cX, this.target.hb.cY, this.attackEffect, this.muteSfx));
            
            // 处理金币偷取
            if (this.goldAmount != 0) {
                stealGold();
            }
        }
        
        tickDuration();
        
        if (this.isDone) {
            // 应用颜色效果
            if (this.attackEffect == AbstractGameAction.AttackEffect.POISON) {
                this.target.tint.color.set(Color.CHARTREUSE.cpy());
                this.target.tint.changeColor(Color.WHITE.cpy());
            } else if (this.attackEffect == AbstractGameAction.AttackEffect.FIRE) {
                this.target.tint.color.set(Color.RED);
                this.target.tint.changeColor(Color.WHITE.cpy());
            }
            
            // 实际造成伤害
            this.target.damage(this.info);
            
            // 检查战斗是否结束
            if ((AbstractDungeon.getCurrRoom()).monsters.areMonstersBasicallyDead()) {
                AbstractDungeon.actionManager.clearPostCombatActions();
            }
            
            // 添加等待动作
            if (!this.skipWait && !Settings.FAST_MODE) {
                addToTop(new WaitAction(0.1F));
            }
        }
    }
}
```

### 2. DrawCardAction - 抽牌动作

```java
public class DrawCardAction extends AbstractGameAction {
    private boolean shuffleCheck = false;
    
    public DrawCardAction(AbstractCreature source, int amount) {
        this.setValues(source, source, amount);
        this.actionType = ActionType.DRAW;
        this.duration = Settings.ACTION_DUR_FAST;
    }
    
    public void update() {
        if (this.duration == Settings.ACTION_DUR_FAST) {
            // 检查牌堆是否为空
            if (AbstractDungeon.player.drawPile.isEmpty()) {
                // 洗牌逻辑
                if (!this.shuffleCheck) {
                    AbstractDungeon.player.drawPile.shuffle();
                    this.shuffleCheck = true;
                } else {
                    this.isDone = true;
                    return;
                }
            }
            
            // 执行抽牌
            for (int i = 0; i < this.amount; i++) {
                if (!AbstractDungeon.player.drawPile.isEmpty()) {
                    AbstractCard c = AbstractDungeon.player.drawPile.pickCard(true);
                    AbstractDungeon.player.drawPile.removeCard(c);
                    AbstractDungeon.player.hand.addToTop(c);
                }
            }
            
            // 刷新手牌布局
            AbstractDungeon.player.hand.refreshHandLayout();
            AbstractDungeon.player.hand.applyPowers();
        }
        
        this.tickDuration();
    }
}
```

### 3. ApplyPowerAction - 能力应用动作

```java
public class ApplyPowerAction extends AbstractGameAction {
    private AbstractPower powerToApply;
    private boolean stackPower = true;
    
    public void update() {
        if (this.duration == Settings.ACTION_DUR_FAST) {
            // 检查是否应该取消动作
            if (shouldCancelAction()) {
                this.isDone = true;
                return;
            }
            
            // 应用能力
            if (this.stackPower) {
                this.target.powers.add(this.powerToApply);
                this.powerToApply.onInitialApplication();
                
                // 触发能力应用事件
                for (AbstractPower p : this.target.powers) {
                    if (p != this.powerToApply) {
                        p.onApplyPower(this.powerToApply, this.target, this.source);
                    }
                }
                
                // 触发遗物效果
                for (AbstractRelic r : AbstractDungeon.player.relics) {
                    r.onApplyPower(this.powerToApply, this.target, this.source);
                }
            } else {
                // 替换能力逻辑
                for (int i = 0; i < this.target.powers.size(); i++) {
                    if (this.target.powers.get(i).ID.equals(this.powerToApply.ID)) {
                        this.target.powers.get(i).onRemove();
                        this.target.powers.set(i, this.powerToApply);
                        this.powerToApply.onInitialApplication();
                        break;
                    }
                }
            }
        }
        
        this.tickDuration();
    }
}
```

## 卡牌队列系统

### CardQueueItem - 卡牌队列项

```java
public class CardQueueItem {
    public AbstractCard card;
    public AbstractMonster monster;
    public int energyOnUse;
    public boolean autoplayCard;
    public boolean ignoreEnergyTotal;
    public boolean isEndTurnAutoPlay;
    public boolean randomTarget;
}
```

### 卡牌使用流程

1. **卡牌添加到队列**: 玩家选择卡牌后，卡牌被添加到 `cardQueue`
2. **卡牌验证**: 检查卡牌是否可以使用
3. **触发前置事件**: 触发能力、遗物等的 `onPlayCard` 事件
4. **能量消耗**: 扣除相应能量
5. **卡牌使用**: 调用 `AbstractPlayer.useCard()` 方法
6. **后置处理**: 处理卡牌使用后的效果

```java
// 卡牌队列处理逻辑
if (!this.cardQueue.isEmpty()) {
    this.usingCard = true;
    AbstractCard c = ((CardQueueItem)this.cardQueue.get(0)).card;
    
    // 检查卡牌是否可以使用
    if (c != null && (c.canUse(AbstractDungeon.player, ((CardQueueItem)this.cardQueue.get(0)).monster) || 
        ((CardQueueItem)this.cardQueue.get(0)).card.dontTriggerOnUseCard)) {
        
        // 触发onPlayCard事件
        for (AbstractPower p : AbstractDungeon.player.powers) {
            p.onPlayCard(((CardQueueItem)this.cardQueue.get(0)).card, ((CardQueueItem)this.cardQueue.get(0)).monster);
        }
        
        // 使用卡牌
        AbstractDungeon.player.useCard(((CardQueueItem)this.cardQueue.get(0)).card, 
                                     ((CardQueueItem)this.cardQueue.get(0)).monster, 
                                     ((CardQueueItem)this.cardQueue.get(0)).energyOnUse);
    }
    
    this.cardQueue.remove(0);
}
```

## 回合管理系统

### 回合开始流程

```java
// 回合开始时的处理
if (this.turnHasEnded && !AbstractDungeon.getMonsters().areMonstersBasicallyDead()) {
    // 应用回合结束效果
    if (!(AbstractDungeon.getCurrRoom()).skipMonsterTurn) {
        (AbstractDungeon.getCurrRoom()).monsters.applyEndOfTurnPowers();
    }
    
    // 重置玩家状态
    AbstractDungeon.player.cardsPlayedThisTurn = 0;
    this.orbsChanneledThisTurn.clear();
    
    // 应用回合开始效果
    AbstractDungeon.player.applyStartOfTurnRelics();
    AbstractDungeon.player.applyStartOfTurnPreDrawCards();
    AbstractDungeon.player.applyStartOfTurnCards();
    AbstractDungeon.player.applyStartOfTurnPowers();
    AbstractDungeon.player.applyStartOfTurnOrbs();
    
    // 增加回合数
    turn++;
    
    // 重置格挡（除非有特殊能力）
    if (!AbstractDungeon.player.hasPower("Barricade") && !AbstractDungeon.player.hasPower("Blur")) {
        if (!AbstractDungeon.player.hasRelic("Calipers")) {
            AbstractDungeon.player.loseBlock();
        } else {
            AbstractDungeon.player.loseBlock(15);
        }
    }
    
    // 抽牌
    if (!(AbstractDungeon.getCurrRoom()).isBattleOver) {
        addToBottom(new DrawCardAction(null, AbstractDungeon.player.gameHandSize, true));
        AbstractDungeon.player.applyStartOfTurnPostDrawRelics();
        AbstractDungeon.player.applyStartOfTurnPostDrawPowers();
        addToBottom(new EnableEndTurnButtonAction());
    }
}
```

### 回合结束流程

```java
public void endTurn() {
    AbstractDungeon.player.resetControllerValues();
    this.turnHasEnded = true;
    playerHpLastTurn = AbstractDungeon.player.currentHealth;
}

private void callEndOfTurnActions() {
    AbstractDungeon.getCurrRoom().applyEndOfTurnRelics();
    AbstractDungeon.getCurrRoom().applyEndOfTurnPreCardPowers();
    addToBottom(new TriggerEndOfTurnOrbsAction());
    
    // 触发手牌中卡牌的回合结束效果
    for (AbstractCard c : AbstractDungeon.player.hand.group) {
        c.triggerOnEndOfTurnForPlayingCard();
    }
    
    AbstractDungeon.player.stance.onEndOfTurn();
}
```

## 性能优化机制

### 1. 动作队列清理

```java
public void clearPostCombatActions() {
    for (Iterator<AbstractGameAction> i = this.actions.iterator(); i.hasNext(); ) {
        AbstractGameAction e = i.next();
        if (e instanceof HealAction || e instanceof GainBlockAction || 
            e instanceof UseCardAction || e.actionType == AbstractGameAction.ActionType.DAMAGE) {
            continue;
        }
        i.remove();
    }
}
```

### 2. 快速模式支持

```java
// 在快速模式下跳过等待动作
if (!this.skipWait && !Settings.FAST_MODE) {
    addToTop(new WaitAction(0.1F));
}
```

### 3. 动作取消检查

```java
protected boolean shouldCancelAction() {
    return (this.target == null || 
            (this.source != null && this.source.isDying) || 
            this.target.isDeadOrEscaped());
}
```

## 设计模式分析

### 1. 命令模式 (Command Pattern)

动作系统采用命令模式，每个动作都是一个命令对象，封装了执行操作的所有信息：

- **命令接口**: `AbstractGameAction` 抽象类
- **具体命令**: 各种动作实现类
- **调用者**: `GameActionManager`
- **接收者**: 游戏中的各种对象（角色、怪物等）

### 2. 队列模式 (Queue Pattern)

使用多个队列来管理不同类型的动作，确保执行顺序和优先级：

- **FIFO队列**: 主动作队列按先进先出顺序执行
- **优先级队列**: 回合前动作具有更高优先级
- **分离队列**: 卡牌和怪物动作分别管理

### 3. 状态模式 (State Pattern)

动作管理器使用状态模式来管理执行状态：

- **状态枚举**: `Phase` 枚举定义了等待和执行两种状态
- **状态转换**: 根据条件在状态间转换
- **状态行为**: 不同状态下有不同的行为逻辑

## 扩展机制

### 1. 自定义动作创建

```java
public class CustomAction extends AbstractGameAction {
    public CustomAction(AbstractCreature target, int amount) {
        this.target = target;
        this.amount = amount;
        this.actionType = ActionType.SPECIAL;
        this.duration = Settings.ACTION_DUR_FAST;
    }
    
    @Override
    public void update() {
        if (this.duration == Settings.ACTION_DUR_FAST) {
            // 自定义逻辑
            this.target.heal(this.amount);
            
            // 添加特效
            AbstractDungeon.effectList.add(new HealEffect(this.target.hb.cX, this.target.hb.cY, this.amount));
        }
        
        this.tickDuration();
    }
}
```

### 2. 动作组合

```java
// 创建动作序列
public void createActionSequence() {
    ArrayList<AbstractGameAction> actions = new ArrayList<>();
    actions.add(new DamageAction(target, new DamageInfo(source, 10)));
    actions.add(new ApplyPowerAction(target, source, new WeakPower(target, 1, false)));
    actions.add(new DrawCardAction(source, 2));
    
    // 按顺序添加到动作队列
    for (AbstractGameAction action : actions) {
        AbstractDungeon.actionManager.addToBottom(action);
    }
}
```

### 3. 条件动作

```java
public class ConditionalAction extends AbstractGameAction {
    private Runnable condition;
    private AbstractGameAction trueAction;
    private AbstractGameAction falseAction;
    
    @Override
    public void update() {
        if (this.duration == Settings.ACTION_DUR_FAST) {
            if (condition != null) {
                condition.run();
            }
            
            if (evaluateCondition()) {
                addToBottom(trueAction);
            } else {
                addToBottom(falseAction);
            }
        }
        
        this.tickDuration();
    }
}
```

## 调试和监控

### 1. 动作日志

```java
public class ActionLogger {
    private static final Logger logger = LogManager.getLogger(ActionLogger.class.getName());
    
    public static void logAction(AbstractGameAction action) {
        logger.info("Executing action: " + action.getClass().getSimpleName() + 
                   " Target: " + (action.target != null ? action.target.getClass().getSimpleName() : "null") +
                   " Amount: " + action.amount);
    }
}
```

### 2. 性能监控

```java
public class ActionProfiler {
    private static Map<String, Long> actionTimes = new HashMap<>();
    
    public static void profileAction(AbstractGameAction action) {
        String className = action.getClass().getSimpleName();
        long startTime = System.nanoTime();
        
        // 执行动作
        action.update();
        
        long endTime = System.nanoTime();
        long duration = endTime - startTime;
        
        actionTimes.put(className, actionTimes.getOrDefault(className, 0L) + duration);
    }
}
```

## 总结

杀戮尖塔的动作系统是一个精心设计的队列式执行系统，具有以下特点：

1. **模块化设计**: 每个动作都是独立的模块，易于扩展和维护
2. **时序控制**: 通过duration机制精确控制动作时序
3. **队列管理**: 多级队列确保动作按正确顺序执行
4. **状态管理**: 清晰的状态转换机制
5. **事件集成**: 与游戏其他系统紧密集成
6. **性能优化**: 多种优化机制确保流畅运行

这个系统为游戏提供了强大的动作执行能力，支持复杂的游戏逻辑和丰富的交互效果，是杀戮尖塔游戏体验的核心基础。